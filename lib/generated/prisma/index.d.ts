
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Domain
 * 
 */
export type Domain = $Result.DefaultSelection<Prisma.$DomainPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model LearningPath
 * 
 */
export type LearningPath = $Result.DefaultSelection<Prisma.$LearningPathPayload>
/**
 * Model LearningPathItem
 * 
 */
export type LearningPathItem = $Result.DefaultSelection<Prisma.$LearningPathItemPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Chapter
 * 
 */
export type Chapter = $Result.DefaultSelection<Prisma.$ChapterPayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model Workshop
 * 
 */
export type Workshop = $Result.DefaultSelection<Prisma.$WorkshopPayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model LearningPathResource
 * 
 */
export type LearningPathResource = $Result.DefaultSelection<Prisma.$LearningPathResourcePayload>
/**
 * Model CourseResource
 * 
 */
export type CourseResource = $Result.DefaultSelection<Prisma.$CourseResourcePayload>
/**
 * Model LessonResource
 * 
 */
export type LessonResource = $Result.DefaultSelection<Prisma.$LessonResourcePayload>
/**
 * Model WorkshopResource
 * 
 */
export type WorkshopResource = $Result.DefaultSelection<Prisma.$WorkshopResourcePayload>
/**
 * Model LessonProgress
 * 
 */
export type LessonProgress = $Result.DefaultSelection<Prisma.$LessonProgressPayload>
/**
 * Model UserProgress
 * 
 */
export type UserProgress = $Result.DefaultSelection<Prisma.$UserProgressPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model CourseTag
 * 
 */
export type CourseTag = $Result.DefaultSelection<Prisma.$CourseTagPayload>
/**
 * Model WorkshopTag
 * 
 */
export type WorkshopTag = $Result.DefaultSelection<Prisma.$WorkshopTagPayload>
/**
 * Model LearningPathTag
 * 
 */
export type LearningPathTag = $Result.DefaultSelection<Prisma.$LearningPathTagPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model PromoCode
 * 
 */
export type PromoCode = $Result.DefaultSelection<Prisma.$PromoCodePayload>
/**
 * Model Enrollment
 * 
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model Objective
 * 
 */
export type Objective = $Result.DefaultSelection<Prisma.$ObjectivePayload>
/**
 * Model Prerequisite
 * 
 */
export type Prerequisite = $Result.DefaultSelection<Prisma.$PrerequisitePayload>
/**
 * Model CourseObjective
 * 
 */
export type CourseObjective = $Result.DefaultSelection<Prisma.$CourseObjectivePayload>
/**
 * Model CoursePrerequisite
 * 
 */
export type CoursePrerequisite = $Result.DefaultSelection<Prisma.$CoursePrerequisitePayload>
/**
 * Model WorkshopObjective
 * 
 */
export type WorkshopObjective = $Result.DefaultSelection<Prisma.$WorkshopObjectivePayload>
/**
 * Model WorkshopPrerequisite
 * 
 */
export type WorkshopPrerequisite = $Result.DefaultSelection<Prisma.$WorkshopPrerequisitePayload>
/**
 * Model LearningPathObjective
 * 
 */
export type LearningPathObjective = $Result.DefaultSelection<Prisma.$LearningPathObjectivePayload>
/**
 * Model LearningPathPrerequisite
 * 
 */
export type LearningPathPrerequisite = $Result.DefaultSelection<Prisma.$LearningPathPrerequisitePayload>
/**
 * Model Feature
 * 
 */
export type Feature = $Result.DefaultSelection<Prisma.$FeaturePayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model SocialLink
 * 
 */
export type SocialLink = $Result.DefaultSelection<Prisma.$SocialLinkPayload>
/**
 * Model CompanySocialLink
 * 
 */
export type CompanySocialLink = $Result.DefaultSelection<Prisma.$CompanySocialLinkPayload>
/**
 * Model Page
 * 
 */
export type Page = $Result.DefaultSelection<Prisma.$PagePayload>
/**
 * Model Quiz
 * 
 */
export type Quiz = $Result.DefaultSelection<Prisma.$QuizPayload>
/**
 * Model QuizQuestion
 * 
 */
export type QuizQuestion = $Result.DefaultSelection<Prisma.$QuizQuestionPayload>
/**
 * Model QuizOption
 * 
 */
export type QuizOption = $Result.DefaultSelection<Prisma.$QuizOptionPayload>
/**
 * Model QuizResult
 * 
 */
export type QuizResult = $Result.DefaultSelection<Prisma.$QuizResultPayload>
/**
 * Model Testimonial
 * 
 */
export type Testimonial = $Result.DefaultSelection<Prisma.$TestimonialPayload>
/**
 * Model NewsletterSubscription
 * 
 */
export type NewsletterSubscription = $Result.DefaultSelection<Prisma.$NewsletterSubscriptionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  STUDENT: 'STUDENT',
  INSTRUCTOR: 'INSTRUCTOR',
  ADMIN: 'ADMIN',
  MODERATOR: 'MODERATOR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const Levels: {
  Beginner: 'Beginner',
  Intermediate: 'Intermediate',
  Advanced: 'Advanced',
  Expert: 'Expert'
};

export type Levels = (typeof Levels)[keyof typeof Levels]


export const Status: {
  Draft: 'Draft',
  Published: 'Published',
  Archived: 'Archived'
};

export type Status = (typeof Status)[keyof typeof Status]


export const ResourceType: {
  PDF: 'PDF',
  Link: 'Link',
  Tool: 'Tool',
  Video: 'Video'
};

export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]


export const ItemType: {
  Course: 'Course',
  Workshop: 'Workshop',
  Resource: 'Resource',
  Evaluation: 'Evaluation'
};

export type ItemType = (typeof ItemType)[keyof typeof ItemType]


export const DiscountType: {
  PERCENTAGE: 'PERCENTAGE',
  FIXED: 'FIXED'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const InvoiceItemType: {
  COURSE: 'COURSE',
  WORKSHOP: 'WORKSHOP',
  SUBSCRIPTION: 'SUBSCRIPTION',
  LEARNING_PATH: 'LEARNING_PATH'
};

export type InvoiceItemType = (typeof InvoiceItemType)[keyof typeof InvoiceItemType]


export const enrollmentStatus: {
  Pending: 'Pending',
  Active: 'Active',
  Cancelled: 'Cancelled'
};

export type enrollmentStatus = (typeof enrollmentStatus)[keyof typeof enrollmentStatus]


export const PaymentStatus: {
  Succeeded: 'Succeeded',
  Pending: 'Pending',
  Failed: 'Failed'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const QuizType: {
  CHAPTER: 'CHAPTER',
  COURSE: 'COURSE'
};

export type QuizType = (typeof QuizType)[keyof typeof QuizType]


export const QuestionType: {
  SINGLE_CHOICE: 'SINGLE_CHOICE',
  MULTIPLE_CHOICE: 'MULTIPLE_CHOICE',
  TRUE_FALSE: 'TRUE_FALSE'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type Levels = $Enums.Levels

export const Levels: typeof $Enums.Levels

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type ResourceType = $Enums.ResourceType

export const ResourceType: typeof $Enums.ResourceType

export type ItemType = $Enums.ItemType

export const ItemType: typeof $Enums.ItemType

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

export type InvoiceItemType = $Enums.InvoiceItemType

export const InvoiceItemType: typeof $Enums.InvoiceItemType

export type enrollmentStatus = $Enums.enrollmentStatus

export const enrollmentStatus: typeof $Enums.enrollmentStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type QuizType = $Enums.QuizType

export const QuizType: typeof $Enums.QuizType

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domain`: Exposes CRUD operations for the **Domain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Domains
    * const domains = await prisma.domain.findMany()
    * ```
    */
  get domain(): Prisma.DomainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningPath`: Exposes CRUD operations for the **LearningPath** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningPaths
    * const learningPaths = await prisma.learningPath.findMany()
    * ```
    */
  get learningPath(): Prisma.LearningPathDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningPathItem`: Exposes CRUD operations for the **LearningPathItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningPathItems
    * const learningPathItems = await prisma.learningPathItem.findMany()
    * ```
    */
  get learningPathItem(): Prisma.LearningPathItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapter`: Exposes CRUD operations for the **Chapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapter.findMany()
    * ```
    */
  get chapter(): Prisma.ChapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workshop`: Exposes CRUD operations for the **Workshop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workshops
    * const workshops = await prisma.workshop.findMany()
    * ```
    */
  get workshop(): Prisma.WorkshopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningPathResource`: Exposes CRUD operations for the **LearningPathResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningPathResources
    * const learningPathResources = await prisma.learningPathResource.findMany()
    * ```
    */
  get learningPathResource(): Prisma.LearningPathResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseResource`: Exposes CRUD operations for the **CourseResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseResources
    * const courseResources = await prisma.courseResource.findMany()
    * ```
    */
  get courseResource(): Prisma.CourseResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonResource`: Exposes CRUD operations for the **LessonResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonResources
    * const lessonResources = await prisma.lessonResource.findMany()
    * ```
    */
  get lessonResource(): Prisma.LessonResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workshopResource`: Exposes CRUD operations for the **WorkshopResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkshopResources
    * const workshopResources = await prisma.workshopResource.findMany()
    * ```
    */
  get workshopResource(): Prisma.WorkshopResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonProgress`: Exposes CRUD operations for the **LessonProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonProgresses
    * const lessonProgresses = await prisma.lessonProgress.findMany()
    * ```
    */
  get lessonProgress(): Prisma.LessonProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProgress`: Exposes CRUD operations for the **UserProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProgresses
    * const userProgresses = await prisma.userProgress.findMany()
    * ```
    */
  get userProgress(): Prisma.UserProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseTag`: Exposes CRUD operations for the **CourseTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseTags
    * const courseTags = await prisma.courseTag.findMany()
    * ```
    */
  get courseTag(): Prisma.CourseTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workshopTag`: Exposes CRUD operations for the **WorkshopTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkshopTags
    * const workshopTags = await prisma.workshopTag.findMany()
    * ```
    */
  get workshopTag(): Prisma.WorkshopTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningPathTag`: Exposes CRUD operations for the **LearningPathTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningPathTags
    * const learningPathTags = await prisma.learningPathTag.findMany()
    * ```
    */
  get learningPathTag(): Prisma.LearningPathTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promoCode`: Exposes CRUD operations for the **PromoCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoCodes
    * const promoCodes = await prisma.promoCode.findMany()
    * ```
    */
  get promoCode(): Prisma.PromoCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.objective`: Exposes CRUD operations for the **Objective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Objectives
    * const objectives = await prisma.objective.findMany()
    * ```
    */
  get objective(): Prisma.ObjectiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prerequisite`: Exposes CRUD operations for the **Prerequisite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prerequisites
    * const prerequisites = await prisma.prerequisite.findMany()
    * ```
    */
  get prerequisite(): Prisma.PrerequisiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseObjective`: Exposes CRUD operations for the **CourseObjective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseObjectives
    * const courseObjectives = await prisma.courseObjective.findMany()
    * ```
    */
  get courseObjective(): Prisma.CourseObjectiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coursePrerequisite`: Exposes CRUD operations for the **CoursePrerequisite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoursePrerequisites
    * const coursePrerequisites = await prisma.coursePrerequisite.findMany()
    * ```
    */
  get coursePrerequisite(): Prisma.CoursePrerequisiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workshopObjective`: Exposes CRUD operations for the **WorkshopObjective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkshopObjectives
    * const workshopObjectives = await prisma.workshopObjective.findMany()
    * ```
    */
  get workshopObjective(): Prisma.WorkshopObjectiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workshopPrerequisite`: Exposes CRUD operations for the **WorkshopPrerequisite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkshopPrerequisites
    * const workshopPrerequisites = await prisma.workshopPrerequisite.findMany()
    * ```
    */
  get workshopPrerequisite(): Prisma.WorkshopPrerequisiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningPathObjective`: Exposes CRUD operations for the **LearningPathObjective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningPathObjectives
    * const learningPathObjectives = await prisma.learningPathObjective.findMany()
    * ```
    */
  get learningPathObjective(): Prisma.LearningPathObjectiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningPathPrerequisite`: Exposes CRUD operations for the **LearningPathPrerequisite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningPathPrerequisites
    * const learningPathPrerequisites = await prisma.learningPathPrerequisite.findMany()
    * ```
    */
  get learningPathPrerequisite(): Prisma.LearningPathPrerequisiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feature`: Exposes CRUD operations for the **Feature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Features
    * const features = await prisma.feature.findMany()
    * ```
    */
  get feature(): Prisma.FeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialLink`: Exposes CRUD operations for the **SocialLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialLinks
    * const socialLinks = await prisma.socialLink.findMany()
    * ```
    */
  get socialLink(): Prisma.SocialLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companySocialLink`: Exposes CRUD operations for the **CompanySocialLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanySocialLinks
    * const companySocialLinks = await prisma.companySocialLink.findMany()
    * ```
    */
  get companySocialLink(): Prisma.CompanySocialLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.page`: Exposes CRUD operations for the **Page** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pages
    * const pages = await prisma.page.findMany()
    * ```
    */
  get page(): Prisma.PageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **Quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.QuizDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestion`: Exposes CRUD operations for the **QuizQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestions
    * const quizQuestions = await prisma.quizQuestion.findMany()
    * ```
    */
  get quizQuestion(): Prisma.QuizQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizOption`: Exposes CRUD operations for the **QuizOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizOptions
    * const quizOptions = await prisma.quizOption.findMany()
    * ```
    */
  get quizOption(): Prisma.QuizOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizResult`: Exposes CRUD operations for the **QuizResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizResults
    * const quizResults = await prisma.quizResult.findMany()
    * ```
    */
  get quizResult(): Prisma.QuizResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testimonial`: Exposes CRUD operations for the **Testimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testimonials
    * const testimonials = await prisma.testimonial.findMany()
    * ```
    */
  get testimonial(): Prisma.TestimonialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsletterSubscription`: Exposes CRUD operations for the **NewsletterSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsletterSubscriptions
    * const newsletterSubscriptions = await prisma.newsletterSubscription.findMany()
    * ```
    */
  get newsletterSubscription(): Prisma.NewsletterSubscriptionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Domain: 'Domain',
    Category: 'Category',
    LearningPath: 'LearningPath',
    LearningPathItem: 'LearningPathItem',
    Course: 'Course',
    Chapter: 'Chapter',
    Lesson: 'Lesson',
    Workshop: 'Workshop',
    Resource: 'Resource',
    LearningPathResource: 'LearningPathResource',
    CourseResource: 'CourseResource',
    LessonResource: 'LessonResource',
    WorkshopResource: 'WorkshopResource',
    LessonProgress: 'LessonProgress',
    UserProgress: 'UserProgress',
    Tag: 'Tag',
    CourseTag: 'CourseTag',
    WorkshopTag: 'WorkshopTag',
    LearningPathTag: 'LearningPathTag',
    Promotion: 'Promotion',
    PromoCode: 'PromoCode',
    Enrollment: 'Enrollment',
    Payment: 'Payment',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Objective: 'Objective',
    Prerequisite: 'Prerequisite',
    CourseObjective: 'CourseObjective',
    CoursePrerequisite: 'CoursePrerequisite',
    WorkshopObjective: 'WorkshopObjective',
    WorkshopPrerequisite: 'WorkshopPrerequisite',
    LearningPathObjective: 'LearningPathObjective',
    LearningPathPrerequisite: 'LearningPathPrerequisite',
    Feature: 'Feature',
    Company: 'Company',
    SocialLink: 'SocialLink',
    CompanySocialLink: 'CompanySocialLink',
    Page: 'Page',
    Quiz: 'Quiz',
    QuizQuestion: 'QuizQuestion',
    QuizOption: 'QuizOption',
    QuizResult: 'QuizResult',
    Testimonial: 'Testimonial',
    NewsletterSubscription: 'NewsletterSubscription'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "domain" | "category" | "learningPath" | "learningPathItem" | "course" | "chapter" | "lesson" | "workshop" | "resource" | "learningPathResource" | "courseResource" | "lessonResource" | "workshopResource" | "lessonProgress" | "userProgress" | "tag" | "courseTag" | "workshopTag" | "learningPathTag" | "promotion" | "promoCode" | "enrollment" | "payment" | "invoice" | "invoiceItem" | "objective" | "prerequisite" | "courseObjective" | "coursePrerequisite" | "workshopObjective" | "workshopPrerequisite" | "learningPathObjective" | "learningPathPrerequisite" | "feature" | "company" | "socialLink" | "companySocialLink" | "page" | "quiz" | "quizQuestion" | "quizOption" | "quizResult" | "testimonial" | "newsletterSubscription"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Domain: {
        payload: Prisma.$DomainPayload<ExtArgs>
        fields: Prisma.DomainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          findFirst: {
            args: Prisma.DomainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          findMany: {
            args: Prisma.DomainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>[]
          }
          create: {
            args: Prisma.DomainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          createMany: {
            args: Prisma.DomainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>[]
          }
          delete: {
            args: Prisma.DomainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          update: {
            args: Prisma.DomainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          deleteMany: {
            args: Prisma.DomainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>[]
          }
          upsert: {
            args: Prisma.DomainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          aggregate: {
            args: Prisma.DomainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomain>
          }
          groupBy: {
            args: Prisma.DomainGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainCountArgs<ExtArgs>
            result: $Utils.Optional<DomainCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      LearningPath: {
        payload: Prisma.$LearningPathPayload<ExtArgs>
        fields: Prisma.LearningPathFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningPathFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningPathFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>
          }
          findFirst: {
            args: Prisma.LearningPathFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningPathFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>
          }
          findMany: {
            args: Prisma.LearningPathFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>[]
          }
          create: {
            args: Prisma.LearningPathCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>
          }
          createMany: {
            args: Prisma.LearningPathCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningPathCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>[]
          }
          delete: {
            args: Prisma.LearningPathDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>
          }
          update: {
            args: Prisma.LearningPathUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>
          }
          deleteMany: {
            args: Prisma.LearningPathDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningPathUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningPathUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>[]
          }
          upsert: {
            args: Prisma.LearningPathUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>
          }
          aggregate: {
            args: Prisma.LearningPathAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningPath>
          }
          groupBy: {
            args: Prisma.LearningPathGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningPathGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningPathCountArgs<ExtArgs>
            result: $Utils.Optional<LearningPathCountAggregateOutputType> | number
          }
        }
      }
      LearningPathItem: {
        payload: Prisma.$LearningPathItemPayload<ExtArgs>
        fields: Prisma.LearningPathItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningPathItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningPathItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>
          }
          findFirst: {
            args: Prisma.LearningPathItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningPathItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>
          }
          findMany: {
            args: Prisma.LearningPathItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>[]
          }
          create: {
            args: Prisma.LearningPathItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>
          }
          createMany: {
            args: Prisma.LearningPathItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningPathItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>[]
          }
          delete: {
            args: Prisma.LearningPathItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>
          }
          update: {
            args: Prisma.LearningPathItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>
          }
          deleteMany: {
            args: Prisma.LearningPathItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningPathItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningPathItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>[]
          }
          upsert: {
            args: Prisma.LearningPathItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>
          }
          aggregate: {
            args: Prisma.LearningPathItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningPathItem>
          }
          groupBy: {
            args: Prisma.LearningPathItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningPathItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningPathItemCountArgs<ExtArgs>
            result: $Utils.Optional<LearningPathItemCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Chapter: {
        payload: Prisma.$ChapterPayload<ExtArgs>
        fields: Prisma.ChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findFirst: {
            args: Prisma.ChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findMany: {
            args: Prisma.ChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          create: {
            args: Prisma.ChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          createMany: {
            args: Prisma.ChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          delete: {
            args: Prisma.ChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          update: {
            args: Prisma.ChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          deleteMany: {
            args: Prisma.ChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChapterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          upsert: {
            args: Prisma.ChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          aggregate: {
            args: Prisma.ChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapter>
          }
          groupBy: {
            args: Prisma.ChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      Workshop: {
        payload: Prisma.$WorkshopPayload<ExtArgs>
        fields: Prisma.WorkshopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkshopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkshopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          findFirst: {
            args: Prisma.WorkshopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkshopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          findMany: {
            args: Prisma.WorkshopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>[]
          }
          create: {
            args: Prisma.WorkshopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          createMany: {
            args: Prisma.WorkshopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkshopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>[]
          }
          delete: {
            args: Prisma.WorkshopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          update: {
            args: Prisma.WorkshopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          deleteMany: {
            args: Prisma.WorkshopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkshopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkshopUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>[]
          }
          upsert: {
            args: Prisma.WorkshopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          aggregate: {
            args: Prisma.WorkshopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkshop>
          }
          groupBy: {
            args: Prisma.WorkshopGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkshopGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkshopCountArgs<ExtArgs>
            result: $Utils.Optional<WorkshopCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      LearningPathResource: {
        payload: Prisma.$LearningPathResourcePayload<ExtArgs>
        fields: Prisma.LearningPathResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningPathResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningPathResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathResourcePayload>
          }
          findFirst: {
            args: Prisma.LearningPathResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningPathResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathResourcePayload>
          }
          findMany: {
            args: Prisma.LearningPathResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathResourcePayload>[]
          }
          create: {
            args: Prisma.LearningPathResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathResourcePayload>
          }
          createMany: {
            args: Prisma.LearningPathResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningPathResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathResourcePayload>[]
          }
          delete: {
            args: Prisma.LearningPathResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathResourcePayload>
          }
          update: {
            args: Prisma.LearningPathResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathResourcePayload>
          }
          deleteMany: {
            args: Prisma.LearningPathResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningPathResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningPathResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathResourcePayload>[]
          }
          upsert: {
            args: Prisma.LearningPathResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathResourcePayload>
          }
          aggregate: {
            args: Prisma.LearningPathResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningPathResource>
          }
          groupBy: {
            args: Prisma.LearningPathResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningPathResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningPathResourceCountArgs<ExtArgs>
            result: $Utils.Optional<LearningPathResourceCountAggregateOutputType> | number
          }
        }
      }
      CourseResource: {
        payload: Prisma.$CourseResourcePayload<ExtArgs>
        fields: Prisma.CourseResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseResourcePayload>
          }
          findFirst: {
            args: Prisma.CourseResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseResourcePayload>
          }
          findMany: {
            args: Prisma.CourseResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseResourcePayload>[]
          }
          create: {
            args: Prisma.CourseResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseResourcePayload>
          }
          createMany: {
            args: Prisma.CourseResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseResourcePayload>[]
          }
          delete: {
            args: Prisma.CourseResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseResourcePayload>
          }
          update: {
            args: Prisma.CourseResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseResourcePayload>
          }
          deleteMany: {
            args: Prisma.CourseResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseResourcePayload>[]
          }
          upsert: {
            args: Prisma.CourseResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseResourcePayload>
          }
          aggregate: {
            args: Prisma.CourseResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseResource>
          }
          groupBy: {
            args: Prisma.CourseResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseResourceCountArgs<ExtArgs>
            result: $Utils.Optional<CourseResourceCountAggregateOutputType> | number
          }
        }
      }
      LessonResource: {
        payload: Prisma.$LessonResourcePayload<ExtArgs>
        fields: Prisma.LessonResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonResourcePayload>
          }
          findFirst: {
            args: Prisma.LessonResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonResourcePayload>
          }
          findMany: {
            args: Prisma.LessonResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonResourcePayload>[]
          }
          create: {
            args: Prisma.LessonResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonResourcePayload>
          }
          createMany: {
            args: Prisma.LessonResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonResourcePayload>[]
          }
          delete: {
            args: Prisma.LessonResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonResourcePayload>
          }
          update: {
            args: Prisma.LessonResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonResourcePayload>
          }
          deleteMany: {
            args: Prisma.LessonResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonResourcePayload>[]
          }
          upsert: {
            args: Prisma.LessonResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonResourcePayload>
          }
          aggregate: {
            args: Prisma.LessonResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonResource>
          }
          groupBy: {
            args: Prisma.LessonResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonResourceCountArgs<ExtArgs>
            result: $Utils.Optional<LessonResourceCountAggregateOutputType> | number
          }
        }
      }
      WorkshopResource: {
        payload: Prisma.$WorkshopResourcePayload<ExtArgs>
        fields: Prisma.WorkshopResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkshopResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkshopResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopResourcePayload>
          }
          findFirst: {
            args: Prisma.WorkshopResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkshopResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopResourcePayload>
          }
          findMany: {
            args: Prisma.WorkshopResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopResourcePayload>[]
          }
          create: {
            args: Prisma.WorkshopResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopResourcePayload>
          }
          createMany: {
            args: Prisma.WorkshopResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkshopResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopResourcePayload>[]
          }
          delete: {
            args: Prisma.WorkshopResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopResourcePayload>
          }
          update: {
            args: Prisma.WorkshopResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopResourcePayload>
          }
          deleteMany: {
            args: Prisma.WorkshopResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkshopResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkshopResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopResourcePayload>[]
          }
          upsert: {
            args: Prisma.WorkshopResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopResourcePayload>
          }
          aggregate: {
            args: Prisma.WorkshopResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkshopResource>
          }
          groupBy: {
            args: Prisma.WorkshopResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkshopResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkshopResourceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkshopResourceCountAggregateOutputType> | number
          }
        }
      }
      LessonProgress: {
        payload: Prisma.$LessonProgressPayload<ExtArgs>
        fields: Prisma.LessonProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          findFirst: {
            args: Prisma.LessonProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          findMany: {
            args: Prisma.LessonProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>[]
          }
          create: {
            args: Prisma.LessonProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          createMany: {
            args: Prisma.LessonProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>[]
          }
          delete: {
            args: Prisma.LessonProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          update: {
            args: Prisma.LessonProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          deleteMany: {
            args: Prisma.LessonProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>[]
          }
          upsert: {
            args: Prisma.LessonProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          aggregate: {
            args: Prisma.LessonProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonProgress>
          }
          groupBy: {
            args: Prisma.LessonProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonProgressCountArgs<ExtArgs>
            result: $Utils.Optional<LessonProgressCountAggregateOutputType> | number
          }
        }
      }
      UserProgress: {
        payload: Prisma.$UserProgressPayload<ExtArgs>
        fields: Prisma.UserProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findFirst: {
            args: Prisma.UserProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findMany: {
            args: Prisma.UserProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          create: {
            args: Prisma.UserProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          createMany: {
            args: Prisma.UserProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          delete: {
            args: Prisma.UserProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          update: {
            args: Prisma.UserProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          upsert: {
            args: Prisma.UserProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          aggregate: {
            args: Prisma.UserProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProgress>
          }
          groupBy: {
            args: Prisma.UserProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserProgressCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      CourseTag: {
        payload: Prisma.$CourseTagPayload<ExtArgs>
        fields: Prisma.CourseTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          findFirst: {
            args: Prisma.CourseTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          findMany: {
            args: Prisma.CourseTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>[]
          }
          create: {
            args: Prisma.CourseTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          createMany: {
            args: Prisma.CourseTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>[]
          }
          delete: {
            args: Prisma.CourseTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          update: {
            args: Prisma.CourseTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          deleteMany: {
            args: Prisma.CourseTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>[]
          }
          upsert: {
            args: Prisma.CourseTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          aggregate: {
            args: Prisma.CourseTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseTag>
          }
          groupBy: {
            args: Prisma.CourseTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseTagCountArgs<ExtArgs>
            result: $Utils.Optional<CourseTagCountAggregateOutputType> | number
          }
        }
      }
      WorkshopTag: {
        payload: Prisma.$WorkshopTagPayload<ExtArgs>
        fields: Prisma.WorkshopTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkshopTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkshopTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTagPayload>
          }
          findFirst: {
            args: Prisma.WorkshopTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkshopTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTagPayload>
          }
          findMany: {
            args: Prisma.WorkshopTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTagPayload>[]
          }
          create: {
            args: Prisma.WorkshopTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTagPayload>
          }
          createMany: {
            args: Prisma.WorkshopTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkshopTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTagPayload>[]
          }
          delete: {
            args: Prisma.WorkshopTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTagPayload>
          }
          update: {
            args: Prisma.WorkshopTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTagPayload>
          }
          deleteMany: {
            args: Prisma.WorkshopTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkshopTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkshopTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTagPayload>[]
          }
          upsert: {
            args: Prisma.WorkshopTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTagPayload>
          }
          aggregate: {
            args: Prisma.WorkshopTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkshopTag>
          }
          groupBy: {
            args: Prisma.WorkshopTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkshopTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkshopTagCountArgs<ExtArgs>
            result: $Utils.Optional<WorkshopTagCountAggregateOutputType> | number
          }
        }
      }
      LearningPathTag: {
        payload: Prisma.$LearningPathTagPayload<ExtArgs>
        fields: Prisma.LearningPathTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningPathTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningPathTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathTagPayload>
          }
          findFirst: {
            args: Prisma.LearningPathTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningPathTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathTagPayload>
          }
          findMany: {
            args: Prisma.LearningPathTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathTagPayload>[]
          }
          create: {
            args: Prisma.LearningPathTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathTagPayload>
          }
          createMany: {
            args: Prisma.LearningPathTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningPathTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathTagPayload>[]
          }
          delete: {
            args: Prisma.LearningPathTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathTagPayload>
          }
          update: {
            args: Prisma.LearningPathTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathTagPayload>
          }
          deleteMany: {
            args: Prisma.LearningPathTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningPathTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningPathTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathTagPayload>[]
          }
          upsert: {
            args: Prisma.LearningPathTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathTagPayload>
          }
          aggregate: {
            args: Prisma.LearningPathTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningPathTag>
          }
          groupBy: {
            args: Prisma.LearningPathTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningPathTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningPathTagCountArgs<ExtArgs>
            result: $Utils.Optional<LearningPathTagCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromotionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      PromoCode: {
        payload: Prisma.$PromoCodePayload<ExtArgs>
        fields: Prisma.PromoCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findFirst: {
            args: Prisma.PromoCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findMany: {
            args: Prisma.PromoCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          create: {
            args: Prisma.PromoCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          createMany: {
            args: Prisma.PromoCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromoCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          delete: {
            args: Prisma.PromoCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          update: {
            args: Prisma.PromoCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          deleteMany: {
            args: Prisma.PromoCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromoCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          upsert: {
            args: Prisma.PromoCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          aggregate: {
            args: Prisma.PromoCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoCode>
          }
          groupBy: {
            args: Prisma.PromoCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoCodeCountArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeCountAggregateOutputType> | number
          }
        }
      }
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>
        fields: Prisma.EnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Objective: {
        payload: Prisma.$ObjectivePayload<ExtArgs>
        fields: Prisma.ObjectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>
          }
          findFirst: {
            args: Prisma.ObjectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>
          }
          findMany: {
            args: Prisma.ObjectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>[]
          }
          create: {
            args: Prisma.ObjectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>
          }
          createMany: {
            args: Prisma.ObjectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ObjectiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>[]
          }
          delete: {
            args: Prisma.ObjectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>
          }
          update: {
            args: Prisma.ObjectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>
          }
          deleteMany: {
            args: Prisma.ObjectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ObjectiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>[]
          }
          upsert: {
            args: Prisma.ObjectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>
          }
          aggregate: {
            args: Prisma.ObjectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObjective>
          }
          groupBy: {
            args: Prisma.ObjectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObjectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectiveCountArgs<ExtArgs>
            result: $Utils.Optional<ObjectiveCountAggregateOutputType> | number
          }
        }
      }
      Prerequisite: {
        payload: Prisma.$PrerequisitePayload<ExtArgs>
        fields: Prisma.PrerequisiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrerequisiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrerequisiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>
          }
          findFirst: {
            args: Prisma.PrerequisiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrerequisiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>
          }
          findMany: {
            args: Prisma.PrerequisiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>[]
          }
          create: {
            args: Prisma.PrerequisiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>
          }
          createMany: {
            args: Prisma.PrerequisiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrerequisiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>[]
          }
          delete: {
            args: Prisma.PrerequisiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>
          }
          update: {
            args: Prisma.PrerequisiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>
          }
          deleteMany: {
            args: Prisma.PrerequisiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrerequisiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrerequisiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>[]
          }
          upsert: {
            args: Prisma.PrerequisiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>
          }
          aggregate: {
            args: Prisma.PrerequisiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrerequisite>
          }
          groupBy: {
            args: Prisma.PrerequisiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrerequisiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrerequisiteCountArgs<ExtArgs>
            result: $Utils.Optional<PrerequisiteCountAggregateOutputType> | number
          }
        }
      }
      CourseObjective: {
        payload: Prisma.$CourseObjectivePayload<ExtArgs>
        fields: Prisma.CourseObjectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseObjectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseObjectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>
          }
          findFirst: {
            args: Prisma.CourseObjectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseObjectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>
          }
          findMany: {
            args: Prisma.CourseObjectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>[]
          }
          create: {
            args: Prisma.CourseObjectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>
          }
          createMany: {
            args: Prisma.CourseObjectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseObjectiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>[]
          }
          delete: {
            args: Prisma.CourseObjectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>
          }
          update: {
            args: Prisma.CourseObjectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>
          }
          deleteMany: {
            args: Prisma.CourseObjectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseObjectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseObjectiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>[]
          }
          upsert: {
            args: Prisma.CourseObjectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseObjectivePayload>
          }
          aggregate: {
            args: Prisma.CourseObjectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseObjective>
          }
          groupBy: {
            args: Prisma.CourseObjectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseObjectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseObjectiveCountArgs<ExtArgs>
            result: $Utils.Optional<CourseObjectiveCountAggregateOutputType> | number
          }
        }
      }
      CoursePrerequisite: {
        payload: Prisma.$CoursePrerequisitePayload<ExtArgs>
        fields: Prisma.CoursePrerequisiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoursePrerequisiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePrerequisitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoursePrerequisiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePrerequisitePayload>
          }
          findFirst: {
            args: Prisma.CoursePrerequisiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePrerequisitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoursePrerequisiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePrerequisitePayload>
          }
          findMany: {
            args: Prisma.CoursePrerequisiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePrerequisitePayload>[]
          }
          create: {
            args: Prisma.CoursePrerequisiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePrerequisitePayload>
          }
          createMany: {
            args: Prisma.CoursePrerequisiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoursePrerequisiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePrerequisitePayload>[]
          }
          delete: {
            args: Prisma.CoursePrerequisiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePrerequisitePayload>
          }
          update: {
            args: Prisma.CoursePrerequisiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePrerequisitePayload>
          }
          deleteMany: {
            args: Prisma.CoursePrerequisiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoursePrerequisiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoursePrerequisiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePrerequisitePayload>[]
          }
          upsert: {
            args: Prisma.CoursePrerequisiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePrerequisitePayload>
          }
          aggregate: {
            args: Prisma.CoursePrerequisiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoursePrerequisite>
          }
          groupBy: {
            args: Prisma.CoursePrerequisiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoursePrerequisiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoursePrerequisiteCountArgs<ExtArgs>
            result: $Utils.Optional<CoursePrerequisiteCountAggregateOutputType> | number
          }
        }
      }
      WorkshopObjective: {
        payload: Prisma.$WorkshopObjectivePayload<ExtArgs>
        fields: Prisma.WorkshopObjectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkshopObjectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopObjectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkshopObjectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopObjectivePayload>
          }
          findFirst: {
            args: Prisma.WorkshopObjectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopObjectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkshopObjectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopObjectivePayload>
          }
          findMany: {
            args: Prisma.WorkshopObjectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopObjectivePayload>[]
          }
          create: {
            args: Prisma.WorkshopObjectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopObjectivePayload>
          }
          createMany: {
            args: Prisma.WorkshopObjectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkshopObjectiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopObjectivePayload>[]
          }
          delete: {
            args: Prisma.WorkshopObjectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopObjectivePayload>
          }
          update: {
            args: Prisma.WorkshopObjectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopObjectivePayload>
          }
          deleteMany: {
            args: Prisma.WorkshopObjectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkshopObjectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkshopObjectiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopObjectivePayload>[]
          }
          upsert: {
            args: Prisma.WorkshopObjectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopObjectivePayload>
          }
          aggregate: {
            args: Prisma.WorkshopObjectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkshopObjective>
          }
          groupBy: {
            args: Prisma.WorkshopObjectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkshopObjectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkshopObjectiveCountArgs<ExtArgs>
            result: $Utils.Optional<WorkshopObjectiveCountAggregateOutputType> | number
          }
        }
      }
      WorkshopPrerequisite: {
        payload: Prisma.$WorkshopPrerequisitePayload<ExtArgs>
        fields: Prisma.WorkshopPrerequisiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkshopPrerequisiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPrerequisitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkshopPrerequisiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPrerequisitePayload>
          }
          findFirst: {
            args: Prisma.WorkshopPrerequisiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPrerequisitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkshopPrerequisiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPrerequisitePayload>
          }
          findMany: {
            args: Prisma.WorkshopPrerequisiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPrerequisitePayload>[]
          }
          create: {
            args: Prisma.WorkshopPrerequisiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPrerequisitePayload>
          }
          createMany: {
            args: Prisma.WorkshopPrerequisiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkshopPrerequisiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPrerequisitePayload>[]
          }
          delete: {
            args: Prisma.WorkshopPrerequisiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPrerequisitePayload>
          }
          update: {
            args: Prisma.WorkshopPrerequisiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPrerequisitePayload>
          }
          deleteMany: {
            args: Prisma.WorkshopPrerequisiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkshopPrerequisiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkshopPrerequisiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPrerequisitePayload>[]
          }
          upsert: {
            args: Prisma.WorkshopPrerequisiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPrerequisitePayload>
          }
          aggregate: {
            args: Prisma.WorkshopPrerequisiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkshopPrerequisite>
          }
          groupBy: {
            args: Prisma.WorkshopPrerequisiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkshopPrerequisiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkshopPrerequisiteCountArgs<ExtArgs>
            result: $Utils.Optional<WorkshopPrerequisiteCountAggregateOutputType> | number
          }
        }
      }
      LearningPathObjective: {
        payload: Prisma.$LearningPathObjectivePayload<ExtArgs>
        fields: Prisma.LearningPathObjectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningPathObjectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathObjectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningPathObjectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathObjectivePayload>
          }
          findFirst: {
            args: Prisma.LearningPathObjectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathObjectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningPathObjectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathObjectivePayload>
          }
          findMany: {
            args: Prisma.LearningPathObjectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathObjectivePayload>[]
          }
          create: {
            args: Prisma.LearningPathObjectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathObjectivePayload>
          }
          createMany: {
            args: Prisma.LearningPathObjectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningPathObjectiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathObjectivePayload>[]
          }
          delete: {
            args: Prisma.LearningPathObjectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathObjectivePayload>
          }
          update: {
            args: Prisma.LearningPathObjectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathObjectivePayload>
          }
          deleteMany: {
            args: Prisma.LearningPathObjectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningPathObjectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningPathObjectiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathObjectivePayload>[]
          }
          upsert: {
            args: Prisma.LearningPathObjectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathObjectivePayload>
          }
          aggregate: {
            args: Prisma.LearningPathObjectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningPathObjective>
          }
          groupBy: {
            args: Prisma.LearningPathObjectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningPathObjectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningPathObjectiveCountArgs<ExtArgs>
            result: $Utils.Optional<LearningPathObjectiveCountAggregateOutputType> | number
          }
        }
      }
      LearningPathPrerequisite: {
        payload: Prisma.$LearningPathPrerequisitePayload<ExtArgs>
        fields: Prisma.LearningPathPrerequisiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningPathPrerequisiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPrerequisitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningPathPrerequisiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPrerequisitePayload>
          }
          findFirst: {
            args: Prisma.LearningPathPrerequisiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPrerequisitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningPathPrerequisiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPrerequisitePayload>
          }
          findMany: {
            args: Prisma.LearningPathPrerequisiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPrerequisitePayload>[]
          }
          create: {
            args: Prisma.LearningPathPrerequisiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPrerequisitePayload>
          }
          createMany: {
            args: Prisma.LearningPathPrerequisiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningPathPrerequisiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPrerequisitePayload>[]
          }
          delete: {
            args: Prisma.LearningPathPrerequisiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPrerequisitePayload>
          }
          update: {
            args: Prisma.LearningPathPrerequisiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPrerequisitePayload>
          }
          deleteMany: {
            args: Prisma.LearningPathPrerequisiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningPathPrerequisiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningPathPrerequisiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPrerequisitePayload>[]
          }
          upsert: {
            args: Prisma.LearningPathPrerequisiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPrerequisitePayload>
          }
          aggregate: {
            args: Prisma.LearningPathPrerequisiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningPathPrerequisite>
          }
          groupBy: {
            args: Prisma.LearningPathPrerequisiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningPathPrerequisiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningPathPrerequisiteCountArgs<ExtArgs>
            result: $Utils.Optional<LearningPathPrerequisiteCountAggregateOutputType> | number
          }
        }
      }
      Feature: {
        payload: Prisma.$FeaturePayload<ExtArgs>
        fields: Prisma.FeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findFirst: {
            args: Prisma.FeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findMany: {
            args: Prisma.FeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          create: {
            args: Prisma.FeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          createMany: {
            args: Prisma.FeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          delete: {
            args: Prisma.FeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          update: {
            args: Prisma.FeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          deleteMany: {
            args: Prisma.FeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          upsert: {
            args: Prisma.FeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          aggregate: {
            args: Prisma.FeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeature>
          }
          groupBy: {
            args: Prisma.FeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      SocialLink: {
        payload: Prisma.$SocialLinkPayload<ExtArgs>
        fields: Prisma.SocialLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          findFirst: {
            args: Prisma.SocialLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          findMany: {
            args: Prisma.SocialLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>[]
          }
          create: {
            args: Prisma.SocialLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          createMany: {
            args: Prisma.SocialLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>[]
          }
          delete: {
            args: Prisma.SocialLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          update: {
            args: Prisma.SocialLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          deleteMany: {
            args: Prisma.SocialLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SocialLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>[]
          }
          upsert: {
            args: Prisma.SocialLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          aggregate: {
            args: Prisma.SocialLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialLink>
          }
          groupBy: {
            args: Prisma.SocialLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialLinkCountArgs<ExtArgs>
            result: $Utils.Optional<SocialLinkCountAggregateOutputType> | number
          }
        }
      }
      CompanySocialLink: {
        payload: Prisma.$CompanySocialLinkPayload<ExtArgs>
        fields: Prisma.CompanySocialLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanySocialLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySocialLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanySocialLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySocialLinkPayload>
          }
          findFirst: {
            args: Prisma.CompanySocialLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySocialLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanySocialLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySocialLinkPayload>
          }
          findMany: {
            args: Prisma.CompanySocialLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySocialLinkPayload>[]
          }
          create: {
            args: Prisma.CompanySocialLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySocialLinkPayload>
          }
          createMany: {
            args: Prisma.CompanySocialLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanySocialLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySocialLinkPayload>[]
          }
          delete: {
            args: Prisma.CompanySocialLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySocialLinkPayload>
          }
          update: {
            args: Prisma.CompanySocialLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySocialLinkPayload>
          }
          deleteMany: {
            args: Prisma.CompanySocialLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanySocialLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanySocialLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySocialLinkPayload>[]
          }
          upsert: {
            args: Prisma.CompanySocialLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySocialLinkPayload>
          }
          aggregate: {
            args: Prisma.CompanySocialLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanySocialLink>
          }
          groupBy: {
            args: Prisma.CompanySocialLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanySocialLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanySocialLinkCountArgs<ExtArgs>
            result: $Utils.Optional<CompanySocialLinkCountAggregateOutputType> | number
          }
        }
      }
      Page: {
        payload: Prisma.$PagePayload<ExtArgs>
        fields: Prisma.PageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findFirst: {
            args: Prisma.PageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findMany: {
            args: Prisma.PageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          create: {
            args: Prisma.PageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          createMany: {
            args: Prisma.PageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          delete: {
            args: Prisma.PageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          update: {
            args: Prisma.PageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          deleteMany: {
            args: Prisma.PageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          upsert: {
            args: Prisma.PageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          aggregate: {
            args: Prisma.PageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePage>
          }
          groupBy: {
            args: Prisma.PageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageCountArgs<ExtArgs>
            result: $Utils.Optional<PageCountAggregateOutputType> | number
          }
        }
      }
      Quiz: {
        payload: Prisma.$QuizPayload<ExtArgs>
        fields: Prisma.QuizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findFirst: {
            args: Prisma.QuizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findMany: {
            args: Prisma.QuizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          create: {
            args: Prisma.QuizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          createMany: {
            args: Prisma.QuizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          delete: {
            args: Prisma.QuizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          update: {
            args: Prisma.QuizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          deleteMany: {
            args: Prisma.QuizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          upsert: {
            args: Prisma.QuizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          aggregate: {
            args: Prisma.QuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz>
          }
          groupBy: {
            args: Prisma.QuizGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizCountArgs<ExtArgs>
            result: $Utils.Optional<QuizCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestion: {
        payload: Prisma.$QuizQuestionPayload<ExtArgs>
        fields: Prisma.QuizQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          update: {
            args: Prisma.QuizQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuizQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestion>
          }
          groupBy: {
            args: Prisma.QuizQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionCountAggregateOutputType> | number
          }
        }
      }
      QuizOption: {
        payload: Prisma.$QuizOptionPayload<ExtArgs>
        fields: Prisma.QuizOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>
          }
          findFirst: {
            args: Prisma.QuizOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>
          }
          findMany: {
            args: Prisma.QuizOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>[]
          }
          create: {
            args: Prisma.QuizOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>
          }
          createMany: {
            args: Prisma.QuizOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>[]
          }
          delete: {
            args: Prisma.QuizOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>
          }
          update: {
            args: Prisma.QuizOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>
          }
          deleteMany: {
            args: Prisma.QuizOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>[]
          }
          upsert: {
            args: Prisma.QuizOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>
          }
          aggregate: {
            args: Prisma.QuizOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizOption>
          }
          groupBy: {
            args: Prisma.QuizOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizOptionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizOptionCountAggregateOutputType> | number
          }
        }
      }
      QuizResult: {
        payload: Prisma.$QuizResultPayload<ExtArgs>
        fields: Prisma.QuizResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>
          }
          findFirst: {
            args: Prisma.QuizResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>
          }
          findMany: {
            args: Prisma.QuizResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>[]
          }
          create: {
            args: Prisma.QuizResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>
          }
          createMany: {
            args: Prisma.QuizResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>[]
          }
          delete: {
            args: Prisma.QuizResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>
          }
          update: {
            args: Prisma.QuizResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>
          }
          deleteMany: {
            args: Prisma.QuizResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>[]
          }
          upsert: {
            args: Prisma.QuizResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResultPayload>
          }
          aggregate: {
            args: Prisma.QuizResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizResult>
          }
          groupBy: {
            args: Prisma.QuizResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizResultCountArgs<ExtArgs>
            result: $Utils.Optional<QuizResultCountAggregateOutputType> | number
          }
        }
      }
      Testimonial: {
        payload: Prisma.$TestimonialPayload<ExtArgs>
        fields: Prisma.TestimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findFirst: {
            args: Prisma.TestimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findMany: {
            args: Prisma.TestimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          create: {
            args: Prisma.TestimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          createMany: {
            args: Prisma.TestimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestimonialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          delete: {
            args: Prisma.TestimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          update: {
            args: Prisma.TestimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          deleteMany: {
            args: Prisma.TestimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestimonialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          upsert: {
            args: Prisma.TestimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          aggregate: {
            args: Prisma.TestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonial>
          }
          groupBy: {
            args: Prisma.TestimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestimonialCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialCountAggregateOutputType> | number
          }
        }
      }
      NewsletterSubscription: {
        payload: Prisma.$NewsletterSubscriptionPayload<ExtArgs>
        fields: Prisma.NewsletterSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsletterSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsletterSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.NewsletterSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsletterSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          findMany: {
            args: Prisma.NewsletterSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>[]
          }
          create: {
            args: Prisma.NewsletterSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          createMany: {
            args: Prisma.NewsletterSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsletterSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.NewsletterSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          update: {
            args: Prisma.NewsletterSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.NewsletterSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsletterSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsletterSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.NewsletterSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.NewsletterSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletterSubscription>
          }
          groupBy: {
            args: Prisma.NewsletterSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsletterSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsletterSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<NewsletterSubscriptionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    domain?: DomainOmit
    category?: CategoryOmit
    learningPath?: LearningPathOmit
    learningPathItem?: LearningPathItemOmit
    course?: CourseOmit
    chapter?: ChapterOmit
    lesson?: LessonOmit
    workshop?: WorkshopOmit
    resource?: ResourceOmit
    learningPathResource?: LearningPathResourceOmit
    courseResource?: CourseResourceOmit
    lessonResource?: LessonResourceOmit
    workshopResource?: WorkshopResourceOmit
    lessonProgress?: LessonProgressOmit
    userProgress?: UserProgressOmit
    tag?: TagOmit
    courseTag?: CourseTagOmit
    workshopTag?: WorkshopTagOmit
    learningPathTag?: LearningPathTagOmit
    promotion?: PromotionOmit
    promoCode?: PromoCodeOmit
    enrollment?: EnrollmentOmit
    payment?: PaymentOmit
    invoice?: InvoiceOmit
    invoiceItem?: InvoiceItemOmit
    objective?: ObjectiveOmit
    prerequisite?: PrerequisiteOmit
    courseObjective?: CourseObjectiveOmit
    coursePrerequisite?: CoursePrerequisiteOmit
    workshopObjective?: WorkshopObjectiveOmit
    workshopPrerequisite?: WorkshopPrerequisiteOmit
    learningPathObjective?: LearningPathObjectiveOmit
    learningPathPrerequisite?: LearningPathPrerequisiteOmit
    feature?: FeatureOmit
    company?: CompanyOmit
    socialLink?: SocialLinkOmit
    companySocialLink?: CompanySocialLinkOmit
    page?: PageOmit
    quiz?: QuizOmit
    quizQuestion?: QuizQuestionOmit
    quizOption?: QuizOptionOmit
    quizResult?: QuizResultOmit
    testimonial?: TestimonialOmit
    newsletterSubscription?: NewsletterSubscriptionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    lessonProgress: number
    enrollment: number
    payments: number
    invoices: number
    courses: number
    learningPaths: number
    workshops: number
    resources: number
    quiz: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    lessonProgress?: boolean | UserCountOutputTypeCountLessonProgressArgs
    enrollment?: boolean | UserCountOutputTypeCountEnrollmentArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    courses?: boolean | UserCountOutputTypeCountCoursesArgs
    learningPaths?: boolean | UserCountOutputTypeCountLearningPathsArgs
    workshops?: boolean | UserCountOutputTypeCountWorkshopsArgs
    resources?: boolean | UserCountOutputTypeCountResourcesArgs
    quiz?: boolean | UserCountOutputTypeCountQuizArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLearningPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkshopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuizArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }


  /**
   * Count Type DomainCountOutputType
   */

  export type DomainCountOutputType = {
    categories: number
  }

  export type DomainCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | DomainCountOutputTypeCountCategoriesArgs
  }

  // Custom InputTypes
  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCountOutputType
     */
    select?: DomainCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    courses: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | CategoryCountOutputTypeCountCoursesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }


  /**
   * Count Type LearningPathCountOutputType
   */

  export type LearningPathCountOutputType = {
    tags: number
    contents: number
    progress: number
    resources: number
    objectives: number
    prerequisites: number
    promoCodes: number
    promotions: number
    enrollments: number
    payments: number
  }

  export type LearningPathCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | LearningPathCountOutputTypeCountTagsArgs
    contents?: boolean | LearningPathCountOutputTypeCountContentsArgs
    progress?: boolean | LearningPathCountOutputTypeCountProgressArgs
    resources?: boolean | LearningPathCountOutputTypeCountResourcesArgs
    objectives?: boolean | LearningPathCountOutputTypeCountObjectivesArgs
    prerequisites?: boolean | LearningPathCountOutputTypeCountPrerequisitesArgs
    promoCodes?: boolean | LearningPathCountOutputTypeCountPromoCodesArgs
    promotions?: boolean | LearningPathCountOutputTypeCountPromotionsArgs
    enrollments?: boolean | LearningPathCountOutputTypeCountEnrollmentsArgs
    payments?: boolean | LearningPathCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathCountOutputType
     */
    select?: LearningPathCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathTagWhereInput
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountContentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathItemWhereInput
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathResourceWhereInput
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountObjectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathObjectiveWhereInput
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountPrerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathPrerequisiteWhereInput
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountPromoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    chapters: number
    enrollments: number
    payments: number
    promotions: number
    promoCodes: number
    tags: number
    progress: number
    resources: number
    learningPathItems: number
    objectives: number
    prerequisites: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | CourseCountOutputTypeCountChaptersArgs
    enrollments?: boolean | CourseCountOutputTypeCountEnrollmentsArgs
    payments?: boolean | CourseCountOutputTypeCountPaymentsArgs
    promotions?: boolean | CourseCountOutputTypeCountPromotionsArgs
    promoCodes?: boolean | CourseCountOutputTypeCountPromoCodesArgs
    tags?: boolean | CourseCountOutputTypeCountTagsArgs
    progress?: boolean | CourseCountOutputTypeCountProgressArgs
    resources?: boolean | CourseCountOutputTypeCountResourcesArgs
    learningPathItems?: boolean | CourseCountOutputTypeCountLearningPathItemsArgs
    objectives?: boolean | CourseCountOutputTypeCountObjectivesArgs
    prerequisites?: boolean | CourseCountOutputTypeCountPrerequisitesArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPromoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTagWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseResourceWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountLearningPathItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathItemWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountObjectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseObjectiveWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPrerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursePrerequisiteWhereInput
  }


  /**
   * Count Type ChapterCountOutputType
   */

  export type ChapterCountOutputType = {
    lessons: number
  }

  export type ChapterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | ChapterCountOutputTypeCountLessonsArgs
  }

  // Custom InputTypes
  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterCountOutputType
     */
    select?: ChapterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    lessonProgress: number
    resources: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessonProgress?: boolean | LessonCountOutputTypeCountLessonProgressArgs
    resources?: boolean | LessonCountOutputTypeCountResourcesArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountLessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonResourceWhereInput
  }


  /**
   * Count Type WorkshopCountOutputType
   */

  export type WorkshopCountOutputType = {
    tags: number
    progress: number
    resources: number
    learningPathItems: number
    objectives: number
    prerequisites: number
    promoCodes: number
    promotions: number
    enrollments: number
    payments: number
  }

  export type WorkshopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | WorkshopCountOutputTypeCountTagsArgs
    progress?: boolean | WorkshopCountOutputTypeCountProgressArgs
    resources?: boolean | WorkshopCountOutputTypeCountResourcesArgs
    learningPathItems?: boolean | WorkshopCountOutputTypeCountLearningPathItemsArgs
    objectives?: boolean | WorkshopCountOutputTypeCountObjectivesArgs
    prerequisites?: boolean | WorkshopCountOutputTypeCountPrerequisitesArgs
    promoCodes?: boolean | WorkshopCountOutputTypeCountPromoCodesArgs
    promotions?: boolean | WorkshopCountOutputTypeCountPromotionsArgs
    enrollments?: boolean | WorkshopCountOutputTypeCountEnrollmentsArgs
    payments?: boolean | WorkshopCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCountOutputType
     */
    select?: WorkshopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopTagWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopResourceWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountLearningPathItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathItemWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountObjectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopObjectiveWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountPrerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopPrerequisiteWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountPromoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type ResourceCountOutputType
   */

  export type ResourceCountOutputType = {
    courseResources: number
    lessonResources: number
    workshopResources: number
    learningPathResources: number
    learningPathItems: number
  }

  export type ResourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseResources?: boolean | ResourceCountOutputTypeCountCourseResourcesArgs
    lessonResources?: boolean | ResourceCountOutputTypeCountLessonResourcesArgs
    workshopResources?: boolean | ResourceCountOutputTypeCountWorkshopResourcesArgs
    learningPathResources?: boolean | ResourceCountOutputTypeCountLearningPathResourcesArgs
    learningPathItems?: boolean | ResourceCountOutputTypeCountLearningPathItemsArgs
  }

  // Custom InputTypes
  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCountOutputType
     */
    select?: ResourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountCourseResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseResourceWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountLessonResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonResourceWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountWorkshopResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopResourceWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountLearningPathResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathResourceWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountLearningPathItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathItemWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    courseTags: number
    workshopTags: number
    learningPathTags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseTags?: boolean | TagCountOutputTypeCountCourseTagsArgs
    workshopTags?: boolean | TagCountOutputTypeCountWorkshopTagsArgs
    learningPathTags?: boolean | TagCountOutputTypeCountLearningPathTagsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountCourseTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountWorkshopTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountLearningPathTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathTagWhereInput
  }


  /**
   * Count Type PromoCodeCountOutputType
   */

  export type PromoCodeCountOutputType = {
    applicableCourses: number
    applicableWorkshops: number
    applicableLearningPaths: number
  }

  export type PromoCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicableCourses?: boolean | PromoCodeCountOutputTypeCountApplicableCoursesArgs
    applicableWorkshops?: boolean | PromoCodeCountOutputTypeCountApplicableWorkshopsArgs
    applicableLearningPaths?: boolean | PromoCodeCountOutputTypeCountApplicableLearningPathsArgs
  }

  // Custom InputTypes
  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeCountOutputType
     */
    select?: PromoCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeCountApplicableCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeCountApplicableWorkshopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopWhereInput
  }

  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeCountApplicableLearningPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type ObjectiveCountOutputType
   */

  export type ObjectiveCountOutputType = {
    courses: number
    workshops: number
    learningPaths: number
  }

  export type ObjectiveCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | ObjectiveCountOutputTypeCountCoursesArgs
    workshops?: boolean | ObjectiveCountOutputTypeCountWorkshopsArgs
    learningPaths?: boolean | ObjectiveCountOutputTypeCountLearningPathsArgs
  }

  // Custom InputTypes
  /**
   * ObjectiveCountOutputType without action
   */
  export type ObjectiveCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectiveCountOutputType
     */
    select?: ObjectiveCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ObjectiveCountOutputType without action
   */
  export type ObjectiveCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseObjectiveWhereInput
  }

  /**
   * ObjectiveCountOutputType without action
   */
  export type ObjectiveCountOutputTypeCountWorkshopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopObjectiveWhereInput
  }

  /**
   * ObjectiveCountOutputType without action
   */
  export type ObjectiveCountOutputTypeCountLearningPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathObjectiveWhereInput
  }


  /**
   * Count Type PrerequisiteCountOutputType
   */

  export type PrerequisiteCountOutputType = {
    courses: number
    workshops: number
    learningPaths: number
  }

  export type PrerequisiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | PrerequisiteCountOutputTypeCountCoursesArgs
    workshops?: boolean | PrerequisiteCountOutputTypeCountWorkshopsArgs
    learningPaths?: boolean | PrerequisiteCountOutputTypeCountLearningPathsArgs
  }

  // Custom InputTypes
  /**
   * PrerequisiteCountOutputType without action
   */
  export type PrerequisiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrerequisiteCountOutputType
     */
    select?: PrerequisiteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrerequisiteCountOutputType without action
   */
  export type PrerequisiteCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursePrerequisiteWhereInput
  }

  /**
   * PrerequisiteCountOutputType without action
   */
  export type PrerequisiteCountOutputTypeCountWorkshopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopPrerequisiteWhereInput
  }

  /**
   * PrerequisiteCountOutputType without action
   */
  export type PrerequisiteCountOutputTypeCountLearningPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathPrerequisiteWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    companySocialLink: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companySocialLink?: boolean | CompanyCountOutputTypeCountCompanySocialLinkArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCompanySocialLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanySocialLinkWhereInput
  }


  /**
   * Count Type SocialLinkCountOutputType
   */

  export type SocialLinkCountOutputType = {
    companySocialLink: number
  }

  export type SocialLinkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companySocialLink?: boolean | SocialLinkCountOutputTypeCountCompanySocialLinkArgs
  }

  // Custom InputTypes
  /**
   * SocialLinkCountOutputType without action
   */
  export type SocialLinkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinkCountOutputType
     */
    select?: SocialLinkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SocialLinkCountOutputType without action
   */
  export type SocialLinkCountOutputTypeCountCompanySocialLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanySocialLinkWhereInput
  }


  /**
   * Count Type QuizCountOutputType
   */

  export type QuizCountOutputType = {
    questions: number
  }

  export type QuizCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuizCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
  }


  /**
   * Count Type QuizQuestionCountOutputType
   */

  export type QuizQuestionCountOutputType = {
    options: number
  }

  export type QuizQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | QuizQuestionCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionCountOutputType
     */
    select?: QuizQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizOptionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    stripeCustomerId: string | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    stripeCustomerId: string | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    stripeCustomerId: number
    role: number
    banned: number
    banReason: number
    banExpires: number
    deletedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    stripeCustomerId?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    stripeCustomerId?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    stripeCustomerId?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    stripeCustomerId: string | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stripeCustomerId?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    deletedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    lessonProgress?: boolean | User$lessonProgressArgs<ExtArgs>
    enrollment?: boolean | User$enrollmentArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    courses?: boolean | User$coursesArgs<ExtArgs>
    learningPaths?: boolean | User$learningPathsArgs<ExtArgs>
    workshops?: boolean | User$workshopsArgs<ExtArgs>
    resources?: boolean | User$resourcesArgs<ExtArgs>
    quiz?: boolean | User$quizArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stripeCustomerId?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stripeCustomerId?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stripeCustomerId?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    deletedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt" | "stripeCustomerId" | "role" | "banned" | "banReason" | "banExpires" | "deletedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    lessonProgress?: boolean | User$lessonProgressArgs<ExtArgs>
    enrollment?: boolean | User$enrollmentArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    courses?: boolean | User$coursesArgs<ExtArgs>
    learningPaths?: boolean | User$learningPathsArgs<ExtArgs>
    workshops?: boolean | User$workshopsArgs<ExtArgs>
    resources?: boolean | User$resourcesArgs<ExtArgs>
    quiz?: boolean | User$quizArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      lessonProgress: Prisma.$LessonProgressPayload<ExtArgs>[]
      enrollment: Prisma.$EnrollmentPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      courses: Prisma.$CoursePayload<ExtArgs>[]
      learningPaths: Prisma.$LearningPathPayload<ExtArgs>[]
      workshops: Prisma.$WorkshopPayload<ExtArgs>[]
      resources: Prisma.$ResourcePayload<ExtArgs>[]
      quiz: Prisma.$QuizPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
      stripeCustomerId: string | null
      role: string | null
      banned: boolean | null
      banReason: string | null
      banExpires: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessonProgress<T extends User$lessonProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$lessonProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollment<T extends User$enrollmentArgs<ExtArgs> = {}>(args?: Subset<T, User$enrollmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courses<T extends User$coursesArgs<ExtArgs> = {}>(args?: Subset<T, User$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningPaths<T extends User$learningPathsArgs<ExtArgs> = {}>(args?: Subset<T, User$learningPathsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workshops<T extends User$workshopsArgs<ExtArgs> = {}>(args?: Subset<T, User$workshopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resources<T extends User$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, User$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quiz<T extends User$quizArgs<ExtArgs> = {}>(args?: Subset<T, User$quizArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly stripeCustomerId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly banned: FieldRef<"User", 'Boolean'>
    readonly banReason: FieldRef<"User", 'String'>
    readonly banExpires: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.lessonProgress
   */
  export type User$lessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    where?: LessonProgressWhereInput
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    cursor?: LessonProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * User.enrollment
   */
  export type User$enrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.invoices
   */
  export type User$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.courses
   */
  export type User$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.learningPaths
   */
  export type User$learningPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    where?: LearningPathWhereInput
    orderBy?: LearningPathOrderByWithRelationInput | LearningPathOrderByWithRelationInput[]
    cursor?: LearningPathWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathScalarFieldEnum | LearningPathScalarFieldEnum[]
  }

  /**
   * User.workshops
   */
  export type User$workshopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    where?: WorkshopWhereInput
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    cursor?: WorkshopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopScalarFieldEnum | WorkshopScalarFieldEnum[]
  }

  /**
   * User.resources
   */
  export type User$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * User.quiz
   */
  export type User$quizArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    impersonatedBy: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    impersonatedBy: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    impersonatedBy: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    impersonatedBy?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    impersonatedBy?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    impersonatedBy?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    impersonatedBy: string | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId" | "impersonatedBy", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
      impersonatedBy: string | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly impersonatedBy: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Domain
   */

  export type AggregateDomain = {
    _count: DomainCountAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  export type DomainMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    desc: string | null
    color: string | null
    iconName: string | null
    iconLib: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DomainMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    desc: string | null
    color: string | null
    iconName: string | null
    iconLib: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DomainCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    desc: number
    color: number
    iconName: number
    iconLib: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type DomainMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    desc?: true
    color?: true
    iconName?: true
    iconLib?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DomainMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    desc?: true
    color?: true
    iconName?: true
    iconLib?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DomainCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    desc?: true
    color?: true
    iconName?: true
    iconLib?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type DomainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Domain to aggregate.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Domains
    **/
    _count?: true | DomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainMaxAggregateInputType
  }

  export type GetDomainAggregateType<T extends DomainAggregateArgs> = {
        [P in keyof T & keyof AggregateDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomain[P]>
      : GetScalarType<T[P], AggregateDomain[P]>
  }




  export type DomainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainWhereInput
    orderBy?: DomainOrderByWithAggregationInput | DomainOrderByWithAggregationInput[]
    by: DomainScalarFieldEnum[] | DomainScalarFieldEnum
    having?: DomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainCountAggregateInputType | true
    _min?: DomainMinAggregateInputType
    _max?: DomainMaxAggregateInputType
  }

  export type DomainGroupByOutputType = {
    id: string
    title: string
    slug: string
    desc: string
    color: string | null
    iconName: string | null
    iconLib: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: DomainCountAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  type GetDomainGroupByPayload<T extends DomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainGroupByOutputType[P]>
            : GetScalarType<T[P], DomainGroupByOutputType[P]>
        }
      >
    >


  export type DomainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    desc?: boolean
    color?: boolean
    iconName?: boolean
    iconLib?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    categories?: boolean | Domain$categoriesArgs<ExtArgs>
    _count?: boolean | DomainCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domain"]>

  export type DomainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    desc?: boolean
    color?: boolean
    iconName?: boolean
    iconLib?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["domain"]>

  export type DomainSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    desc?: boolean
    color?: boolean
    iconName?: boolean
    iconLib?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["domain"]>

  export type DomainSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    desc?: boolean
    color?: boolean
    iconName?: boolean
    iconLib?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type DomainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "desc" | "color" | "iconName" | "iconLib" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["domain"]>
  export type DomainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Domain$categoriesArgs<ExtArgs>
    _count?: boolean | DomainCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DomainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DomainIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DomainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Domain"
    objects: {
      categories: Prisma.$CategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      desc: string
      color: string | null
      iconName: string | null
      iconLib: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["domain"]>
    composites: {}
  }

  type DomainGetPayload<S extends boolean | null | undefined | DomainDefaultArgs> = $Result.GetResult<Prisma.$DomainPayload, S>

  type DomainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainCountAggregateInputType | true
    }

  export interface DomainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Domain'], meta: { name: 'Domain' } }
    /**
     * Find zero or one Domain that matches the filter.
     * @param {DomainFindUniqueArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainFindUniqueArgs>(args: SelectSubset<T, DomainFindUniqueArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Domain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainFindUniqueOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Domain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindFirstArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainFindFirstArgs>(args?: SelectSubset<T, DomainFindFirstArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Domain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindFirstOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Domains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Domains
     * const domains = await prisma.domain.findMany()
     * 
     * // Get first 10 Domains
     * const domains = await prisma.domain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainWithIdOnly = await prisma.domain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DomainFindManyArgs>(args?: SelectSubset<T, DomainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Domain.
     * @param {DomainCreateArgs} args - Arguments to create a Domain.
     * @example
     * // Create one Domain
     * const Domain = await prisma.domain.create({
     *   data: {
     *     // ... data to create a Domain
     *   }
     * })
     * 
     */
    create<T extends DomainCreateArgs>(args: SelectSubset<T, DomainCreateArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Domains.
     * @param {DomainCreateManyArgs} args - Arguments to create many Domains.
     * @example
     * // Create many Domains
     * const domain = await prisma.domain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainCreateManyArgs>(args?: SelectSubset<T, DomainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Domains and returns the data saved in the database.
     * @param {DomainCreateManyAndReturnArgs} args - Arguments to create many Domains.
     * @example
     * // Create many Domains
     * const domain = await prisma.domain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Domains and only return the `id`
     * const domainWithIdOnly = await prisma.domain.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Domain.
     * @param {DomainDeleteArgs} args - Arguments to delete one Domain.
     * @example
     * // Delete one Domain
     * const Domain = await prisma.domain.delete({
     *   where: {
     *     // ... filter to delete one Domain
     *   }
     * })
     * 
     */
    delete<T extends DomainDeleteArgs>(args: SelectSubset<T, DomainDeleteArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Domain.
     * @param {DomainUpdateArgs} args - Arguments to update one Domain.
     * @example
     * // Update one Domain
     * const domain = await prisma.domain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainUpdateArgs>(args: SelectSubset<T, DomainUpdateArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Domains.
     * @param {DomainDeleteManyArgs} args - Arguments to filter Domains to delete.
     * @example
     * // Delete a few Domains
     * const { count } = await prisma.domain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainDeleteManyArgs>(args?: SelectSubset<T, DomainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Domains
     * const domain = await prisma.domain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainUpdateManyArgs>(args: SelectSubset<T, DomainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Domains and returns the data updated in the database.
     * @param {DomainUpdateManyAndReturnArgs} args - Arguments to update many Domains.
     * @example
     * // Update many Domains
     * const domain = await prisma.domain.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Domains and only return the `id`
     * const domainWithIdOnly = await prisma.domain.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Domain.
     * @param {DomainUpsertArgs} args - Arguments to update or create a Domain.
     * @example
     * // Update or create a Domain
     * const domain = await prisma.domain.upsert({
     *   create: {
     *     // ... data to create a Domain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Domain we want to update
     *   }
     * })
     */
    upsert<T extends DomainUpsertArgs>(args: SelectSubset<T, DomainUpsertArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainCountArgs} args - Arguments to filter Domains to count.
     * @example
     * // Count the number of Domains
     * const count = await prisma.domain.count({
     *   where: {
     *     // ... the filter for the Domains we want to count
     *   }
     * })
    **/
    count<T extends DomainCountArgs>(
      args?: Subset<T, DomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainAggregateArgs>(args: Subset<T, DomainAggregateArgs>): Prisma.PrismaPromise<GetDomainAggregateType<T>>

    /**
     * Group by Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainGroupByArgs['orderBy'] }
        : { orderBy?: DomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Domain model
   */
  readonly fields: DomainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Domain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends Domain$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Domain$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Domain model
   */
  interface DomainFieldRefs {
    readonly id: FieldRef<"Domain", 'String'>
    readonly title: FieldRef<"Domain", 'String'>
    readonly slug: FieldRef<"Domain", 'String'>
    readonly desc: FieldRef<"Domain", 'String'>
    readonly color: FieldRef<"Domain", 'String'>
    readonly iconName: FieldRef<"Domain", 'String'>
    readonly iconLib: FieldRef<"Domain", 'String'>
    readonly createdAt: FieldRef<"Domain", 'DateTime'>
    readonly updatedAt: FieldRef<"Domain", 'DateTime'>
    readonly deletedAt: FieldRef<"Domain", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Domain findUnique
   */
  export type DomainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain findUniqueOrThrow
   */
  export type DomainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain findFirst
   */
  export type DomainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domains.
     */
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * Domain findFirstOrThrow
   */
  export type DomainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domains.
     */
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * Domain findMany
   */
  export type DomainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domains to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * Domain create
   */
  export type DomainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * The data needed to create a Domain.
     */
    data: XOR<DomainCreateInput, DomainUncheckedCreateInput>
  }

  /**
   * Domain createMany
   */
  export type DomainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Domains.
     */
    data: DomainCreateManyInput | DomainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Domain createManyAndReturn
   */
  export type DomainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * The data used to create many Domains.
     */
    data: DomainCreateManyInput | DomainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Domain update
   */
  export type DomainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * The data needed to update a Domain.
     */
    data: XOR<DomainUpdateInput, DomainUncheckedUpdateInput>
    /**
     * Choose, which Domain to update.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain updateMany
   */
  export type DomainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Domains.
     */
    data: XOR<DomainUpdateManyMutationInput, DomainUncheckedUpdateManyInput>
    /**
     * Filter which Domains to update
     */
    where?: DomainWhereInput
    /**
     * Limit how many Domains to update.
     */
    limit?: number
  }

  /**
   * Domain updateManyAndReturn
   */
  export type DomainUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * The data used to update Domains.
     */
    data: XOR<DomainUpdateManyMutationInput, DomainUncheckedUpdateManyInput>
    /**
     * Filter which Domains to update
     */
    where?: DomainWhereInput
    /**
     * Limit how many Domains to update.
     */
    limit?: number
  }

  /**
   * Domain upsert
   */
  export type DomainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * The filter to search for the Domain to update in case it exists.
     */
    where: DomainWhereUniqueInput
    /**
     * In case the Domain found by the `where` argument doesn't exist, create a new Domain with this data.
     */
    create: XOR<DomainCreateInput, DomainUncheckedCreateInput>
    /**
     * In case the Domain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainUpdateInput, DomainUncheckedUpdateInput>
  }

  /**
   * Domain delete
   */
  export type DomainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter which Domain to delete.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain deleteMany
   */
  export type DomainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Domains to delete
     */
    where?: DomainWhereInput
    /**
     * Limit how many Domains to delete.
     */
    limit?: number
  }

  /**
   * Domain.categories
   */
  export type Domain$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Domain without action
   */
  export type DomainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    desc: string | null
    color: string | null
    iconName: string | null
    iconLib: string | null
    createdAt: Date | null
    updatedAt: Date | null
    domainId: string | null
    deletedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    desc: string | null
    color: string | null
    iconName: string | null
    iconLib: string | null
    createdAt: Date | null
    updatedAt: Date | null
    domainId: string | null
    deletedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    desc: number
    color: number
    iconName: number
    iconLib: number
    createdAt: number
    updatedAt: number
    domainId: number
    deletedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    desc?: true
    color?: true
    iconName?: true
    iconLib?: true
    createdAt?: true
    updatedAt?: true
    domainId?: true
    deletedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    desc?: true
    color?: true
    iconName?: true
    iconLib?: true
    createdAt?: true
    updatedAt?: true
    domainId?: true
    deletedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    desc?: true
    color?: true
    iconName?: true
    iconLib?: true
    createdAt?: true
    updatedAt?: true
    domainId?: true
    deletedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    title: string
    slug: string
    desc: string
    color: string | null
    iconName: string | null
    iconLib: string | null
    createdAt: Date
    updatedAt: Date
    domainId: string
    deletedAt: Date | null
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    desc?: boolean
    color?: boolean
    iconName?: boolean
    iconLib?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainId?: boolean
    deletedAt?: boolean
    courses?: boolean | Category$coursesArgs<ExtArgs>
    domain?: boolean | DomainDefaultArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    desc?: boolean
    color?: boolean
    iconName?: boolean
    iconLib?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainId?: boolean
    deletedAt?: boolean
    domain?: boolean | DomainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    desc?: boolean
    color?: boolean
    iconName?: boolean
    iconLib?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainId?: boolean
    deletedAt?: boolean
    domain?: boolean | DomainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    desc?: boolean
    color?: boolean
    iconName?: boolean
    iconLib?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainId?: boolean
    deletedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "desc" | "color" | "iconName" | "iconLib" | "createdAt" | "updatedAt" | "domainId" | "deletedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | Category$coursesArgs<ExtArgs>
    domain?: boolean | DomainDefaultArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | DomainDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | DomainDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      courses: Prisma.$CoursePayload<ExtArgs>[]
      domain: Prisma.$DomainPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      desc: string
      color: string | null
      iconName: string | null
      iconLib: string | null
      createdAt: Date
      updatedAt: Date
      domainId: string
      deletedAt: Date | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends Category$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Category$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    domain<T extends DomainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainDefaultArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly title: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly desc: FieldRef<"Category", 'String'>
    readonly color: FieldRef<"Category", 'String'>
    readonly iconName: FieldRef<"Category", 'String'>
    readonly iconLib: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
    readonly domainId: FieldRef<"Category", 'String'>
    readonly deletedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.courses
   */
  export type Category$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model LearningPath
   */

  export type AggregateLearningPath = {
    _count: LearningPathCountAggregateOutputType | null
    _avg: LearningPathAvgAggregateOutputType | null
    _sum: LearningPathSumAggregateOutputType | null
    _min: LearningPathMinAggregateOutputType | null
    _max: LearningPathMaxAggregateOutputType | null
  }

  export type LearningPathAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type LearningPathSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type LearningPathMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    smallDescription: string | null
    fileKey: string | null
    price: number | null
    currency: string | null
    duration: number | null
    slug: string | null
    status: string | null
    level: string | null
    stripePriceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    deletedAt: Date | null
  }

  export type LearningPathMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    smallDescription: string | null
    fileKey: string | null
    price: number | null
    currency: string | null
    duration: number | null
    slug: string | null
    status: string | null
    level: string | null
    stripePriceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    deletedAt: Date | null
  }

  export type LearningPathCountAggregateOutputType = {
    id: number
    title: number
    description: number
    smallDescription: number
    fileKey: number
    price: number
    currency: number
    duration: number
    slug: number
    status: number
    level: number
    stripePriceId: number
    createdAt: number
    updatedAt: number
    userId: number
    deletedAt: number
    _all: number
  }


  export type LearningPathAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type LearningPathSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type LearningPathMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    smallDescription?: true
    fileKey?: true
    price?: true
    currency?: true
    duration?: true
    slug?: true
    status?: true
    level?: true
    stripePriceId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    deletedAt?: true
  }

  export type LearningPathMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    smallDescription?: true
    fileKey?: true
    price?: true
    currency?: true
    duration?: true
    slug?: true
    status?: true
    level?: true
    stripePriceId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    deletedAt?: true
  }

  export type LearningPathCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    smallDescription?: true
    fileKey?: true
    price?: true
    currency?: true
    duration?: true
    slug?: true
    status?: true
    level?: true
    stripePriceId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    deletedAt?: true
    _all?: true
  }

  export type LearningPathAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPath to aggregate.
     */
    where?: LearningPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPaths to fetch.
     */
    orderBy?: LearningPathOrderByWithRelationInput | LearningPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningPaths
    **/
    _count?: true | LearningPathCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningPathAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningPathSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningPathMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningPathMaxAggregateInputType
  }

  export type GetLearningPathAggregateType<T extends LearningPathAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningPath]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningPath[P]>
      : GetScalarType<T[P], AggregateLearningPath[P]>
  }




  export type LearningPathGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathWhereInput
    orderBy?: LearningPathOrderByWithAggregationInput | LearningPathOrderByWithAggregationInput[]
    by: LearningPathScalarFieldEnum[] | LearningPathScalarFieldEnum
    having?: LearningPathScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningPathCountAggregateInputType | true
    _avg?: LearningPathAvgAggregateInputType
    _sum?: LearningPathSumAggregateInputType
    _min?: LearningPathMinAggregateInputType
    _max?: LearningPathMaxAggregateInputType
  }

  export type LearningPathGroupByOutputType = {
    id: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt: Date
    updatedAt: Date
    userId: string
    deletedAt: Date | null
    _count: LearningPathCountAggregateOutputType | null
    _avg: LearningPathAvgAggregateOutputType | null
    _sum: LearningPathSumAggregateOutputType | null
    _min: LearningPathMinAggregateOutputType | null
    _max: LearningPathMaxAggregateOutputType | null
  }

  type GetLearningPathGroupByPayload<T extends LearningPathGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningPathGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningPathGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningPathGroupByOutputType[P]>
            : GetScalarType<T[P], LearningPathGroupByOutputType[P]>
        }
      >
    >


  export type LearningPathSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    smallDescription?: boolean
    fileKey?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    slug?: boolean
    status?: boolean
    level?: boolean
    stripePriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    deletedAt?: boolean
    user?: boolean | LearningPath$userArgs<ExtArgs>
    tags?: boolean | LearningPath$tagsArgs<ExtArgs>
    contents?: boolean | LearningPath$contentsArgs<ExtArgs>
    progress?: boolean | LearningPath$progressArgs<ExtArgs>
    resources?: boolean | LearningPath$resourcesArgs<ExtArgs>
    objectives?: boolean | LearningPath$objectivesArgs<ExtArgs>
    prerequisites?: boolean | LearningPath$prerequisitesArgs<ExtArgs>
    promoCodes?: boolean | LearningPath$promoCodesArgs<ExtArgs>
    promotions?: boolean | LearningPath$promotionsArgs<ExtArgs>
    enrollments?: boolean | LearningPath$enrollmentsArgs<ExtArgs>
    payments?: boolean | LearningPath$paymentsArgs<ExtArgs>
    _count?: boolean | LearningPathCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPath"]>

  export type LearningPathSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    smallDescription?: boolean
    fileKey?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    slug?: boolean
    status?: boolean
    level?: boolean
    stripePriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    deletedAt?: boolean
    user?: boolean | LearningPath$userArgs<ExtArgs>
  }, ExtArgs["result"]["learningPath"]>

  export type LearningPathSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    smallDescription?: boolean
    fileKey?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    slug?: boolean
    status?: boolean
    level?: boolean
    stripePriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    deletedAt?: boolean
    user?: boolean | LearningPath$userArgs<ExtArgs>
  }, ExtArgs["result"]["learningPath"]>

  export type LearningPathSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    smallDescription?: boolean
    fileKey?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    slug?: boolean
    status?: boolean
    level?: boolean
    stripePriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    deletedAt?: boolean
  }

  export type LearningPathOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "smallDescription" | "fileKey" | "price" | "currency" | "duration" | "slug" | "status" | "level" | "stripePriceId" | "createdAt" | "updatedAt" | "userId" | "deletedAt", ExtArgs["result"]["learningPath"]>
  export type LearningPathInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LearningPath$userArgs<ExtArgs>
    tags?: boolean | LearningPath$tagsArgs<ExtArgs>
    contents?: boolean | LearningPath$contentsArgs<ExtArgs>
    progress?: boolean | LearningPath$progressArgs<ExtArgs>
    resources?: boolean | LearningPath$resourcesArgs<ExtArgs>
    objectives?: boolean | LearningPath$objectivesArgs<ExtArgs>
    prerequisites?: boolean | LearningPath$prerequisitesArgs<ExtArgs>
    promoCodes?: boolean | LearningPath$promoCodesArgs<ExtArgs>
    promotions?: boolean | LearningPath$promotionsArgs<ExtArgs>
    enrollments?: boolean | LearningPath$enrollmentsArgs<ExtArgs>
    payments?: boolean | LearningPath$paymentsArgs<ExtArgs>
    _count?: boolean | LearningPathCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LearningPathIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LearningPath$userArgs<ExtArgs>
  }
  export type LearningPathIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LearningPath$userArgs<ExtArgs>
  }

  export type $LearningPathPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningPath"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      tags: Prisma.$LearningPathTagPayload<ExtArgs>[]
      contents: Prisma.$LearningPathItemPayload<ExtArgs>[]
      progress: Prisma.$UserProgressPayload<ExtArgs>[]
      resources: Prisma.$LearningPathResourcePayload<ExtArgs>[]
      objectives: Prisma.$LearningPathObjectivePayload<ExtArgs>[]
      prerequisites: Prisma.$LearningPathPrerequisitePayload<ExtArgs>[]
      promoCodes: Prisma.$PromoCodePayload<ExtArgs>[]
      promotions: Prisma.$PromotionPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      smallDescription: string
      fileKey: string
      price: number
      currency: string
      duration: number
      slug: string
      status: string
      level: string
      stripePriceId: string
      createdAt: Date
      updatedAt: Date
      userId: string
      deletedAt: Date | null
    }, ExtArgs["result"]["learningPath"]>
    composites: {}
  }

  type LearningPathGetPayload<S extends boolean | null | undefined | LearningPathDefaultArgs> = $Result.GetResult<Prisma.$LearningPathPayload, S>

  type LearningPathCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningPathFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningPathCountAggregateInputType | true
    }

  export interface LearningPathDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningPath'], meta: { name: 'LearningPath' } }
    /**
     * Find zero or one LearningPath that matches the filter.
     * @param {LearningPathFindUniqueArgs} args - Arguments to find a LearningPath
     * @example
     * // Get one LearningPath
     * const learningPath = await prisma.learningPath.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningPathFindUniqueArgs>(args: SelectSubset<T, LearningPathFindUniqueArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LearningPath that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningPathFindUniqueOrThrowArgs} args - Arguments to find a LearningPath
     * @example
     * // Get one LearningPath
     * const learningPath = await prisma.learningPath.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningPathFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningPathFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningPath that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathFindFirstArgs} args - Arguments to find a LearningPath
     * @example
     * // Get one LearningPath
     * const learningPath = await prisma.learningPath.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningPathFindFirstArgs>(args?: SelectSubset<T, LearningPathFindFirstArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningPath that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathFindFirstOrThrowArgs} args - Arguments to find a LearningPath
     * @example
     * // Get one LearningPath
     * const learningPath = await prisma.learningPath.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningPathFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningPathFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LearningPaths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningPaths
     * const learningPaths = await prisma.learningPath.findMany()
     * 
     * // Get first 10 LearningPaths
     * const learningPaths = await prisma.learningPath.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningPathWithIdOnly = await prisma.learningPath.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningPathFindManyArgs>(args?: SelectSubset<T, LearningPathFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LearningPath.
     * @param {LearningPathCreateArgs} args - Arguments to create a LearningPath.
     * @example
     * // Create one LearningPath
     * const LearningPath = await prisma.learningPath.create({
     *   data: {
     *     // ... data to create a LearningPath
     *   }
     * })
     * 
     */
    create<T extends LearningPathCreateArgs>(args: SelectSubset<T, LearningPathCreateArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LearningPaths.
     * @param {LearningPathCreateManyArgs} args - Arguments to create many LearningPaths.
     * @example
     * // Create many LearningPaths
     * const learningPath = await prisma.learningPath.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningPathCreateManyArgs>(args?: SelectSubset<T, LearningPathCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningPaths and returns the data saved in the database.
     * @param {LearningPathCreateManyAndReturnArgs} args - Arguments to create many LearningPaths.
     * @example
     * // Create many LearningPaths
     * const learningPath = await prisma.learningPath.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningPaths and only return the `id`
     * const learningPathWithIdOnly = await prisma.learningPath.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningPathCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningPathCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LearningPath.
     * @param {LearningPathDeleteArgs} args - Arguments to delete one LearningPath.
     * @example
     * // Delete one LearningPath
     * const LearningPath = await prisma.learningPath.delete({
     *   where: {
     *     // ... filter to delete one LearningPath
     *   }
     * })
     * 
     */
    delete<T extends LearningPathDeleteArgs>(args: SelectSubset<T, LearningPathDeleteArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LearningPath.
     * @param {LearningPathUpdateArgs} args - Arguments to update one LearningPath.
     * @example
     * // Update one LearningPath
     * const learningPath = await prisma.learningPath.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningPathUpdateArgs>(args: SelectSubset<T, LearningPathUpdateArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LearningPaths.
     * @param {LearningPathDeleteManyArgs} args - Arguments to filter LearningPaths to delete.
     * @example
     * // Delete a few LearningPaths
     * const { count } = await prisma.learningPath.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningPathDeleteManyArgs>(args?: SelectSubset<T, LearningPathDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningPaths
     * const learningPath = await prisma.learningPath.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningPathUpdateManyArgs>(args: SelectSubset<T, LearningPathUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPaths and returns the data updated in the database.
     * @param {LearningPathUpdateManyAndReturnArgs} args - Arguments to update many LearningPaths.
     * @example
     * // Update many LearningPaths
     * const learningPath = await prisma.learningPath.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningPaths and only return the `id`
     * const learningPathWithIdOnly = await prisma.learningPath.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningPathUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningPathUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LearningPath.
     * @param {LearningPathUpsertArgs} args - Arguments to update or create a LearningPath.
     * @example
     * // Update or create a LearningPath
     * const learningPath = await prisma.learningPath.upsert({
     *   create: {
     *     // ... data to create a LearningPath
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningPath we want to update
     *   }
     * })
     */
    upsert<T extends LearningPathUpsertArgs>(args: SelectSubset<T, LearningPathUpsertArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LearningPaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathCountArgs} args - Arguments to filter LearningPaths to count.
     * @example
     * // Count the number of LearningPaths
     * const count = await prisma.learningPath.count({
     *   where: {
     *     // ... the filter for the LearningPaths we want to count
     *   }
     * })
    **/
    count<T extends LearningPathCountArgs>(
      args?: Subset<T, LearningPathCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningPathCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningPath.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningPathAggregateArgs>(args: Subset<T, LearningPathAggregateArgs>): Prisma.PrismaPromise<GetLearningPathAggregateType<T>>

    /**
     * Group by LearningPath.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningPathGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningPathGroupByArgs['orderBy'] }
        : { orderBy?: LearningPathGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningPathGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningPathGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningPath model
   */
  readonly fields: LearningPathFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningPath.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningPathClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends LearningPath$userArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tags<T extends LearningPath$tagsArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contents<T extends LearningPath$contentsArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$contentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progress<T extends LearningPath$progressArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resources<T extends LearningPath$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    objectives<T extends LearningPath$objectivesArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$objectivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prerequisites<T extends LearningPath$prerequisitesArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$prerequisitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promoCodes<T extends LearningPath$promoCodesArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$promoCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promotions<T extends LearningPath$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends LearningPath$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends LearningPath$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningPath model
   */
  interface LearningPathFieldRefs {
    readonly id: FieldRef<"LearningPath", 'String'>
    readonly title: FieldRef<"LearningPath", 'String'>
    readonly description: FieldRef<"LearningPath", 'String'>
    readonly smallDescription: FieldRef<"LearningPath", 'String'>
    readonly fileKey: FieldRef<"LearningPath", 'String'>
    readonly price: FieldRef<"LearningPath", 'Int'>
    readonly currency: FieldRef<"LearningPath", 'String'>
    readonly duration: FieldRef<"LearningPath", 'Int'>
    readonly slug: FieldRef<"LearningPath", 'String'>
    readonly status: FieldRef<"LearningPath", 'String'>
    readonly level: FieldRef<"LearningPath", 'String'>
    readonly stripePriceId: FieldRef<"LearningPath", 'String'>
    readonly createdAt: FieldRef<"LearningPath", 'DateTime'>
    readonly updatedAt: FieldRef<"LearningPath", 'DateTime'>
    readonly userId: FieldRef<"LearningPath", 'String'>
    readonly deletedAt: FieldRef<"LearningPath", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearningPath findUnique
   */
  export type LearningPathFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * Filter, which LearningPath to fetch.
     */
    where: LearningPathWhereUniqueInput
  }

  /**
   * LearningPath findUniqueOrThrow
   */
  export type LearningPathFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * Filter, which LearningPath to fetch.
     */
    where: LearningPathWhereUniqueInput
  }

  /**
   * LearningPath findFirst
   */
  export type LearningPathFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * Filter, which LearningPath to fetch.
     */
    where?: LearningPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPaths to fetch.
     */
    orderBy?: LearningPathOrderByWithRelationInput | LearningPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPaths.
     */
    cursor?: LearningPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPaths.
     */
    distinct?: LearningPathScalarFieldEnum | LearningPathScalarFieldEnum[]
  }

  /**
   * LearningPath findFirstOrThrow
   */
  export type LearningPathFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * Filter, which LearningPath to fetch.
     */
    where?: LearningPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPaths to fetch.
     */
    orderBy?: LearningPathOrderByWithRelationInput | LearningPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPaths.
     */
    cursor?: LearningPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPaths.
     */
    distinct?: LearningPathScalarFieldEnum | LearningPathScalarFieldEnum[]
  }

  /**
   * LearningPath findMany
   */
  export type LearningPathFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * Filter, which LearningPaths to fetch.
     */
    where?: LearningPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPaths to fetch.
     */
    orderBy?: LearningPathOrderByWithRelationInput | LearningPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningPaths.
     */
    cursor?: LearningPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPaths.
     */
    skip?: number
    distinct?: LearningPathScalarFieldEnum | LearningPathScalarFieldEnum[]
  }

  /**
   * LearningPath create
   */
  export type LearningPathCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningPath.
     */
    data: XOR<LearningPathCreateInput, LearningPathUncheckedCreateInput>
  }

  /**
   * LearningPath createMany
   */
  export type LearningPathCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningPaths.
     */
    data: LearningPathCreateManyInput | LearningPathCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningPath createManyAndReturn
   */
  export type LearningPathCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * The data used to create many LearningPaths.
     */
    data: LearningPathCreateManyInput | LearningPathCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPath update
   */
  export type LearningPathUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningPath.
     */
    data: XOR<LearningPathUpdateInput, LearningPathUncheckedUpdateInput>
    /**
     * Choose, which LearningPath to update.
     */
    where: LearningPathWhereUniqueInput
  }

  /**
   * LearningPath updateMany
   */
  export type LearningPathUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningPaths.
     */
    data: XOR<LearningPathUpdateManyMutationInput, LearningPathUncheckedUpdateManyInput>
    /**
     * Filter which LearningPaths to update
     */
    where?: LearningPathWhereInput
    /**
     * Limit how many LearningPaths to update.
     */
    limit?: number
  }

  /**
   * LearningPath updateManyAndReturn
   */
  export type LearningPathUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * The data used to update LearningPaths.
     */
    data: XOR<LearningPathUpdateManyMutationInput, LearningPathUncheckedUpdateManyInput>
    /**
     * Filter which LearningPaths to update
     */
    where?: LearningPathWhereInput
    /**
     * Limit how many LearningPaths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPath upsert
   */
  export type LearningPathUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningPath to update in case it exists.
     */
    where: LearningPathWhereUniqueInput
    /**
     * In case the LearningPath found by the `where` argument doesn't exist, create a new LearningPath with this data.
     */
    create: XOR<LearningPathCreateInput, LearningPathUncheckedCreateInput>
    /**
     * In case the LearningPath was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningPathUpdateInput, LearningPathUncheckedUpdateInput>
  }

  /**
   * LearningPath delete
   */
  export type LearningPathDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * Filter which LearningPath to delete.
     */
    where: LearningPathWhereUniqueInput
  }

  /**
   * LearningPath deleteMany
   */
  export type LearningPathDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPaths to delete
     */
    where?: LearningPathWhereInput
    /**
     * Limit how many LearningPaths to delete.
     */
    limit?: number
  }

  /**
   * LearningPath.user
   */
  export type LearningPath$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LearningPath.tags
   */
  export type LearningPath$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagInclude<ExtArgs> | null
    where?: LearningPathTagWhereInput
    orderBy?: LearningPathTagOrderByWithRelationInput | LearningPathTagOrderByWithRelationInput[]
    cursor?: LearningPathTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathTagScalarFieldEnum | LearningPathTagScalarFieldEnum[]
  }

  /**
   * LearningPath.contents
   */
  export type LearningPath$contentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    where?: LearningPathItemWhereInput
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    cursor?: LearningPathItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathItemScalarFieldEnum | LearningPathItemScalarFieldEnum[]
  }

  /**
   * LearningPath.progress
   */
  export type LearningPath$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * LearningPath.resources
   */
  export type LearningPath$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceInclude<ExtArgs> | null
    where?: LearningPathResourceWhereInput
    orderBy?: LearningPathResourceOrderByWithRelationInput | LearningPathResourceOrderByWithRelationInput[]
    cursor?: LearningPathResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathResourceScalarFieldEnum | LearningPathResourceScalarFieldEnum[]
  }

  /**
   * LearningPath.objectives
   */
  export type LearningPath$objectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveInclude<ExtArgs> | null
    where?: LearningPathObjectiveWhereInput
    orderBy?: LearningPathObjectiveOrderByWithRelationInput | LearningPathObjectiveOrderByWithRelationInput[]
    cursor?: LearningPathObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathObjectiveScalarFieldEnum | LearningPathObjectiveScalarFieldEnum[]
  }

  /**
   * LearningPath.prerequisites
   */
  export type LearningPath$prerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteInclude<ExtArgs> | null
    where?: LearningPathPrerequisiteWhereInput
    orderBy?: LearningPathPrerequisiteOrderByWithRelationInput | LearningPathPrerequisiteOrderByWithRelationInput[]
    cursor?: LearningPathPrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathPrerequisiteScalarFieldEnum | LearningPathPrerequisiteScalarFieldEnum[]
  }

  /**
   * LearningPath.promoCodes
   */
  export type LearningPath$promoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    cursor?: PromoCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * LearningPath.promotions
   */
  export type LearningPath$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    cursor?: PromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * LearningPath.enrollments
   */
  export type LearningPath$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * LearningPath.payments
   */
  export type LearningPath$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * LearningPath without action
   */
  export type LearningPathDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
  }


  /**
   * Model LearningPathItem
   */

  export type AggregateLearningPathItem = {
    _count: LearningPathItemCountAggregateOutputType | null
    _avg: LearningPathItemAvgAggregateOutputType | null
    _sum: LearningPathItemSumAggregateOutputType | null
    _min: LearningPathItemMinAggregateOutputType | null
    _max: LearningPathItemMaxAggregateOutputType | null
  }

  export type LearningPathItemAvgAggregateOutputType = {
    position: number | null
  }

  export type LearningPathItemSumAggregateOutputType = {
    position: number | null
  }

  export type LearningPathItemMinAggregateOutputType = {
    id: string | null
    type: string | null
    position: number | null
    learningPathId: string | null
    courseId: string | null
    workshopId: string | null
    resourceId: string | null
  }

  export type LearningPathItemMaxAggregateOutputType = {
    id: string | null
    type: string | null
    position: number | null
    learningPathId: string | null
    courseId: string | null
    workshopId: string | null
    resourceId: string | null
  }

  export type LearningPathItemCountAggregateOutputType = {
    id: number
    type: number
    position: number
    learningPathId: number
    courseId: number
    workshopId: number
    resourceId: number
    _all: number
  }


  export type LearningPathItemAvgAggregateInputType = {
    position?: true
  }

  export type LearningPathItemSumAggregateInputType = {
    position?: true
  }

  export type LearningPathItemMinAggregateInputType = {
    id?: true
    type?: true
    position?: true
    learningPathId?: true
    courseId?: true
    workshopId?: true
    resourceId?: true
  }

  export type LearningPathItemMaxAggregateInputType = {
    id?: true
    type?: true
    position?: true
    learningPathId?: true
    courseId?: true
    workshopId?: true
    resourceId?: true
  }

  export type LearningPathItemCountAggregateInputType = {
    id?: true
    type?: true
    position?: true
    learningPathId?: true
    courseId?: true
    workshopId?: true
    resourceId?: true
    _all?: true
  }

  export type LearningPathItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPathItem to aggregate.
     */
    where?: LearningPathItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathItems to fetch.
     */
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningPathItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningPathItems
    **/
    _count?: true | LearningPathItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningPathItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningPathItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningPathItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningPathItemMaxAggregateInputType
  }

  export type GetLearningPathItemAggregateType<T extends LearningPathItemAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningPathItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningPathItem[P]>
      : GetScalarType<T[P], AggregateLearningPathItem[P]>
  }




  export type LearningPathItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathItemWhereInput
    orderBy?: LearningPathItemOrderByWithAggregationInput | LearningPathItemOrderByWithAggregationInput[]
    by: LearningPathItemScalarFieldEnum[] | LearningPathItemScalarFieldEnum
    having?: LearningPathItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningPathItemCountAggregateInputType | true
    _avg?: LearningPathItemAvgAggregateInputType
    _sum?: LearningPathItemSumAggregateInputType
    _min?: LearningPathItemMinAggregateInputType
    _max?: LearningPathItemMaxAggregateInputType
  }

  export type LearningPathItemGroupByOutputType = {
    id: string
    type: string
    position: number
    learningPathId: string
    courseId: string | null
    workshopId: string | null
    resourceId: string | null
    _count: LearningPathItemCountAggregateOutputType | null
    _avg: LearningPathItemAvgAggregateOutputType | null
    _sum: LearningPathItemSumAggregateOutputType | null
    _min: LearningPathItemMinAggregateOutputType | null
    _max: LearningPathItemMaxAggregateOutputType | null
  }

  type GetLearningPathItemGroupByPayload<T extends LearningPathItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningPathItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningPathItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningPathItemGroupByOutputType[P]>
            : GetScalarType<T[P], LearningPathItemGroupByOutputType[P]>
        }
      >
    >


  export type LearningPathItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    position?: boolean
    learningPathId?: boolean
    courseId?: boolean
    workshopId?: boolean
    resourceId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    course?: boolean | LearningPathItem$courseArgs<ExtArgs>
    workshop?: boolean | LearningPathItem$workshopArgs<ExtArgs>
    resource?: boolean | LearningPathItem$resourceArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathItem"]>

  export type LearningPathItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    position?: boolean
    learningPathId?: boolean
    courseId?: boolean
    workshopId?: boolean
    resourceId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    course?: boolean | LearningPathItem$courseArgs<ExtArgs>
    workshop?: boolean | LearningPathItem$workshopArgs<ExtArgs>
    resource?: boolean | LearningPathItem$resourceArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathItem"]>

  export type LearningPathItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    position?: boolean
    learningPathId?: boolean
    courseId?: boolean
    workshopId?: boolean
    resourceId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    course?: boolean | LearningPathItem$courseArgs<ExtArgs>
    workshop?: boolean | LearningPathItem$workshopArgs<ExtArgs>
    resource?: boolean | LearningPathItem$resourceArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathItem"]>

  export type LearningPathItemSelectScalar = {
    id?: boolean
    type?: boolean
    position?: boolean
    learningPathId?: boolean
    courseId?: boolean
    workshopId?: boolean
    resourceId?: boolean
  }

  export type LearningPathItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "position" | "learningPathId" | "courseId" | "workshopId" | "resourceId", ExtArgs["result"]["learningPathItem"]>
  export type LearningPathItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    course?: boolean | LearningPathItem$courseArgs<ExtArgs>
    workshop?: boolean | LearningPathItem$workshopArgs<ExtArgs>
    resource?: boolean | LearningPathItem$resourceArgs<ExtArgs>
  }
  export type LearningPathItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    course?: boolean | LearningPathItem$courseArgs<ExtArgs>
    workshop?: boolean | LearningPathItem$workshopArgs<ExtArgs>
    resource?: boolean | LearningPathItem$resourceArgs<ExtArgs>
  }
  export type LearningPathItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    course?: boolean | LearningPathItem$courseArgs<ExtArgs>
    workshop?: boolean | LearningPathItem$workshopArgs<ExtArgs>
    resource?: boolean | LearningPathItem$resourceArgs<ExtArgs>
  }

  export type $LearningPathItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningPathItem"
    objects: {
      learningPath: Prisma.$LearningPathPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs> | null
      workshop: Prisma.$WorkshopPayload<ExtArgs> | null
      resource: Prisma.$ResourcePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      position: number
      learningPathId: string
      courseId: string | null
      workshopId: string | null
      resourceId: string | null
    }, ExtArgs["result"]["learningPathItem"]>
    composites: {}
  }

  type LearningPathItemGetPayload<S extends boolean | null | undefined | LearningPathItemDefaultArgs> = $Result.GetResult<Prisma.$LearningPathItemPayload, S>

  type LearningPathItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningPathItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningPathItemCountAggregateInputType | true
    }

  export interface LearningPathItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningPathItem'], meta: { name: 'LearningPathItem' } }
    /**
     * Find zero or one LearningPathItem that matches the filter.
     * @param {LearningPathItemFindUniqueArgs} args - Arguments to find a LearningPathItem
     * @example
     * // Get one LearningPathItem
     * const learningPathItem = await prisma.learningPathItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningPathItemFindUniqueArgs>(args: SelectSubset<T, LearningPathItemFindUniqueArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LearningPathItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningPathItemFindUniqueOrThrowArgs} args - Arguments to find a LearningPathItem
     * @example
     * // Get one LearningPathItem
     * const learningPathItem = await prisma.learningPathItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningPathItemFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningPathItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningPathItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemFindFirstArgs} args - Arguments to find a LearningPathItem
     * @example
     * // Get one LearningPathItem
     * const learningPathItem = await prisma.learningPathItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningPathItemFindFirstArgs>(args?: SelectSubset<T, LearningPathItemFindFirstArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningPathItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemFindFirstOrThrowArgs} args - Arguments to find a LearningPathItem
     * @example
     * // Get one LearningPathItem
     * const learningPathItem = await prisma.learningPathItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningPathItemFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningPathItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LearningPathItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningPathItems
     * const learningPathItems = await prisma.learningPathItem.findMany()
     * 
     * // Get first 10 LearningPathItems
     * const learningPathItems = await prisma.learningPathItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningPathItemWithIdOnly = await prisma.learningPathItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningPathItemFindManyArgs>(args?: SelectSubset<T, LearningPathItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LearningPathItem.
     * @param {LearningPathItemCreateArgs} args - Arguments to create a LearningPathItem.
     * @example
     * // Create one LearningPathItem
     * const LearningPathItem = await prisma.learningPathItem.create({
     *   data: {
     *     // ... data to create a LearningPathItem
     *   }
     * })
     * 
     */
    create<T extends LearningPathItemCreateArgs>(args: SelectSubset<T, LearningPathItemCreateArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LearningPathItems.
     * @param {LearningPathItemCreateManyArgs} args - Arguments to create many LearningPathItems.
     * @example
     * // Create many LearningPathItems
     * const learningPathItem = await prisma.learningPathItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningPathItemCreateManyArgs>(args?: SelectSubset<T, LearningPathItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningPathItems and returns the data saved in the database.
     * @param {LearningPathItemCreateManyAndReturnArgs} args - Arguments to create many LearningPathItems.
     * @example
     * // Create many LearningPathItems
     * const learningPathItem = await prisma.learningPathItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningPathItems and only return the `id`
     * const learningPathItemWithIdOnly = await prisma.learningPathItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningPathItemCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningPathItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LearningPathItem.
     * @param {LearningPathItemDeleteArgs} args - Arguments to delete one LearningPathItem.
     * @example
     * // Delete one LearningPathItem
     * const LearningPathItem = await prisma.learningPathItem.delete({
     *   where: {
     *     // ... filter to delete one LearningPathItem
     *   }
     * })
     * 
     */
    delete<T extends LearningPathItemDeleteArgs>(args: SelectSubset<T, LearningPathItemDeleteArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LearningPathItem.
     * @param {LearningPathItemUpdateArgs} args - Arguments to update one LearningPathItem.
     * @example
     * // Update one LearningPathItem
     * const learningPathItem = await prisma.learningPathItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningPathItemUpdateArgs>(args: SelectSubset<T, LearningPathItemUpdateArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LearningPathItems.
     * @param {LearningPathItemDeleteManyArgs} args - Arguments to filter LearningPathItems to delete.
     * @example
     * // Delete a few LearningPathItems
     * const { count } = await prisma.learningPathItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningPathItemDeleteManyArgs>(args?: SelectSubset<T, LearningPathItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPathItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningPathItems
     * const learningPathItem = await prisma.learningPathItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningPathItemUpdateManyArgs>(args: SelectSubset<T, LearningPathItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPathItems and returns the data updated in the database.
     * @param {LearningPathItemUpdateManyAndReturnArgs} args - Arguments to update many LearningPathItems.
     * @example
     * // Update many LearningPathItems
     * const learningPathItem = await prisma.learningPathItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningPathItems and only return the `id`
     * const learningPathItemWithIdOnly = await prisma.learningPathItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningPathItemUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningPathItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LearningPathItem.
     * @param {LearningPathItemUpsertArgs} args - Arguments to update or create a LearningPathItem.
     * @example
     * // Update or create a LearningPathItem
     * const learningPathItem = await prisma.learningPathItem.upsert({
     *   create: {
     *     // ... data to create a LearningPathItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningPathItem we want to update
     *   }
     * })
     */
    upsert<T extends LearningPathItemUpsertArgs>(args: SelectSubset<T, LearningPathItemUpsertArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LearningPathItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemCountArgs} args - Arguments to filter LearningPathItems to count.
     * @example
     * // Count the number of LearningPathItems
     * const count = await prisma.learningPathItem.count({
     *   where: {
     *     // ... the filter for the LearningPathItems we want to count
     *   }
     * })
    **/
    count<T extends LearningPathItemCountArgs>(
      args?: Subset<T, LearningPathItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningPathItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningPathItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningPathItemAggregateArgs>(args: Subset<T, LearningPathItemAggregateArgs>): Prisma.PrismaPromise<GetLearningPathItemAggregateType<T>>

    /**
     * Group by LearningPathItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningPathItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningPathItemGroupByArgs['orderBy'] }
        : { orderBy?: LearningPathItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningPathItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningPathItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningPathItem model
   */
  readonly fields: LearningPathItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningPathItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningPathItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learningPath<T extends LearningPathDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathDefaultArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends LearningPathItem$courseArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathItem$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workshop<T extends LearningPathItem$workshopArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathItem$workshopArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    resource<T extends LearningPathItem$resourceArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathItem$resourceArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningPathItem model
   */
  interface LearningPathItemFieldRefs {
    readonly id: FieldRef<"LearningPathItem", 'String'>
    readonly type: FieldRef<"LearningPathItem", 'String'>
    readonly position: FieldRef<"LearningPathItem", 'Int'>
    readonly learningPathId: FieldRef<"LearningPathItem", 'String'>
    readonly courseId: FieldRef<"LearningPathItem", 'String'>
    readonly workshopId: FieldRef<"LearningPathItem", 'String'>
    readonly resourceId: FieldRef<"LearningPathItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LearningPathItem findUnique
   */
  export type LearningPathItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathItem to fetch.
     */
    where: LearningPathItemWhereUniqueInput
  }

  /**
   * LearningPathItem findUniqueOrThrow
   */
  export type LearningPathItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathItem to fetch.
     */
    where: LearningPathItemWhereUniqueInput
  }

  /**
   * LearningPathItem findFirst
   */
  export type LearningPathItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathItem to fetch.
     */
    where?: LearningPathItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathItems to fetch.
     */
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPathItems.
     */
    cursor?: LearningPathItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPathItems.
     */
    distinct?: LearningPathItemScalarFieldEnum | LearningPathItemScalarFieldEnum[]
  }

  /**
   * LearningPathItem findFirstOrThrow
   */
  export type LearningPathItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathItem to fetch.
     */
    where?: LearningPathItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathItems to fetch.
     */
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPathItems.
     */
    cursor?: LearningPathItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPathItems.
     */
    distinct?: LearningPathItemScalarFieldEnum | LearningPathItemScalarFieldEnum[]
  }

  /**
   * LearningPathItem findMany
   */
  export type LearningPathItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathItems to fetch.
     */
    where?: LearningPathItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathItems to fetch.
     */
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningPathItems.
     */
    cursor?: LearningPathItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathItems.
     */
    skip?: number
    distinct?: LearningPathItemScalarFieldEnum | LearningPathItemScalarFieldEnum[]
  }

  /**
   * LearningPathItem create
   */
  export type LearningPathItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningPathItem.
     */
    data: XOR<LearningPathItemCreateInput, LearningPathItemUncheckedCreateInput>
  }

  /**
   * LearningPathItem createMany
   */
  export type LearningPathItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningPathItems.
     */
    data: LearningPathItemCreateManyInput | LearningPathItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningPathItem createManyAndReturn
   */
  export type LearningPathItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * The data used to create many LearningPathItems.
     */
    data: LearningPathItemCreateManyInput | LearningPathItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPathItem update
   */
  export type LearningPathItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningPathItem.
     */
    data: XOR<LearningPathItemUpdateInput, LearningPathItemUncheckedUpdateInput>
    /**
     * Choose, which LearningPathItem to update.
     */
    where: LearningPathItemWhereUniqueInput
  }

  /**
   * LearningPathItem updateMany
   */
  export type LearningPathItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningPathItems.
     */
    data: XOR<LearningPathItemUpdateManyMutationInput, LearningPathItemUncheckedUpdateManyInput>
    /**
     * Filter which LearningPathItems to update
     */
    where?: LearningPathItemWhereInput
    /**
     * Limit how many LearningPathItems to update.
     */
    limit?: number
  }

  /**
   * LearningPathItem updateManyAndReturn
   */
  export type LearningPathItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * The data used to update LearningPathItems.
     */
    data: XOR<LearningPathItemUpdateManyMutationInput, LearningPathItemUncheckedUpdateManyInput>
    /**
     * Filter which LearningPathItems to update
     */
    where?: LearningPathItemWhereInput
    /**
     * Limit how many LearningPathItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPathItem upsert
   */
  export type LearningPathItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningPathItem to update in case it exists.
     */
    where: LearningPathItemWhereUniqueInput
    /**
     * In case the LearningPathItem found by the `where` argument doesn't exist, create a new LearningPathItem with this data.
     */
    create: XOR<LearningPathItemCreateInput, LearningPathItemUncheckedCreateInput>
    /**
     * In case the LearningPathItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningPathItemUpdateInput, LearningPathItemUncheckedUpdateInput>
  }

  /**
   * LearningPathItem delete
   */
  export type LearningPathItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * Filter which LearningPathItem to delete.
     */
    where: LearningPathItemWhereUniqueInput
  }

  /**
   * LearningPathItem deleteMany
   */
  export type LearningPathItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPathItems to delete
     */
    where?: LearningPathItemWhereInput
    /**
     * Limit how many LearningPathItems to delete.
     */
    limit?: number
  }

  /**
   * LearningPathItem.course
   */
  export type LearningPathItem$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * LearningPathItem.workshop
   */
  export type LearningPathItem$workshopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    where?: WorkshopWhereInput
  }

  /**
   * LearningPathItem.resource
   */
  export type LearningPathItem$resourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
  }

  /**
   * LearningPathItem without action
   */
  export type LearningPathItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type CourseSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    smallDescription: string | null
    description: string | null
    fileKey: string | null
    price: number | null
    currency: string | null
    duration: number | null
    status: string | null
    level: string | null
    stripePriceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    categoryId: string | null
    deletedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    smallDescription: string | null
    description: string | null
    fileKey: string | null
    price: number | null
    currency: string | null
    duration: number | null
    status: string | null
    level: string | null
    stripePriceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    categoryId: string | null
    deletedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    smallDescription: number
    description: number
    fileKey: number
    price: number
    currency: number
    duration: number
    status: number
    level: number
    stripePriceId: number
    createdAt: number
    updatedAt: number
    userId: number
    categoryId: number
    deletedAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type CourseSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    smallDescription?: true
    description?: true
    fileKey?: true
    price?: true
    currency?: true
    duration?: true
    status?: true
    level?: true
    stripePriceId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    categoryId?: true
    deletedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    smallDescription?: true
    description?: true
    fileKey?: true
    price?: true
    currency?: true
    duration?: true
    status?: true
    level?: true
    stripePriceId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    categoryId?: true
    deletedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    smallDescription?: true
    description?: true
    fileKey?: true
    price?: true
    currency?: true
    duration?: true
    status?: true
    level?: true
    stripePriceId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    categoryId?: true
    deletedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt: Date
    updatedAt: Date
    userId: string
    categoryId: string
    deletedAt: Date | null
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    smallDescription?: boolean
    description?: boolean
    fileKey?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    status?: boolean
    level?: boolean
    stripePriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    categoryId?: boolean
    deletedAt?: boolean
    user?: boolean | Course$userArgs<ExtArgs>
    chapters?: boolean | Course$chaptersArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    payments?: boolean | Course$paymentsArgs<ExtArgs>
    promotions?: boolean | Course$promotionsArgs<ExtArgs>
    promoCodes?: boolean | Course$promoCodesArgs<ExtArgs>
    tags?: boolean | Course$tagsArgs<ExtArgs>
    progress?: boolean | Course$progressArgs<ExtArgs>
    resources?: boolean | Course$resourcesArgs<ExtArgs>
    learningPathItems?: boolean | Course$learningPathItemsArgs<ExtArgs>
    objectives?: boolean | Course$objectivesArgs<ExtArgs>
    prerequisites?: boolean | Course$prerequisitesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    smallDescription?: boolean
    description?: boolean
    fileKey?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    status?: boolean
    level?: boolean
    stripePriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    categoryId?: boolean
    deletedAt?: boolean
    user?: boolean | Course$userArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    smallDescription?: boolean
    description?: boolean
    fileKey?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    status?: boolean
    level?: boolean
    stripePriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    categoryId?: boolean
    deletedAt?: boolean
    user?: boolean | Course$userArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    smallDescription?: boolean
    description?: boolean
    fileKey?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    status?: boolean
    level?: boolean
    stripePriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    categoryId?: boolean
    deletedAt?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "smallDescription" | "description" | "fileKey" | "price" | "currency" | "duration" | "status" | "level" | "stripePriceId" | "createdAt" | "updatedAt" | "userId" | "categoryId" | "deletedAt", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Course$userArgs<ExtArgs>
    chapters?: boolean | Course$chaptersArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    payments?: boolean | Course$paymentsArgs<ExtArgs>
    promotions?: boolean | Course$promotionsArgs<ExtArgs>
    promoCodes?: boolean | Course$promoCodesArgs<ExtArgs>
    tags?: boolean | Course$tagsArgs<ExtArgs>
    progress?: boolean | Course$progressArgs<ExtArgs>
    resources?: boolean | Course$resourcesArgs<ExtArgs>
    learningPathItems?: boolean | Course$learningPathItemsArgs<ExtArgs>
    objectives?: boolean | Course$objectivesArgs<ExtArgs>
    prerequisites?: boolean | Course$prerequisitesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Course$userArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Course$userArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      chapters: Prisma.$ChapterPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      promotions: Prisma.$PromotionPayload<ExtArgs>[]
      promoCodes: Prisma.$PromoCodePayload<ExtArgs>[]
      tags: Prisma.$CourseTagPayload<ExtArgs>[]
      progress: Prisma.$UserProgressPayload<ExtArgs>[]
      resources: Prisma.$CourseResourcePayload<ExtArgs>[]
      learningPathItems: Prisma.$LearningPathItemPayload<ExtArgs>[]
      objectives: Prisma.$CourseObjectivePayload<ExtArgs>[]
      prerequisites: Prisma.$CoursePrerequisitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      smallDescription: string
      description: string
      fileKey: string
      price: number
      currency: string
      duration: number
      status: string
      level: string
      stripePriceId: string
      createdAt: Date
      updatedAt: Date
      userId: string
      categoryId: string
      deletedAt: Date | null
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Course$userArgs<ExtArgs> = {}>(args?: Subset<T, Course$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    chapters<T extends Course$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, Course$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Course$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Course$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promotions<T extends Course$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Course$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promoCodes<T extends Course$promoCodesArgs<ExtArgs> = {}>(args?: Subset<T, Course$promoCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Course$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Course$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progress<T extends Course$progressArgs<ExtArgs> = {}>(args?: Subset<T, Course$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resources<T extends Course$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, Course$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningPathItems<T extends Course$learningPathItemsArgs<ExtArgs> = {}>(args?: Subset<T, Course$learningPathItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    objectives<T extends Course$objectivesArgs<ExtArgs> = {}>(args?: Subset<T, Course$objectivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prerequisites<T extends Course$prerequisitesArgs<ExtArgs> = {}>(args?: Subset<T, Course$prerequisitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly slug: FieldRef<"Course", 'String'>
    readonly smallDescription: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly fileKey: FieldRef<"Course", 'String'>
    readonly price: FieldRef<"Course", 'Int'>
    readonly currency: FieldRef<"Course", 'String'>
    readonly duration: FieldRef<"Course", 'Int'>
    readonly status: FieldRef<"Course", 'String'>
    readonly level: FieldRef<"Course", 'String'>
    readonly stripePriceId: FieldRef<"Course", 'String'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
    readonly userId: FieldRef<"Course", 'String'>
    readonly categoryId: FieldRef<"Course", 'String'>
    readonly deletedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.user
   */
  export type Course$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Course.chapters
   */
  export type Course$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    cursor?: ChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Course.enrollments
   */
  export type Course$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Course.payments
   */
  export type Course$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Course.promotions
   */
  export type Course$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    cursor?: PromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Course.promoCodes
   */
  export type Course$promoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    cursor?: PromoCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * Course.tags
   */
  export type Course$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    where?: CourseTagWhereInput
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    cursor?: CourseTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * Course.progress
   */
  export type Course$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * Course.resources
   */
  export type Course$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceInclude<ExtArgs> | null
    where?: CourseResourceWhereInput
    orderBy?: CourseResourceOrderByWithRelationInput | CourseResourceOrderByWithRelationInput[]
    cursor?: CourseResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseResourceScalarFieldEnum | CourseResourceScalarFieldEnum[]
  }

  /**
   * Course.learningPathItems
   */
  export type Course$learningPathItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    where?: LearningPathItemWhereInput
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    cursor?: LearningPathItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathItemScalarFieldEnum | LearningPathItemScalarFieldEnum[]
  }

  /**
   * Course.objectives
   */
  export type Course$objectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null
    where?: CourseObjectiveWhereInput
    orderBy?: CourseObjectiveOrderByWithRelationInput | CourseObjectiveOrderByWithRelationInput[]
    cursor?: CourseObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseObjectiveScalarFieldEnum | CourseObjectiveScalarFieldEnum[]
  }

  /**
   * Course.prerequisites
   */
  export type Course$prerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteInclude<ExtArgs> | null
    where?: CoursePrerequisiteWhereInput
    orderBy?: CoursePrerequisiteOrderByWithRelationInput | CoursePrerequisiteOrderByWithRelationInput[]
    cursor?: CoursePrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoursePrerequisiteScalarFieldEnum | CoursePrerequisiteScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Chapter
   */

  export type AggregateChapter = {
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  export type ChapterAvgAggregateOutputType = {
    position: number | null
  }

  export type ChapterSumAggregateOutputType = {
    position: number | null
  }

  export type ChapterMinAggregateOutputType = {
    id: string | null
    title: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    courseId: string | null
  }

  export type ChapterMaxAggregateOutputType = {
    id: string | null
    title: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    courseId: string | null
  }

  export type ChapterCountAggregateOutputType = {
    id: number
    title: number
    position: number
    createdAt: number
    updatedAt: number
    courseId: number
    _all: number
  }


  export type ChapterAvgAggregateInputType = {
    position?: true
  }

  export type ChapterSumAggregateInputType = {
    position?: true
  }

  export type ChapterMinAggregateInputType = {
    id?: true
    title?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    courseId?: true
  }

  export type ChapterMaxAggregateInputType = {
    id?: true
    title?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    courseId?: true
  }

  export type ChapterCountAggregateInputType = {
    id?: true
    title?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    courseId?: true
    _all?: true
  }

  export type ChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapter to aggregate.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chapters
    **/
    _count?: true | ChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterMaxAggregateInputType
  }

  export type GetChapterAggregateType<T extends ChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter[P]>
      : GetScalarType<T[P], AggregateChapter[P]>
  }




  export type ChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithAggregationInput | ChapterOrderByWithAggregationInput[]
    by: ChapterScalarFieldEnum[] | ChapterScalarFieldEnum
    having?: ChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterCountAggregateInputType | true
    _avg?: ChapterAvgAggregateInputType
    _sum?: ChapterSumAggregateInputType
    _min?: ChapterMinAggregateInputType
    _max?: ChapterMaxAggregateInputType
  }

  export type ChapterGroupByOutputType = {
    id: string
    title: string
    position: number
    createdAt: Date
    updatedAt: Date
    courseId: string
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  type GetChapterGroupByPayload<T extends ChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterGroupByOutputType[P]>
        }
      >
    >


  export type ChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lessons?: boolean | Chapter$lessonsArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectScalar = {
    id?: boolean
    title?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
  }

  export type ChapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "position" | "createdAt" | "updatedAt" | "courseId", ExtArgs["result"]["chapter"]>
  export type ChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lessons?: boolean | Chapter$lessonsArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $ChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chapter"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      lessons: Prisma.$LessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      position: number
      createdAt: Date
      updatedAt: Date
      courseId: string
    }, ExtArgs["result"]["chapter"]>
    composites: {}
  }

  type ChapterGetPayload<S extends boolean | null | undefined | ChapterDefaultArgs> = $Result.GetResult<Prisma.$ChapterPayload, S>

  type ChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterCountAggregateInputType | true
    }

  export interface ChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chapter'], meta: { name: 'Chapter' } }
    /**
     * Find zero or one Chapter that matches the filter.
     * @param {ChapterFindUniqueArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterFindUniqueArgs>(args: SelectSubset<T, ChapterFindUniqueArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChapterFindUniqueOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterFindFirstArgs>(args?: SelectSubset<T, ChapterFindFirstArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapter.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterWithIdOnly = await prisma.chapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterFindManyArgs>(args?: SelectSubset<T, ChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chapter.
     * @param {ChapterCreateArgs} args - Arguments to create a Chapter.
     * @example
     * // Create one Chapter
     * const Chapter = await prisma.chapter.create({
     *   data: {
     *     // ... data to create a Chapter
     *   }
     * })
     * 
     */
    create<T extends ChapterCreateArgs>(args: SelectSubset<T, ChapterCreateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chapters.
     * @param {ChapterCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterCreateManyArgs>(args?: SelectSubset<T, ChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chapters and returns the data saved in the database.
     * @param {ChapterCreateManyAndReturnArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chapter.
     * @param {ChapterDeleteArgs} args - Arguments to delete one Chapter.
     * @example
     * // Delete one Chapter
     * const Chapter = await prisma.chapter.delete({
     *   where: {
     *     // ... filter to delete one Chapter
     *   }
     * })
     * 
     */
    delete<T extends ChapterDeleteArgs>(args: SelectSubset<T, ChapterDeleteArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chapter.
     * @param {ChapterUpdateArgs} args - Arguments to update one Chapter.
     * @example
     * // Update one Chapter
     * const chapter = await prisma.chapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterUpdateArgs>(args: SelectSubset<T, ChapterUpdateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chapters.
     * @param {ChapterDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterDeleteManyArgs>(args?: SelectSubset<T, ChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterUpdateManyArgs>(args: SelectSubset<T, ChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters and returns the data updated in the database.
     * @param {ChapterUpdateManyAndReturnArgs} args - Arguments to update many Chapters.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChapterUpdateManyAndReturnArgs>(args: SelectSubset<T, ChapterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chapter.
     * @param {ChapterUpsertArgs} args - Arguments to update or create a Chapter.
     * @example
     * // Update or create a Chapter
     * const chapter = await prisma.chapter.upsert({
     *   create: {
     *     // ... data to create a Chapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter we want to update
     *   }
     * })
     */
    upsert<T extends ChapterUpsertArgs>(args: SelectSubset<T, ChapterUpsertArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapter.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends ChapterCountArgs>(
      args?: Subset<T, ChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterAggregateArgs>(args: Subset<T, ChapterAggregateArgs>): Prisma.PrismaPromise<GetChapterAggregateType<T>>

    /**
     * Group by Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterGroupByArgs['orderBy'] }
        : { orderBy?: ChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chapter model
   */
  readonly fields: ChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lessons<T extends Chapter$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chapter model
   */
  interface ChapterFieldRefs {
    readonly id: FieldRef<"Chapter", 'String'>
    readonly title: FieldRef<"Chapter", 'String'>
    readonly position: FieldRef<"Chapter", 'Int'>
    readonly createdAt: FieldRef<"Chapter", 'DateTime'>
    readonly updatedAt: FieldRef<"Chapter", 'DateTime'>
    readonly courseId: FieldRef<"Chapter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chapter findUnique
   */
  export type ChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findUniqueOrThrow
   */
  export type ChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findFirst
   */
  export type ChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findFirstOrThrow
   */
  export type ChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findMany
   */
  export type ChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter create
   */
  export type ChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a Chapter.
     */
    data: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
  }

  /**
   * Chapter createMany
   */
  export type ChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chapter createManyAndReturn
   */
  export type ChapterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter update
   */
  export type ChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a Chapter.
     */
    data: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
    /**
     * Choose, which Chapter to update.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter updateMany
   */
  export type ChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
  }

  /**
   * Chapter updateManyAndReturn
   */
  export type ChapterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter upsert
   */
  export type ChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the Chapter to update in case it exists.
     */
    where: ChapterWhereUniqueInput
    /**
     * In case the Chapter found by the `where` argument doesn't exist, create a new Chapter with this data.
     */
    create: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
    /**
     * In case the Chapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
  }

  /**
   * Chapter delete
   */
  export type ChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter which Chapter to delete.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter deleteMany
   */
  export type ChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to delete
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to delete.
     */
    limit?: number
  }

  /**
   * Chapter.lessons
   */
  export type Chapter$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Chapter without action
   */
  export type ChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    position: number | null
    duration: number | null
  }

  export type LessonSumAggregateOutputType = {
    position: number | null
    duration: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    thumbnailKey: string | null
    videoKey: string | null
    position: number | null
    duration: number | null
    public: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    chapterId: string | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    thumbnailKey: string | null
    videoKey: string | null
    position: number | null
    duration: number | null
    public: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    chapterId: string | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    title: number
    description: number
    thumbnailKey: number
    videoKey: number
    position: number
    duration: number
    public: number
    createdAt: number
    updatedAt: number
    chapterId: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    position?: true
    duration?: true
  }

  export type LessonSumAggregateInputType = {
    position?: true
    duration?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnailKey?: true
    videoKey?: true
    position?: true
    duration?: true
    public?: true
    createdAt?: true
    updatedAt?: true
    chapterId?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnailKey?: true
    videoKey?: true
    position?: true
    duration?: true
    public?: true
    createdAt?: true
    updatedAt?: true
    chapterId?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnailKey?: true
    videoKey?: true
    position?: true
    duration?: true
    public?: true
    createdAt?: true
    updatedAt?: true
    chapterId?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: string
    title: string
    description: string | null
    thumbnailKey: string | null
    videoKey: string | null
    position: number
    duration: number
    public: boolean
    createdAt: Date
    updatedAt: Date
    chapterId: string
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnailKey?: boolean
    videoKey?: boolean
    position?: boolean
    duration?: boolean
    public?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chapterId?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    lessonProgress?: boolean | Lesson$lessonProgressArgs<ExtArgs>
    resources?: boolean | Lesson$resourcesArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnailKey?: boolean
    videoKey?: boolean
    position?: boolean
    duration?: boolean
    public?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chapterId?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnailKey?: boolean
    videoKey?: boolean
    position?: boolean
    duration?: boolean
    public?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chapterId?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnailKey?: boolean
    videoKey?: boolean
    position?: boolean
    duration?: boolean
    public?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chapterId?: boolean
  }

  export type LessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "thumbnailKey" | "videoKey" | "position" | "duration" | "public" | "createdAt" | "updatedAt" | "chapterId", ExtArgs["result"]["lesson"]>
  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    lessonProgress?: boolean | Lesson$lessonProgressArgs<ExtArgs>
    resources?: boolean | Lesson$resourcesArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type LessonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      chapter: Prisma.$ChapterPayload<ExtArgs>
      lessonProgress: Prisma.$LessonProgressPayload<ExtArgs>[]
      resources: Prisma.$LessonResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      thumbnailKey: string | null
      videoKey: string | null
      position: number
      duration: number
      public: boolean
      createdAt: Date
      updatedAt: Date
      chapterId: string
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lessonProgress<T extends Lesson$lessonProgressArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$lessonProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resources<T extends Lesson$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'String'>
    readonly title: FieldRef<"Lesson", 'String'>
    readonly description: FieldRef<"Lesson", 'String'>
    readonly thumbnailKey: FieldRef<"Lesson", 'String'>
    readonly videoKey: FieldRef<"Lesson", 'String'>
    readonly position: FieldRef<"Lesson", 'Int'>
    readonly duration: FieldRef<"Lesson", 'Int'>
    readonly public: FieldRef<"Lesson", 'Boolean'>
    readonly createdAt: FieldRef<"Lesson", 'DateTime'>
    readonly updatedAt: FieldRef<"Lesson", 'DateTime'>
    readonly chapterId: FieldRef<"Lesson", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lesson updateManyAndReturn
   */
  export type LessonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lesson.lessonProgress
   */
  export type Lesson$lessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    where?: LessonProgressWhereInput
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    cursor?: LessonProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * Lesson.resources
   */
  export type Lesson$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceInclude<ExtArgs> | null
    where?: LessonResourceWhereInput
    orderBy?: LessonResourceOrderByWithRelationInput | LessonResourceOrderByWithRelationInput[]
    cursor?: LessonResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonResourceScalarFieldEnum | LessonResourceScalarFieldEnum[]
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model Workshop
   */

  export type AggregateWorkshop = {
    _count: WorkshopCountAggregateOutputType | null
    _avg: WorkshopAvgAggregateOutputType | null
    _sum: WorkshopSumAggregateOutputType | null
    _min: WorkshopMinAggregateOutputType | null
    _max: WorkshopMaxAggregateOutputType | null
  }

  export type WorkshopAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type WorkshopSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type WorkshopMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    slug: string | null
    statement: string | null
    fileKey: string | null
    statementsStartFileKey: string | null
    statementsStartFileUrl: string | null
    statementVideoKey: string | null
    price: number | null
    currency: string | null
    duration: number | null
    status: string | null
    level: string | null
    stripePriceId: string | null
    solution: string | null
    solutionFileKey: string | null
    solutionFileUrl: string | null
    solutionVideoKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    deletedAt: Date | null
  }

  export type WorkshopMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    slug: string | null
    statement: string | null
    fileKey: string | null
    statementsStartFileKey: string | null
    statementsStartFileUrl: string | null
    statementVideoKey: string | null
    price: number | null
    currency: string | null
    duration: number | null
    status: string | null
    level: string | null
    stripePriceId: string | null
    solution: string | null
    solutionFileKey: string | null
    solutionFileUrl: string | null
    solutionVideoKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    deletedAt: Date | null
  }

  export type WorkshopCountAggregateOutputType = {
    id: number
    title: number
    description: number
    slug: number
    statement: number
    fileKey: number
    statementsStartFileKey: number
    statementsStartFileUrl: number
    statementVideoKey: number
    price: number
    currency: number
    duration: number
    status: number
    level: number
    stripePriceId: number
    solution: number
    solutionFileKey: number
    solutionFileUrl: number
    solutionVideoKey: number
    createdAt: number
    updatedAt: number
    userId: number
    deletedAt: number
    _all: number
  }


  export type WorkshopAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type WorkshopSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type WorkshopMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    slug?: true
    statement?: true
    fileKey?: true
    statementsStartFileKey?: true
    statementsStartFileUrl?: true
    statementVideoKey?: true
    price?: true
    currency?: true
    duration?: true
    status?: true
    level?: true
    stripePriceId?: true
    solution?: true
    solutionFileKey?: true
    solutionFileUrl?: true
    solutionVideoKey?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    deletedAt?: true
  }

  export type WorkshopMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    slug?: true
    statement?: true
    fileKey?: true
    statementsStartFileKey?: true
    statementsStartFileUrl?: true
    statementVideoKey?: true
    price?: true
    currency?: true
    duration?: true
    status?: true
    level?: true
    stripePriceId?: true
    solution?: true
    solutionFileKey?: true
    solutionFileUrl?: true
    solutionVideoKey?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    deletedAt?: true
  }

  export type WorkshopCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    slug?: true
    statement?: true
    fileKey?: true
    statementsStartFileKey?: true
    statementsStartFileUrl?: true
    statementVideoKey?: true
    price?: true
    currency?: true
    duration?: true
    status?: true
    level?: true
    stripePriceId?: true
    solution?: true
    solutionFileKey?: true
    solutionFileUrl?: true
    solutionVideoKey?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    deletedAt?: true
    _all?: true
  }

  export type WorkshopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workshop to aggregate.
     */
    where?: WorkshopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workshops to fetch.
     */
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkshopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workshops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workshops
    **/
    _count?: true | WorkshopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkshopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkshopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkshopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkshopMaxAggregateInputType
  }

  export type GetWorkshopAggregateType<T extends WorkshopAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkshop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkshop[P]>
      : GetScalarType<T[P], AggregateWorkshop[P]>
  }




  export type WorkshopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopWhereInput
    orderBy?: WorkshopOrderByWithAggregationInput | WorkshopOrderByWithAggregationInput[]
    by: WorkshopScalarFieldEnum[] | WorkshopScalarFieldEnum
    having?: WorkshopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkshopCountAggregateInputType | true
    _avg?: WorkshopAvgAggregateInputType
    _sum?: WorkshopSumAggregateInputType
    _min?: WorkshopMinAggregateInputType
    _max?: WorkshopMaxAggregateInputType
  }

  export type WorkshopGroupByOutputType = {
    id: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey: string | null
    statementsStartFileUrl: string | null
    statementVideoKey: string | null
    price: number
    currency: string
    duration: number
    status: string
    level: string
    stripePriceId: string | null
    solution: string | null
    solutionFileKey: string | null
    solutionFileUrl: string | null
    solutionVideoKey: string | null
    createdAt: Date
    updatedAt: Date
    userId: string
    deletedAt: Date | null
    _count: WorkshopCountAggregateOutputType | null
    _avg: WorkshopAvgAggregateOutputType | null
    _sum: WorkshopSumAggregateOutputType | null
    _min: WorkshopMinAggregateOutputType | null
    _max: WorkshopMaxAggregateOutputType | null
  }

  type GetWorkshopGroupByPayload<T extends WorkshopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkshopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkshopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkshopGroupByOutputType[P]>
            : GetScalarType<T[P], WorkshopGroupByOutputType[P]>
        }
      >
    >


  export type WorkshopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    statement?: boolean
    fileKey?: boolean
    statementsStartFileKey?: boolean
    statementsStartFileUrl?: boolean
    statementVideoKey?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    status?: boolean
    level?: boolean
    stripePriceId?: boolean
    solution?: boolean
    solutionFileKey?: boolean
    solutionFileUrl?: boolean
    solutionVideoKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    deletedAt?: boolean
    user?: boolean | Workshop$userArgs<ExtArgs>
    tags?: boolean | Workshop$tagsArgs<ExtArgs>
    progress?: boolean | Workshop$progressArgs<ExtArgs>
    resources?: boolean | Workshop$resourcesArgs<ExtArgs>
    learningPathItems?: boolean | Workshop$learningPathItemsArgs<ExtArgs>
    objectives?: boolean | Workshop$objectivesArgs<ExtArgs>
    prerequisites?: boolean | Workshop$prerequisitesArgs<ExtArgs>
    promoCodes?: boolean | Workshop$promoCodesArgs<ExtArgs>
    promotions?: boolean | Workshop$promotionsArgs<ExtArgs>
    enrollments?: boolean | Workshop$enrollmentsArgs<ExtArgs>
    payments?: boolean | Workshop$paymentsArgs<ExtArgs>
    _count?: boolean | WorkshopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshop"]>

  export type WorkshopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    statement?: boolean
    fileKey?: boolean
    statementsStartFileKey?: boolean
    statementsStartFileUrl?: boolean
    statementVideoKey?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    status?: boolean
    level?: boolean
    stripePriceId?: boolean
    solution?: boolean
    solutionFileKey?: boolean
    solutionFileUrl?: boolean
    solutionVideoKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    deletedAt?: boolean
    user?: boolean | Workshop$userArgs<ExtArgs>
  }, ExtArgs["result"]["workshop"]>

  export type WorkshopSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    statement?: boolean
    fileKey?: boolean
    statementsStartFileKey?: boolean
    statementsStartFileUrl?: boolean
    statementVideoKey?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    status?: boolean
    level?: boolean
    stripePriceId?: boolean
    solution?: boolean
    solutionFileKey?: boolean
    solutionFileUrl?: boolean
    solutionVideoKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    deletedAt?: boolean
    user?: boolean | Workshop$userArgs<ExtArgs>
  }, ExtArgs["result"]["workshop"]>

  export type WorkshopSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    statement?: boolean
    fileKey?: boolean
    statementsStartFileKey?: boolean
    statementsStartFileUrl?: boolean
    statementVideoKey?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    status?: boolean
    level?: boolean
    stripePriceId?: boolean
    solution?: boolean
    solutionFileKey?: boolean
    solutionFileUrl?: boolean
    solutionVideoKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    deletedAt?: boolean
  }

  export type WorkshopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "slug" | "statement" | "fileKey" | "statementsStartFileKey" | "statementsStartFileUrl" | "statementVideoKey" | "price" | "currency" | "duration" | "status" | "level" | "stripePriceId" | "solution" | "solutionFileKey" | "solutionFileUrl" | "solutionVideoKey" | "createdAt" | "updatedAt" | "userId" | "deletedAt", ExtArgs["result"]["workshop"]>
  export type WorkshopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Workshop$userArgs<ExtArgs>
    tags?: boolean | Workshop$tagsArgs<ExtArgs>
    progress?: boolean | Workshop$progressArgs<ExtArgs>
    resources?: boolean | Workshop$resourcesArgs<ExtArgs>
    learningPathItems?: boolean | Workshop$learningPathItemsArgs<ExtArgs>
    objectives?: boolean | Workshop$objectivesArgs<ExtArgs>
    prerequisites?: boolean | Workshop$prerequisitesArgs<ExtArgs>
    promoCodes?: boolean | Workshop$promoCodesArgs<ExtArgs>
    promotions?: boolean | Workshop$promotionsArgs<ExtArgs>
    enrollments?: boolean | Workshop$enrollmentsArgs<ExtArgs>
    payments?: boolean | Workshop$paymentsArgs<ExtArgs>
    _count?: boolean | WorkshopCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkshopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Workshop$userArgs<ExtArgs>
  }
  export type WorkshopIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Workshop$userArgs<ExtArgs>
  }

  export type $WorkshopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workshop"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      tags: Prisma.$WorkshopTagPayload<ExtArgs>[]
      progress: Prisma.$UserProgressPayload<ExtArgs>[]
      resources: Prisma.$WorkshopResourcePayload<ExtArgs>[]
      learningPathItems: Prisma.$LearningPathItemPayload<ExtArgs>[]
      objectives: Prisma.$WorkshopObjectivePayload<ExtArgs>[]
      prerequisites: Prisma.$WorkshopPrerequisitePayload<ExtArgs>[]
      promoCodes: Prisma.$PromoCodePayload<ExtArgs>[]
      promotions: Prisma.$PromotionPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      slug: string
      statement: string
      fileKey: string
      statementsStartFileKey: string | null
      statementsStartFileUrl: string | null
      statementVideoKey: string | null
      price: number
      currency: string
      duration: number
      status: string
      level: string
      stripePriceId: string | null
      solution: string | null
      solutionFileKey: string | null
      solutionFileUrl: string | null
      solutionVideoKey: string | null
      createdAt: Date
      updatedAt: Date
      userId: string
      deletedAt: Date | null
    }, ExtArgs["result"]["workshop"]>
    composites: {}
  }

  type WorkshopGetPayload<S extends boolean | null | undefined | WorkshopDefaultArgs> = $Result.GetResult<Prisma.$WorkshopPayload, S>

  type WorkshopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkshopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkshopCountAggregateInputType | true
    }

  export interface WorkshopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workshop'], meta: { name: 'Workshop' } }
    /**
     * Find zero or one Workshop that matches the filter.
     * @param {WorkshopFindUniqueArgs} args - Arguments to find a Workshop
     * @example
     * // Get one Workshop
     * const workshop = await prisma.workshop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkshopFindUniqueArgs>(args: SelectSubset<T, WorkshopFindUniqueArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workshop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkshopFindUniqueOrThrowArgs} args - Arguments to find a Workshop
     * @example
     * // Get one Workshop
     * const workshop = await prisma.workshop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkshopFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkshopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workshop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopFindFirstArgs} args - Arguments to find a Workshop
     * @example
     * // Get one Workshop
     * const workshop = await prisma.workshop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkshopFindFirstArgs>(args?: SelectSubset<T, WorkshopFindFirstArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workshop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopFindFirstOrThrowArgs} args - Arguments to find a Workshop
     * @example
     * // Get one Workshop
     * const workshop = await prisma.workshop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkshopFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkshopFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workshops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workshops
     * const workshops = await prisma.workshop.findMany()
     * 
     * // Get first 10 Workshops
     * const workshops = await prisma.workshop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workshopWithIdOnly = await prisma.workshop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkshopFindManyArgs>(args?: SelectSubset<T, WorkshopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workshop.
     * @param {WorkshopCreateArgs} args - Arguments to create a Workshop.
     * @example
     * // Create one Workshop
     * const Workshop = await prisma.workshop.create({
     *   data: {
     *     // ... data to create a Workshop
     *   }
     * })
     * 
     */
    create<T extends WorkshopCreateArgs>(args: SelectSubset<T, WorkshopCreateArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workshops.
     * @param {WorkshopCreateManyArgs} args - Arguments to create many Workshops.
     * @example
     * // Create many Workshops
     * const workshop = await prisma.workshop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkshopCreateManyArgs>(args?: SelectSubset<T, WorkshopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workshops and returns the data saved in the database.
     * @param {WorkshopCreateManyAndReturnArgs} args - Arguments to create many Workshops.
     * @example
     * // Create many Workshops
     * const workshop = await prisma.workshop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workshops and only return the `id`
     * const workshopWithIdOnly = await prisma.workshop.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkshopCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkshopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workshop.
     * @param {WorkshopDeleteArgs} args - Arguments to delete one Workshop.
     * @example
     * // Delete one Workshop
     * const Workshop = await prisma.workshop.delete({
     *   where: {
     *     // ... filter to delete one Workshop
     *   }
     * })
     * 
     */
    delete<T extends WorkshopDeleteArgs>(args: SelectSubset<T, WorkshopDeleteArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workshop.
     * @param {WorkshopUpdateArgs} args - Arguments to update one Workshop.
     * @example
     * // Update one Workshop
     * const workshop = await prisma.workshop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkshopUpdateArgs>(args: SelectSubset<T, WorkshopUpdateArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workshops.
     * @param {WorkshopDeleteManyArgs} args - Arguments to filter Workshops to delete.
     * @example
     * // Delete a few Workshops
     * const { count } = await prisma.workshop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkshopDeleteManyArgs>(args?: SelectSubset<T, WorkshopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workshops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workshops
     * const workshop = await prisma.workshop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkshopUpdateManyArgs>(args: SelectSubset<T, WorkshopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workshops and returns the data updated in the database.
     * @param {WorkshopUpdateManyAndReturnArgs} args - Arguments to update many Workshops.
     * @example
     * // Update many Workshops
     * const workshop = await prisma.workshop.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workshops and only return the `id`
     * const workshopWithIdOnly = await prisma.workshop.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkshopUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkshopUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workshop.
     * @param {WorkshopUpsertArgs} args - Arguments to update or create a Workshop.
     * @example
     * // Update or create a Workshop
     * const workshop = await prisma.workshop.upsert({
     *   create: {
     *     // ... data to create a Workshop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workshop we want to update
     *   }
     * })
     */
    upsert<T extends WorkshopUpsertArgs>(args: SelectSubset<T, WorkshopUpsertArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workshops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopCountArgs} args - Arguments to filter Workshops to count.
     * @example
     * // Count the number of Workshops
     * const count = await prisma.workshop.count({
     *   where: {
     *     // ... the filter for the Workshops we want to count
     *   }
     * })
    **/
    count<T extends WorkshopCountArgs>(
      args?: Subset<T, WorkshopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkshopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workshop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkshopAggregateArgs>(args: Subset<T, WorkshopAggregateArgs>): Prisma.PrismaPromise<GetWorkshopAggregateType<T>>

    /**
     * Group by Workshop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkshopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkshopGroupByArgs['orderBy'] }
        : { orderBy?: WorkshopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkshopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkshopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workshop model
   */
  readonly fields: WorkshopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workshop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkshopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Workshop$userArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tags<T extends Workshop$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progress<T extends Workshop$progressArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resources<T extends Workshop$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningPathItems<T extends Workshop$learningPathItemsArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$learningPathItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    objectives<T extends Workshop$objectivesArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$objectivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prerequisites<T extends Workshop$prerequisitesArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$prerequisitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promoCodes<T extends Workshop$promoCodesArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$promoCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promotions<T extends Workshop$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Workshop$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Workshop$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workshop model
   */
  interface WorkshopFieldRefs {
    readonly id: FieldRef<"Workshop", 'String'>
    readonly title: FieldRef<"Workshop", 'String'>
    readonly description: FieldRef<"Workshop", 'String'>
    readonly slug: FieldRef<"Workshop", 'String'>
    readonly statement: FieldRef<"Workshop", 'String'>
    readonly fileKey: FieldRef<"Workshop", 'String'>
    readonly statementsStartFileKey: FieldRef<"Workshop", 'String'>
    readonly statementsStartFileUrl: FieldRef<"Workshop", 'String'>
    readonly statementVideoKey: FieldRef<"Workshop", 'String'>
    readonly price: FieldRef<"Workshop", 'Int'>
    readonly currency: FieldRef<"Workshop", 'String'>
    readonly duration: FieldRef<"Workshop", 'Int'>
    readonly status: FieldRef<"Workshop", 'String'>
    readonly level: FieldRef<"Workshop", 'String'>
    readonly stripePriceId: FieldRef<"Workshop", 'String'>
    readonly solution: FieldRef<"Workshop", 'String'>
    readonly solutionFileKey: FieldRef<"Workshop", 'String'>
    readonly solutionFileUrl: FieldRef<"Workshop", 'String'>
    readonly solutionVideoKey: FieldRef<"Workshop", 'String'>
    readonly createdAt: FieldRef<"Workshop", 'DateTime'>
    readonly updatedAt: FieldRef<"Workshop", 'DateTime'>
    readonly userId: FieldRef<"Workshop", 'String'>
    readonly deletedAt: FieldRef<"Workshop", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workshop findUnique
   */
  export type WorkshopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshop to fetch.
     */
    where: WorkshopWhereUniqueInput
  }

  /**
   * Workshop findUniqueOrThrow
   */
  export type WorkshopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshop to fetch.
     */
    where: WorkshopWhereUniqueInput
  }

  /**
   * Workshop findFirst
   */
  export type WorkshopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshop to fetch.
     */
    where?: WorkshopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workshops to fetch.
     */
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workshops.
     */
    cursor?: WorkshopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workshops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workshops.
     */
    distinct?: WorkshopScalarFieldEnum | WorkshopScalarFieldEnum[]
  }

  /**
   * Workshop findFirstOrThrow
   */
  export type WorkshopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshop to fetch.
     */
    where?: WorkshopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workshops to fetch.
     */
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workshops.
     */
    cursor?: WorkshopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workshops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workshops.
     */
    distinct?: WorkshopScalarFieldEnum | WorkshopScalarFieldEnum[]
  }

  /**
   * Workshop findMany
   */
  export type WorkshopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshops to fetch.
     */
    where?: WorkshopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workshops to fetch.
     */
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workshops.
     */
    cursor?: WorkshopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workshops.
     */
    skip?: number
    distinct?: WorkshopScalarFieldEnum | WorkshopScalarFieldEnum[]
  }

  /**
   * Workshop create
   */
  export type WorkshopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * The data needed to create a Workshop.
     */
    data: XOR<WorkshopCreateInput, WorkshopUncheckedCreateInput>
  }

  /**
   * Workshop createMany
   */
  export type WorkshopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workshops.
     */
    data: WorkshopCreateManyInput | WorkshopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workshop createManyAndReturn
   */
  export type WorkshopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * The data used to create many Workshops.
     */
    data: WorkshopCreateManyInput | WorkshopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workshop update
   */
  export type WorkshopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * The data needed to update a Workshop.
     */
    data: XOR<WorkshopUpdateInput, WorkshopUncheckedUpdateInput>
    /**
     * Choose, which Workshop to update.
     */
    where: WorkshopWhereUniqueInput
  }

  /**
   * Workshop updateMany
   */
  export type WorkshopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workshops.
     */
    data: XOR<WorkshopUpdateManyMutationInput, WorkshopUncheckedUpdateManyInput>
    /**
     * Filter which Workshops to update
     */
    where?: WorkshopWhereInput
    /**
     * Limit how many Workshops to update.
     */
    limit?: number
  }

  /**
   * Workshop updateManyAndReturn
   */
  export type WorkshopUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * The data used to update Workshops.
     */
    data: XOR<WorkshopUpdateManyMutationInput, WorkshopUncheckedUpdateManyInput>
    /**
     * Filter which Workshops to update
     */
    where?: WorkshopWhereInput
    /**
     * Limit how many Workshops to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workshop upsert
   */
  export type WorkshopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * The filter to search for the Workshop to update in case it exists.
     */
    where: WorkshopWhereUniqueInput
    /**
     * In case the Workshop found by the `where` argument doesn't exist, create a new Workshop with this data.
     */
    create: XOR<WorkshopCreateInput, WorkshopUncheckedCreateInput>
    /**
     * In case the Workshop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkshopUpdateInput, WorkshopUncheckedUpdateInput>
  }

  /**
   * Workshop delete
   */
  export type WorkshopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter which Workshop to delete.
     */
    where: WorkshopWhereUniqueInput
  }

  /**
   * Workshop deleteMany
   */
  export type WorkshopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workshops to delete
     */
    where?: WorkshopWhereInput
    /**
     * Limit how many Workshops to delete.
     */
    limit?: number
  }

  /**
   * Workshop.user
   */
  export type Workshop$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Workshop.tags
   */
  export type Workshop$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagInclude<ExtArgs> | null
    where?: WorkshopTagWhereInput
    orderBy?: WorkshopTagOrderByWithRelationInput | WorkshopTagOrderByWithRelationInput[]
    cursor?: WorkshopTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopTagScalarFieldEnum | WorkshopTagScalarFieldEnum[]
  }

  /**
   * Workshop.progress
   */
  export type Workshop$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * Workshop.resources
   */
  export type Workshop$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceInclude<ExtArgs> | null
    where?: WorkshopResourceWhereInput
    orderBy?: WorkshopResourceOrderByWithRelationInput | WorkshopResourceOrderByWithRelationInput[]
    cursor?: WorkshopResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopResourceScalarFieldEnum | WorkshopResourceScalarFieldEnum[]
  }

  /**
   * Workshop.learningPathItems
   */
  export type Workshop$learningPathItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    where?: LearningPathItemWhereInput
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    cursor?: LearningPathItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathItemScalarFieldEnum | LearningPathItemScalarFieldEnum[]
  }

  /**
   * Workshop.objectives
   */
  export type Workshop$objectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveInclude<ExtArgs> | null
    where?: WorkshopObjectiveWhereInput
    orderBy?: WorkshopObjectiveOrderByWithRelationInput | WorkshopObjectiveOrderByWithRelationInput[]
    cursor?: WorkshopObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopObjectiveScalarFieldEnum | WorkshopObjectiveScalarFieldEnum[]
  }

  /**
   * Workshop.prerequisites
   */
  export type Workshop$prerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteInclude<ExtArgs> | null
    where?: WorkshopPrerequisiteWhereInput
    orderBy?: WorkshopPrerequisiteOrderByWithRelationInput | WorkshopPrerequisiteOrderByWithRelationInput[]
    cursor?: WorkshopPrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopPrerequisiteScalarFieldEnum | WorkshopPrerequisiteScalarFieldEnum[]
  }

  /**
   * Workshop.promoCodes
   */
  export type Workshop$promoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    cursor?: PromoCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * Workshop.promotions
   */
  export type Workshop$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    cursor?: PromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Workshop.enrollments
   */
  export type Workshop$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Workshop.payments
   */
  export type Workshop$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Workshop without action
   */
  export type WorkshopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    fileKey: string | null
    url: string | null
    type: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    fileKey: string | null
    url: string | null
    type: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    fileKey: number
    url: number
    type: number
    createdAt: number
    userId: number
    _all: number
  }


  export type ResourceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileKey?: true
    url?: true
    type?: true
    createdAt?: true
    userId?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileKey?: true
    url?: true
    type?: true
    createdAt?: true
    userId?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileKey?: true
    url?: true
    type?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: string
    title: string
    description: string | null
    fileKey: string | null
    url: string
    type: string
    createdAt: Date
    userId: string
    _count: ResourceCountAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileKey?: boolean
    url?: boolean
    type?: boolean
    createdAt?: boolean
    userId?: boolean
    courseResources?: boolean | Resource$courseResourcesArgs<ExtArgs>
    lessonResources?: boolean | Resource$lessonResourcesArgs<ExtArgs>
    workshopResources?: boolean | Resource$workshopResourcesArgs<ExtArgs>
    learningPathResources?: boolean | Resource$learningPathResourcesArgs<ExtArgs>
    learningPathItems?: boolean | Resource$learningPathItemsArgs<ExtArgs>
    user?: boolean | Resource$userArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileKey?: boolean
    url?: boolean
    type?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | Resource$userArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileKey?: boolean
    url?: boolean
    type?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | Resource$userArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    fileKey?: boolean
    url?: boolean
    type?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type ResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "fileKey" | "url" | "type" | "createdAt" | "userId", ExtArgs["result"]["resource"]>
  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseResources?: boolean | Resource$courseResourcesArgs<ExtArgs>
    lessonResources?: boolean | Resource$lessonResourcesArgs<ExtArgs>
    workshopResources?: boolean | Resource$workshopResourcesArgs<ExtArgs>
    learningPathResources?: boolean | Resource$learningPathResourcesArgs<ExtArgs>
    learningPathItems?: boolean | Resource$learningPathItemsArgs<ExtArgs>
    user?: boolean | Resource$userArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Resource$userArgs<ExtArgs>
  }
  export type ResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Resource$userArgs<ExtArgs>
  }

  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      courseResources: Prisma.$CourseResourcePayload<ExtArgs>[]
      lessonResources: Prisma.$LessonResourcePayload<ExtArgs>[]
      workshopResources: Prisma.$WorkshopResourcePayload<ExtArgs>[]
      learningPathResources: Prisma.$LearningPathResourcePayload<ExtArgs>[]
      learningPathItems: Prisma.$LearningPathItemPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      fileKey: string | null
      url: string
      type: string
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources and returns the data updated in the database.
     * @param {ResourceUpdateManyAndReturnArgs} args - Arguments to update many Resources.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courseResources<T extends Resource$courseResourcesArgs<ExtArgs> = {}>(args?: Subset<T, Resource$courseResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessonResources<T extends Resource$lessonResourcesArgs<ExtArgs> = {}>(args?: Subset<T, Resource$lessonResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workshopResources<T extends Resource$workshopResourcesArgs<ExtArgs> = {}>(args?: Subset<T, Resource$workshopResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningPathResources<T extends Resource$learningPathResourcesArgs<ExtArgs> = {}>(args?: Subset<T, Resource$learningPathResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningPathItems<T extends Resource$learningPathItemsArgs<ExtArgs> = {}>(args?: Subset<T, Resource$learningPathItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Resource$userArgs<ExtArgs> = {}>(args?: Subset<T, Resource$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'String'>
    readonly title: FieldRef<"Resource", 'String'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly fileKey: FieldRef<"Resource", 'String'>
    readonly url: FieldRef<"Resource", 'String'>
    readonly type: FieldRef<"Resource", 'String'>
    readonly createdAt: FieldRef<"Resource", 'DateTime'>
    readonly userId: FieldRef<"Resource", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource createManyAndReturn
   */
  export type ResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
  }

  /**
   * Resource updateManyAndReturn
   */
  export type ResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to delete.
     */
    limit?: number
  }

  /**
   * Resource.courseResources
   */
  export type Resource$courseResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceInclude<ExtArgs> | null
    where?: CourseResourceWhereInput
    orderBy?: CourseResourceOrderByWithRelationInput | CourseResourceOrderByWithRelationInput[]
    cursor?: CourseResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseResourceScalarFieldEnum | CourseResourceScalarFieldEnum[]
  }

  /**
   * Resource.lessonResources
   */
  export type Resource$lessonResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceInclude<ExtArgs> | null
    where?: LessonResourceWhereInput
    orderBy?: LessonResourceOrderByWithRelationInput | LessonResourceOrderByWithRelationInput[]
    cursor?: LessonResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonResourceScalarFieldEnum | LessonResourceScalarFieldEnum[]
  }

  /**
   * Resource.workshopResources
   */
  export type Resource$workshopResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceInclude<ExtArgs> | null
    where?: WorkshopResourceWhereInput
    orderBy?: WorkshopResourceOrderByWithRelationInput | WorkshopResourceOrderByWithRelationInput[]
    cursor?: WorkshopResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopResourceScalarFieldEnum | WorkshopResourceScalarFieldEnum[]
  }

  /**
   * Resource.learningPathResources
   */
  export type Resource$learningPathResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceInclude<ExtArgs> | null
    where?: LearningPathResourceWhereInput
    orderBy?: LearningPathResourceOrderByWithRelationInput | LearningPathResourceOrderByWithRelationInput[]
    cursor?: LearningPathResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathResourceScalarFieldEnum | LearningPathResourceScalarFieldEnum[]
  }

  /**
   * Resource.learningPathItems
   */
  export type Resource$learningPathItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    where?: LearningPathItemWhereInput
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    cursor?: LearningPathItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathItemScalarFieldEnum | LearningPathItemScalarFieldEnum[]
  }

  /**
   * Resource.user
   */
  export type Resource$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Model LearningPathResource
   */

  export type AggregateLearningPathResource = {
    _count: LearningPathResourceCountAggregateOutputType | null
    _min: LearningPathResourceMinAggregateOutputType | null
    _max: LearningPathResourceMaxAggregateOutputType | null
  }

  export type LearningPathResourceMinAggregateOutputType = {
    learningPathId: string | null
    resourceId: string | null
  }

  export type LearningPathResourceMaxAggregateOutputType = {
    learningPathId: string | null
    resourceId: string | null
  }

  export type LearningPathResourceCountAggregateOutputType = {
    learningPathId: number
    resourceId: number
    _all: number
  }


  export type LearningPathResourceMinAggregateInputType = {
    learningPathId?: true
    resourceId?: true
  }

  export type LearningPathResourceMaxAggregateInputType = {
    learningPathId?: true
    resourceId?: true
  }

  export type LearningPathResourceCountAggregateInputType = {
    learningPathId?: true
    resourceId?: true
    _all?: true
  }

  export type LearningPathResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPathResource to aggregate.
     */
    where?: LearningPathResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathResources to fetch.
     */
    orderBy?: LearningPathResourceOrderByWithRelationInput | LearningPathResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningPathResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningPathResources
    **/
    _count?: true | LearningPathResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningPathResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningPathResourceMaxAggregateInputType
  }

  export type GetLearningPathResourceAggregateType<T extends LearningPathResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningPathResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningPathResource[P]>
      : GetScalarType<T[P], AggregateLearningPathResource[P]>
  }




  export type LearningPathResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathResourceWhereInput
    orderBy?: LearningPathResourceOrderByWithAggregationInput | LearningPathResourceOrderByWithAggregationInput[]
    by: LearningPathResourceScalarFieldEnum[] | LearningPathResourceScalarFieldEnum
    having?: LearningPathResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningPathResourceCountAggregateInputType | true
    _min?: LearningPathResourceMinAggregateInputType
    _max?: LearningPathResourceMaxAggregateInputType
  }

  export type LearningPathResourceGroupByOutputType = {
    learningPathId: string
    resourceId: string
    _count: LearningPathResourceCountAggregateOutputType | null
    _min: LearningPathResourceMinAggregateOutputType | null
    _max: LearningPathResourceMaxAggregateOutputType | null
  }

  type GetLearningPathResourceGroupByPayload<T extends LearningPathResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningPathResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningPathResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningPathResourceGroupByOutputType[P]>
            : GetScalarType<T[P], LearningPathResourceGroupByOutputType[P]>
        }
      >
    >


  export type LearningPathResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learningPathId?: boolean
    resourceId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathResource"]>

  export type LearningPathResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learningPathId?: boolean
    resourceId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathResource"]>

  export type LearningPathResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learningPathId?: boolean
    resourceId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathResource"]>

  export type LearningPathResourceSelectScalar = {
    learningPathId?: boolean
    resourceId?: boolean
  }

  export type LearningPathResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"learningPathId" | "resourceId", ExtArgs["result"]["learningPathResource"]>
  export type LearningPathResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type LearningPathResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type LearningPathResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $LearningPathResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningPathResource"
    objects: {
      learningPath: Prisma.$LearningPathPayload<ExtArgs>
      resource: Prisma.$ResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      learningPathId: string
      resourceId: string
    }, ExtArgs["result"]["learningPathResource"]>
    composites: {}
  }

  type LearningPathResourceGetPayload<S extends boolean | null | undefined | LearningPathResourceDefaultArgs> = $Result.GetResult<Prisma.$LearningPathResourcePayload, S>

  type LearningPathResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningPathResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningPathResourceCountAggregateInputType | true
    }

  export interface LearningPathResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningPathResource'], meta: { name: 'LearningPathResource' } }
    /**
     * Find zero or one LearningPathResource that matches the filter.
     * @param {LearningPathResourceFindUniqueArgs} args - Arguments to find a LearningPathResource
     * @example
     * // Get one LearningPathResource
     * const learningPathResource = await prisma.learningPathResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningPathResourceFindUniqueArgs>(args: SelectSubset<T, LearningPathResourceFindUniqueArgs<ExtArgs>>): Prisma__LearningPathResourceClient<$Result.GetResult<Prisma.$LearningPathResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LearningPathResource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningPathResourceFindUniqueOrThrowArgs} args - Arguments to find a LearningPathResource
     * @example
     * // Get one LearningPathResource
     * const learningPathResource = await prisma.learningPathResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningPathResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningPathResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningPathResourceClient<$Result.GetResult<Prisma.$LearningPathResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningPathResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathResourceFindFirstArgs} args - Arguments to find a LearningPathResource
     * @example
     * // Get one LearningPathResource
     * const learningPathResource = await prisma.learningPathResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningPathResourceFindFirstArgs>(args?: SelectSubset<T, LearningPathResourceFindFirstArgs<ExtArgs>>): Prisma__LearningPathResourceClient<$Result.GetResult<Prisma.$LearningPathResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningPathResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathResourceFindFirstOrThrowArgs} args - Arguments to find a LearningPathResource
     * @example
     * // Get one LearningPathResource
     * const learningPathResource = await prisma.learningPathResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningPathResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningPathResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningPathResourceClient<$Result.GetResult<Prisma.$LearningPathResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LearningPathResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningPathResources
     * const learningPathResources = await prisma.learningPathResource.findMany()
     * 
     * // Get first 10 LearningPathResources
     * const learningPathResources = await prisma.learningPathResource.findMany({ take: 10 })
     * 
     * // Only select the `learningPathId`
     * const learningPathResourceWithLearningPathIdOnly = await prisma.learningPathResource.findMany({ select: { learningPathId: true } })
     * 
     */
    findMany<T extends LearningPathResourceFindManyArgs>(args?: SelectSubset<T, LearningPathResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LearningPathResource.
     * @param {LearningPathResourceCreateArgs} args - Arguments to create a LearningPathResource.
     * @example
     * // Create one LearningPathResource
     * const LearningPathResource = await prisma.learningPathResource.create({
     *   data: {
     *     // ... data to create a LearningPathResource
     *   }
     * })
     * 
     */
    create<T extends LearningPathResourceCreateArgs>(args: SelectSubset<T, LearningPathResourceCreateArgs<ExtArgs>>): Prisma__LearningPathResourceClient<$Result.GetResult<Prisma.$LearningPathResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LearningPathResources.
     * @param {LearningPathResourceCreateManyArgs} args - Arguments to create many LearningPathResources.
     * @example
     * // Create many LearningPathResources
     * const learningPathResource = await prisma.learningPathResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningPathResourceCreateManyArgs>(args?: SelectSubset<T, LearningPathResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningPathResources and returns the data saved in the database.
     * @param {LearningPathResourceCreateManyAndReturnArgs} args - Arguments to create many LearningPathResources.
     * @example
     * // Create many LearningPathResources
     * const learningPathResource = await prisma.learningPathResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningPathResources and only return the `learningPathId`
     * const learningPathResourceWithLearningPathIdOnly = await prisma.learningPathResource.createManyAndReturn({
     *   select: { learningPathId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningPathResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningPathResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LearningPathResource.
     * @param {LearningPathResourceDeleteArgs} args - Arguments to delete one LearningPathResource.
     * @example
     * // Delete one LearningPathResource
     * const LearningPathResource = await prisma.learningPathResource.delete({
     *   where: {
     *     // ... filter to delete one LearningPathResource
     *   }
     * })
     * 
     */
    delete<T extends LearningPathResourceDeleteArgs>(args: SelectSubset<T, LearningPathResourceDeleteArgs<ExtArgs>>): Prisma__LearningPathResourceClient<$Result.GetResult<Prisma.$LearningPathResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LearningPathResource.
     * @param {LearningPathResourceUpdateArgs} args - Arguments to update one LearningPathResource.
     * @example
     * // Update one LearningPathResource
     * const learningPathResource = await prisma.learningPathResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningPathResourceUpdateArgs>(args: SelectSubset<T, LearningPathResourceUpdateArgs<ExtArgs>>): Prisma__LearningPathResourceClient<$Result.GetResult<Prisma.$LearningPathResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LearningPathResources.
     * @param {LearningPathResourceDeleteManyArgs} args - Arguments to filter LearningPathResources to delete.
     * @example
     * // Delete a few LearningPathResources
     * const { count } = await prisma.learningPathResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningPathResourceDeleteManyArgs>(args?: SelectSubset<T, LearningPathResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPathResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningPathResources
     * const learningPathResource = await prisma.learningPathResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningPathResourceUpdateManyArgs>(args: SelectSubset<T, LearningPathResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPathResources and returns the data updated in the database.
     * @param {LearningPathResourceUpdateManyAndReturnArgs} args - Arguments to update many LearningPathResources.
     * @example
     * // Update many LearningPathResources
     * const learningPathResource = await prisma.learningPathResource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningPathResources and only return the `learningPathId`
     * const learningPathResourceWithLearningPathIdOnly = await prisma.learningPathResource.updateManyAndReturn({
     *   select: { learningPathId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningPathResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningPathResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LearningPathResource.
     * @param {LearningPathResourceUpsertArgs} args - Arguments to update or create a LearningPathResource.
     * @example
     * // Update or create a LearningPathResource
     * const learningPathResource = await prisma.learningPathResource.upsert({
     *   create: {
     *     // ... data to create a LearningPathResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningPathResource we want to update
     *   }
     * })
     */
    upsert<T extends LearningPathResourceUpsertArgs>(args: SelectSubset<T, LearningPathResourceUpsertArgs<ExtArgs>>): Prisma__LearningPathResourceClient<$Result.GetResult<Prisma.$LearningPathResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LearningPathResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathResourceCountArgs} args - Arguments to filter LearningPathResources to count.
     * @example
     * // Count the number of LearningPathResources
     * const count = await prisma.learningPathResource.count({
     *   where: {
     *     // ... the filter for the LearningPathResources we want to count
     *   }
     * })
    **/
    count<T extends LearningPathResourceCountArgs>(
      args?: Subset<T, LearningPathResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningPathResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningPathResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningPathResourceAggregateArgs>(args: Subset<T, LearningPathResourceAggregateArgs>): Prisma.PrismaPromise<GetLearningPathResourceAggregateType<T>>

    /**
     * Group by LearningPathResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningPathResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningPathResourceGroupByArgs['orderBy'] }
        : { orderBy?: LearningPathResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningPathResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningPathResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningPathResource model
   */
  readonly fields: LearningPathResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningPathResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningPathResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learningPath<T extends LearningPathDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathDefaultArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningPathResource model
   */
  interface LearningPathResourceFieldRefs {
    readonly learningPathId: FieldRef<"LearningPathResource", 'String'>
    readonly resourceId: FieldRef<"LearningPathResource", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LearningPathResource findUnique
   */
  export type LearningPathResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathResource to fetch.
     */
    where: LearningPathResourceWhereUniqueInput
  }

  /**
   * LearningPathResource findUniqueOrThrow
   */
  export type LearningPathResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathResource to fetch.
     */
    where: LearningPathResourceWhereUniqueInput
  }

  /**
   * LearningPathResource findFirst
   */
  export type LearningPathResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathResource to fetch.
     */
    where?: LearningPathResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathResources to fetch.
     */
    orderBy?: LearningPathResourceOrderByWithRelationInput | LearningPathResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPathResources.
     */
    cursor?: LearningPathResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPathResources.
     */
    distinct?: LearningPathResourceScalarFieldEnum | LearningPathResourceScalarFieldEnum[]
  }

  /**
   * LearningPathResource findFirstOrThrow
   */
  export type LearningPathResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathResource to fetch.
     */
    where?: LearningPathResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathResources to fetch.
     */
    orderBy?: LearningPathResourceOrderByWithRelationInput | LearningPathResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPathResources.
     */
    cursor?: LearningPathResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPathResources.
     */
    distinct?: LearningPathResourceScalarFieldEnum | LearningPathResourceScalarFieldEnum[]
  }

  /**
   * LearningPathResource findMany
   */
  export type LearningPathResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathResources to fetch.
     */
    where?: LearningPathResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathResources to fetch.
     */
    orderBy?: LearningPathResourceOrderByWithRelationInput | LearningPathResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningPathResources.
     */
    cursor?: LearningPathResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathResources.
     */
    skip?: number
    distinct?: LearningPathResourceScalarFieldEnum | LearningPathResourceScalarFieldEnum[]
  }

  /**
   * LearningPathResource create
   */
  export type LearningPathResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningPathResource.
     */
    data: XOR<LearningPathResourceCreateInput, LearningPathResourceUncheckedCreateInput>
  }

  /**
   * LearningPathResource createMany
   */
  export type LearningPathResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningPathResources.
     */
    data: LearningPathResourceCreateManyInput | LearningPathResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningPathResource createManyAndReturn
   */
  export type LearningPathResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * The data used to create many LearningPathResources.
     */
    data: LearningPathResourceCreateManyInput | LearningPathResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPathResource update
   */
  export type LearningPathResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningPathResource.
     */
    data: XOR<LearningPathResourceUpdateInput, LearningPathResourceUncheckedUpdateInput>
    /**
     * Choose, which LearningPathResource to update.
     */
    where: LearningPathResourceWhereUniqueInput
  }

  /**
   * LearningPathResource updateMany
   */
  export type LearningPathResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningPathResources.
     */
    data: XOR<LearningPathResourceUpdateManyMutationInput, LearningPathResourceUncheckedUpdateManyInput>
    /**
     * Filter which LearningPathResources to update
     */
    where?: LearningPathResourceWhereInput
    /**
     * Limit how many LearningPathResources to update.
     */
    limit?: number
  }

  /**
   * LearningPathResource updateManyAndReturn
   */
  export type LearningPathResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * The data used to update LearningPathResources.
     */
    data: XOR<LearningPathResourceUpdateManyMutationInput, LearningPathResourceUncheckedUpdateManyInput>
    /**
     * Filter which LearningPathResources to update
     */
    where?: LearningPathResourceWhereInput
    /**
     * Limit how many LearningPathResources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPathResource upsert
   */
  export type LearningPathResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningPathResource to update in case it exists.
     */
    where: LearningPathResourceWhereUniqueInput
    /**
     * In case the LearningPathResource found by the `where` argument doesn't exist, create a new LearningPathResource with this data.
     */
    create: XOR<LearningPathResourceCreateInput, LearningPathResourceUncheckedCreateInput>
    /**
     * In case the LearningPathResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningPathResourceUpdateInput, LearningPathResourceUncheckedUpdateInput>
  }

  /**
   * LearningPathResource delete
   */
  export type LearningPathResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceInclude<ExtArgs> | null
    /**
     * Filter which LearningPathResource to delete.
     */
    where: LearningPathResourceWhereUniqueInput
  }

  /**
   * LearningPathResource deleteMany
   */
  export type LearningPathResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPathResources to delete
     */
    where?: LearningPathResourceWhereInput
    /**
     * Limit how many LearningPathResources to delete.
     */
    limit?: number
  }

  /**
   * LearningPathResource without action
   */
  export type LearningPathResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathResource
     */
    select?: LearningPathResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathResource
     */
    omit?: LearningPathResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathResourceInclude<ExtArgs> | null
  }


  /**
   * Model CourseResource
   */

  export type AggregateCourseResource = {
    _count: CourseResourceCountAggregateOutputType | null
    _min: CourseResourceMinAggregateOutputType | null
    _max: CourseResourceMaxAggregateOutputType | null
  }

  export type CourseResourceMinAggregateOutputType = {
    courseId: string | null
    resourceId: string | null
  }

  export type CourseResourceMaxAggregateOutputType = {
    courseId: string | null
    resourceId: string | null
  }

  export type CourseResourceCountAggregateOutputType = {
    courseId: number
    resourceId: number
    _all: number
  }


  export type CourseResourceMinAggregateInputType = {
    courseId?: true
    resourceId?: true
  }

  export type CourseResourceMaxAggregateInputType = {
    courseId?: true
    resourceId?: true
  }

  export type CourseResourceCountAggregateInputType = {
    courseId?: true
    resourceId?: true
    _all?: true
  }

  export type CourseResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseResource to aggregate.
     */
    where?: CourseResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseResources to fetch.
     */
    orderBy?: CourseResourceOrderByWithRelationInput | CourseResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseResources
    **/
    _count?: true | CourseResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseResourceMaxAggregateInputType
  }

  export type GetCourseResourceAggregateType<T extends CourseResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseResource[P]>
      : GetScalarType<T[P], AggregateCourseResource[P]>
  }




  export type CourseResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseResourceWhereInput
    orderBy?: CourseResourceOrderByWithAggregationInput | CourseResourceOrderByWithAggregationInput[]
    by: CourseResourceScalarFieldEnum[] | CourseResourceScalarFieldEnum
    having?: CourseResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseResourceCountAggregateInputType | true
    _min?: CourseResourceMinAggregateInputType
    _max?: CourseResourceMaxAggregateInputType
  }

  export type CourseResourceGroupByOutputType = {
    courseId: string
    resourceId: string
    _count: CourseResourceCountAggregateOutputType | null
    _min: CourseResourceMinAggregateOutputType | null
    _max: CourseResourceMaxAggregateOutputType | null
  }

  type GetCourseResourceGroupByPayload<T extends CourseResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseResourceGroupByOutputType[P]>
            : GetScalarType<T[P], CourseResourceGroupByOutputType[P]>
        }
      >
    >


  export type CourseResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    resourceId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseResource"]>

  export type CourseResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    resourceId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseResource"]>

  export type CourseResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    resourceId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseResource"]>

  export type CourseResourceSelectScalar = {
    courseId?: boolean
    resourceId?: boolean
  }

  export type CourseResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"courseId" | "resourceId", ExtArgs["result"]["courseResource"]>
  export type CourseResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type CourseResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type CourseResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $CourseResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseResource"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      resource: Prisma.$ResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      courseId: string
      resourceId: string
    }, ExtArgs["result"]["courseResource"]>
    composites: {}
  }

  type CourseResourceGetPayload<S extends boolean | null | undefined | CourseResourceDefaultArgs> = $Result.GetResult<Prisma.$CourseResourcePayload, S>

  type CourseResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseResourceCountAggregateInputType | true
    }

  export interface CourseResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseResource'], meta: { name: 'CourseResource' } }
    /**
     * Find zero or one CourseResource that matches the filter.
     * @param {CourseResourceFindUniqueArgs} args - Arguments to find a CourseResource
     * @example
     * // Get one CourseResource
     * const courseResource = await prisma.courseResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseResourceFindUniqueArgs>(args: SelectSubset<T, CourseResourceFindUniqueArgs<ExtArgs>>): Prisma__CourseResourceClient<$Result.GetResult<Prisma.$CourseResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseResource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseResourceFindUniqueOrThrowArgs} args - Arguments to find a CourseResource
     * @example
     * // Get one CourseResource
     * const courseResource = await prisma.courseResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseResourceClient<$Result.GetResult<Prisma.$CourseResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseResourceFindFirstArgs} args - Arguments to find a CourseResource
     * @example
     * // Get one CourseResource
     * const courseResource = await prisma.courseResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseResourceFindFirstArgs>(args?: SelectSubset<T, CourseResourceFindFirstArgs<ExtArgs>>): Prisma__CourseResourceClient<$Result.GetResult<Prisma.$CourseResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseResourceFindFirstOrThrowArgs} args - Arguments to find a CourseResource
     * @example
     * // Get one CourseResource
     * const courseResource = await prisma.courseResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseResourceClient<$Result.GetResult<Prisma.$CourseResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseResources
     * const courseResources = await prisma.courseResource.findMany()
     * 
     * // Get first 10 CourseResources
     * const courseResources = await prisma.courseResource.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const courseResourceWithCourseIdOnly = await prisma.courseResource.findMany({ select: { courseId: true } })
     * 
     */
    findMany<T extends CourseResourceFindManyArgs>(args?: SelectSubset<T, CourseResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseResource.
     * @param {CourseResourceCreateArgs} args - Arguments to create a CourseResource.
     * @example
     * // Create one CourseResource
     * const CourseResource = await prisma.courseResource.create({
     *   data: {
     *     // ... data to create a CourseResource
     *   }
     * })
     * 
     */
    create<T extends CourseResourceCreateArgs>(args: SelectSubset<T, CourseResourceCreateArgs<ExtArgs>>): Prisma__CourseResourceClient<$Result.GetResult<Prisma.$CourseResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseResources.
     * @param {CourseResourceCreateManyArgs} args - Arguments to create many CourseResources.
     * @example
     * // Create many CourseResources
     * const courseResource = await prisma.courseResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseResourceCreateManyArgs>(args?: SelectSubset<T, CourseResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseResources and returns the data saved in the database.
     * @param {CourseResourceCreateManyAndReturnArgs} args - Arguments to create many CourseResources.
     * @example
     * // Create many CourseResources
     * const courseResource = await prisma.courseResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseResources and only return the `courseId`
     * const courseResourceWithCourseIdOnly = await prisma.courseResource.createManyAndReturn({
     *   select: { courseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseResource.
     * @param {CourseResourceDeleteArgs} args - Arguments to delete one CourseResource.
     * @example
     * // Delete one CourseResource
     * const CourseResource = await prisma.courseResource.delete({
     *   where: {
     *     // ... filter to delete one CourseResource
     *   }
     * })
     * 
     */
    delete<T extends CourseResourceDeleteArgs>(args: SelectSubset<T, CourseResourceDeleteArgs<ExtArgs>>): Prisma__CourseResourceClient<$Result.GetResult<Prisma.$CourseResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseResource.
     * @param {CourseResourceUpdateArgs} args - Arguments to update one CourseResource.
     * @example
     * // Update one CourseResource
     * const courseResource = await prisma.courseResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseResourceUpdateArgs>(args: SelectSubset<T, CourseResourceUpdateArgs<ExtArgs>>): Prisma__CourseResourceClient<$Result.GetResult<Prisma.$CourseResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseResources.
     * @param {CourseResourceDeleteManyArgs} args - Arguments to filter CourseResources to delete.
     * @example
     * // Delete a few CourseResources
     * const { count } = await prisma.courseResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseResourceDeleteManyArgs>(args?: SelectSubset<T, CourseResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseResources
     * const courseResource = await prisma.courseResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseResourceUpdateManyArgs>(args: SelectSubset<T, CourseResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseResources and returns the data updated in the database.
     * @param {CourseResourceUpdateManyAndReturnArgs} args - Arguments to update many CourseResources.
     * @example
     * // Update many CourseResources
     * const courseResource = await prisma.courseResource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseResources and only return the `courseId`
     * const courseResourceWithCourseIdOnly = await prisma.courseResource.updateManyAndReturn({
     *   select: { courseId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseResource.
     * @param {CourseResourceUpsertArgs} args - Arguments to update or create a CourseResource.
     * @example
     * // Update or create a CourseResource
     * const courseResource = await prisma.courseResource.upsert({
     *   create: {
     *     // ... data to create a CourseResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseResource we want to update
     *   }
     * })
     */
    upsert<T extends CourseResourceUpsertArgs>(args: SelectSubset<T, CourseResourceUpsertArgs<ExtArgs>>): Prisma__CourseResourceClient<$Result.GetResult<Prisma.$CourseResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseResourceCountArgs} args - Arguments to filter CourseResources to count.
     * @example
     * // Count the number of CourseResources
     * const count = await prisma.courseResource.count({
     *   where: {
     *     // ... the filter for the CourseResources we want to count
     *   }
     * })
    **/
    count<T extends CourseResourceCountArgs>(
      args?: Subset<T, CourseResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseResourceAggregateArgs>(args: Subset<T, CourseResourceAggregateArgs>): Prisma.PrismaPromise<GetCourseResourceAggregateType<T>>

    /**
     * Group by CourseResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseResourceGroupByArgs['orderBy'] }
        : { orderBy?: CourseResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseResource model
   */
  readonly fields: CourseResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseResource model
   */
  interface CourseResourceFieldRefs {
    readonly courseId: FieldRef<"CourseResource", 'String'>
    readonly resourceId: FieldRef<"CourseResource", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseResource findUnique
   */
  export type CourseResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceInclude<ExtArgs> | null
    /**
     * Filter, which CourseResource to fetch.
     */
    where: CourseResourceWhereUniqueInput
  }

  /**
   * CourseResource findUniqueOrThrow
   */
  export type CourseResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceInclude<ExtArgs> | null
    /**
     * Filter, which CourseResource to fetch.
     */
    where: CourseResourceWhereUniqueInput
  }

  /**
   * CourseResource findFirst
   */
  export type CourseResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceInclude<ExtArgs> | null
    /**
     * Filter, which CourseResource to fetch.
     */
    where?: CourseResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseResources to fetch.
     */
    orderBy?: CourseResourceOrderByWithRelationInput | CourseResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseResources.
     */
    cursor?: CourseResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseResources.
     */
    distinct?: CourseResourceScalarFieldEnum | CourseResourceScalarFieldEnum[]
  }

  /**
   * CourseResource findFirstOrThrow
   */
  export type CourseResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceInclude<ExtArgs> | null
    /**
     * Filter, which CourseResource to fetch.
     */
    where?: CourseResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseResources to fetch.
     */
    orderBy?: CourseResourceOrderByWithRelationInput | CourseResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseResources.
     */
    cursor?: CourseResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseResources.
     */
    distinct?: CourseResourceScalarFieldEnum | CourseResourceScalarFieldEnum[]
  }

  /**
   * CourseResource findMany
   */
  export type CourseResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceInclude<ExtArgs> | null
    /**
     * Filter, which CourseResources to fetch.
     */
    where?: CourseResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseResources to fetch.
     */
    orderBy?: CourseResourceOrderByWithRelationInput | CourseResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseResources.
     */
    cursor?: CourseResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseResources.
     */
    skip?: number
    distinct?: CourseResourceScalarFieldEnum | CourseResourceScalarFieldEnum[]
  }

  /**
   * CourseResource create
   */
  export type CourseResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseResource.
     */
    data: XOR<CourseResourceCreateInput, CourseResourceUncheckedCreateInput>
  }

  /**
   * CourseResource createMany
   */
  export type CourseResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseResources.
     */
    data: CourseResourceCreateManyInput | CourseResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseResource createManyAndReturn
   */
  export type CourseResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * The data used to create many CourseResources.
     */
    data: CourseResourceCreateManyInput | CourseResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseResource update
   */
  export type CourseResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseResource.
     */
    data: XOR<CourseResourceUpdateInput, CourseResourceUncheckedUpdateInput>
    /**
     * Choose, which CourseResource to update.
     */
    where: CourseResourceWhereUniqueInput
  }

  /**
   * CourseResource updateMany
   */
  export type CourseResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseResources.
     */
    data: XOR<CourseResourceUpdateManyMutationInput, CourseResourceUncheckedUpdateManyInput>
    /**
     * Filter which CourseResources to update
     */
    where?: CourseResourceWhereInput
    /**
     * Limit how many CourseResources to update.
     */
    limit?: number
  }

  /**
   * CourseResource updateManyAndReturn
   */
  export type CourseResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * The data used to update CourseResources.
     */
    data: XOR<CourseResourceUpdateManyMutationInput, CourseResourceUncheckedUpdateManyInput>
    /**
     * Filter which CourseResources to update
     */
    where?: CourseResourceWhereInput
    /**
     * Limit how many CourseResources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseResource upsert
   */
  export type CourseResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseResource to update in case it exists.
     */
    where: CourseResourceWhereUniqueInput
    /**
     * In case the CourseResource found by the `where` argument doesn't exist, create a new CourseResource with this data.
     */
    create: XOR<CourseResourceCreateInput, CourseResourceUncheckedCreateInput>
    /**
     * In case the CourseResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseResourceUpdateInput, CourseResourceUncheckedUpdateInput>
  }

  /**
   * CourseResource delete
   */
  export type CourseResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceInclude<ExtArgs> | null
    /**
     * Filter which CourseResource to delete.
     */
    where: CourseResourceWhereUniqueInput
  }

  /**
   * CourseResource deleteMany
   */
  export type CourseResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseResources to delete
     */
    where?: CourseResourceWhereInput
    /**
     * Limit how many CourseResources to delete.
     */
    limit?: number
  }

  /**
   * CourseResource without action
   */
  export type CourseResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseResource
     */
    select?: CourseResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseResource
     */
    omit?: CourseResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseResourceInclude<ExtArgs> | null
  }


  /**
   * Model LessonResource
   */

  export type AggregateLessonResource = {
    _count: LessonResourceCountAggregateOutputType | null
    _min: LessonResourceMinAggregateOutputType | null
    _max: LessonResourceMaxAggregateOutputType | null
  }

  export type LessonResourceMinAggregateOutputType = {
    lessonId: string | null
    resourceId: string | null
  }

  export type LessonResourceMaxAggregateOutputType = {
    lessonId: string | null
    resourceId: string | null
  }

  export type LessonResourceCountAggregateOutputType = {
    lessonId: number
    resourceId: number
    _all: number
  }


  export type LessonResourceMinAggregateInputType = {
    lessonId?: true
    resourceId?: true
  }

  export type LessonResourceMaxAggregateInputType = {
    lessonId?: true
    resourceId?: true
  }

  export type LessonResourceCountAggregateInputType = {
    lessonId?: true
    resourceId?: true
    _all?: true
  }

  export type LessonResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonResource to aggregate.
     */
    where?: LessonResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonResources to fetch.
     */
    orderBy?: LessonResourceOrderByWithRelationInput | LessonResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonResources
    **/
    _count?: true | LessonResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonResourceMaxAggregateInputType
  }

  export type GetLessonResourceAggregateType<T extends LessonResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonResource[P]>
      : GetScalarType<T[P], AggregateLessonResource[P]>
  }




  export type LessonResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonResourceWhereInput
    orderBy?: LessonResourceOrderByWithAggregationInput | LessonResourceOrderByWithAggregationInput[]
    by: LessonResourceScalarFieldEnum[] | LessonResourceScalarFieldEnum
    having?: LessonResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonResourceCountAggregateInputType | true
    _min?: LessonResourceMinAggregateInputType
    _max?: LessonResourceMaxAggregateInputType
  }

  export type LessonResourceGroupByOutputType = {
    lessonId: string
    resourceId: string
    _count: LessonResourceCountAggregateOutputType | null
    _min: LessonResourceMinAggregateOutputType | null
    _max: LessonResourceMaxAggregateOutputType | null
  }

  type GetLessonResourceGroupByPayload<T extends LessonResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonResourceGroupByOutputType[P]>
            : GetScalarType<T[P], LessonResourceGroupByOutputType[P]>
        }
      >
    >


  export type LessonResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lessonId?: boolean
    resourceId?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonResource"]>

  export type LessonResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lessonId?: boolean
    resourceId?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonResource"]>

  export type LessonResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lessonId?: boolean
    resourceId?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonResource"]>

  export type LessonResourceSelectScalar = {
    lessonId?: boolean
    resourceId?: boolean
  }

  export type LessonResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"lessonId" | "resourceId", ExtArgs["result"]["lessonResource"]>
  export type LessonResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type LessonResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type LessonResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $LessonResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonResource"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      resource: Prisma.$ResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      lessonId: string
      resourceId: string
    }, ExtArgs["result"]["lessonResource"]>
    composites: {}
  }

  type LessonResourceGetPayload<S extends boolean | null | undefined | LessonResourceDefaultArgs> = $Result.GetResult<Prisma.$LessonResourcePayload, S>

  type LessonResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonResourceCountAggregateInputType | true
    }

  export interface LessonResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonResource'], meta: { name: 'LessonResource' } }
    /**
     * Find zero or one LessonResource that matches the filter.
     * @param {LessonResourceFindUniqueArgs} args - Arguments to find a LessonResource
     * @example
     * // Get one LessonResource
     * const lessonResource = await prisma.lessonResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonResourceFindUniqueArgs>(args: SelectSubset<T, LessonResourceFindUniqueArgs<ExtArgs>>): Prisma__LessonResourceClient<$Result.GetResult<Prisma.$LessonResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LessonResource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonResourceFindUniqueOrThrowArgs} args - Arguments to find a LessonResource
     * @example
     * // Get one LessonResource
     * const lessonResource = await prisma.lessonResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonResourceClient<$Result.GetResult<Prisma.$LessonResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonResourceFindFirstArgs} args - Arguments to find a LessonResource
     * @example
     * // Get one LessonResource
     * const lessonResource = await prisma.lessonResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonResourceFindFirstArgs>(args?: SelectSubset<T, LessonResourceFindFirstArgs<ExtArgs>>): Prisma__LessonResourceClient<$Result.GetResult<Prisma.$LessonResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonResourceFindFirstOrThrowArgs} args - Arguments to find a LessonResource
     * @example
     * // Get one LessonResource
     * const lessonResource = await prisma.lessonResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonResourceClient<$Result.GetResult<Prisma.$LessonResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LessonResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonResources
     * const lessonResources = await prisma.lessonResource.findMany()
     * 
     * // Get first 10 LessonResources
     * const lessonResources = await prisma.lessonResource.findMany({ take: 10 })
     * 
     * // Only select the `lessonId`
     * const lessonResourceWithLessonIdOnly = await prisma.lessonResource.findMany({ select: { lessonId: true } })
     * 
     */
    findMany<T extends LessonResourceFindManyArgs>(args?: SelectSubset<T, LessonResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LessonResource.
     * @param {LessonResourceCreateArgs} args - Arguments to create a LessonResource.
     * @example
     * // Create one LessonResource
     * const LessonResource = await prisma.lessonResource.create({
     *   data: {
     *     // ... data to create a LessonResource
     *   }
     * })
     * 
     */
    create<T extends LessonResourceCreateArgs>(args: SelectSubset<T, LessonResourceCreateArgs<ExtArgs>>): Prisma__LessonResourceClient<$Result.GetResult<Prisma.$LessonResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LessonResources.
     * @param {LessonResourceCreateManyArgs} args - Arguments to create many LessonResources.
     * @example
     * // Create many LessonResources
     * const lessonResource = await prisma.lessonResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonResourceCreateManyArgs>(args?: SelectSubset<T, LessonResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonResources and returns the data saved in the database.
     * @param {LessonResourceCreateManyAndReturnArgs} args - Arguments to create many LessonResources.
     * @example
     * // Create many LessonResources
     * const lessonResource = await prisma.lessonResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonResources and only return the `lessonId`
     * const lessonResourceWithLessonIdOnly = await prisma.lessonResource.createManyAndReturn({
     *   select: { lessonId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LessonResource.
     * @param {LessonResourceDeleteArgs} args - Arguments to delete one LessonResource.
     * @example
     * // Delete one LessonResource
     * const LessonResource = await prisma.lessonResource.delete({
     *   where: {
     *     // ... filter to delete one LessonResource
     *   }
     * })
     * 
     */
    delete<T extends LessonResourceDeleteArgs>(args: SelectSubset<T, LessonResourceDeleteArgs<ExtArgs>>): Prisma__LessonResourceClient<$Result.GetResult<Prisma.$LessonResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LessonResource.
     * @param {LessonResourceUpdateArgs} args - Arguments to update one LessonResource.
     * @example
     * // Update one LessonResource
     * const lessonResource = await prisma.lessonResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonResourceUpdateArgs>(args: SelectSubset<T, LessonResourceUpdateArgs<ExtArgs>>): Prisma__LessonResourceClient<$Result.GetResult<Prisma.$LessonResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LessonResources.
     * @param {LessonResourceDeleteManyArgs} args - Arguments to filter LessonResources to delete.
     * @example
     * // Delete a few LessonResources
     * const { count } = await prisma.lessonResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonResourceDeleteManyArgs>(args?: SelectSubset<T, LessonResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonResources
     * const lessonResource = await prisma.lessonResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonResourceUpdateManyArgs>(args: SelectSubset<T, LessonResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonResources and returns the data updated in the database.
     * @param {LessonResourceUpdateManyAndReturnArgs} args - Arguments to update many LessonResources.
     * @example
     * // Update many LessonResources
     * const lessonResource = await prisma.lessonResource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonResources and only return the `lessonId`
     * const lessonResourceWithLessonIdOnly = await prisma.lessonResource.updateManyAndReturn({
     *   select: { lessonId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LessonResource.
     * @param {LessonResourceUpsertArgs} args - Arguments to update or create a LessonResource.
     * @example
     * // Update or create a LessonResource
     * const lessonResource = await prisma.lessonResource.upsert({
     *   create: {
     *     // ... data to create a LessonResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonResource we want to update
     *   }
     * })
     */
    upsert<T extends LessonResourceUpsertArgs>(args: SelectSubset<T, LessonResourceUpsertArgs<ExtArgs>>): Prisma__LessonResourceClient<$Result.GetResult<Prisma.$LessonResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LessonResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonResourceCountArgs} args - Arguments to filter LessonResources to count.
     * @example
     * // Count the number of LessonResources
     * const count = await prisma.lessonResource.count({
     *   where: {
     *     // ... the filter for the LessonResources we want to count
     *   }
     * })
    **/
    count<T extends LessonResourceCountArgs>(
      args?: Subset<T, LessonResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonResourceAggregateArgs>(args: Subset<T, LessonResourceAggregateArgs>): Prisma.PrismaPromise<GetLessonResourceAggregateType<T>>

    /**
     * Group by LessonResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonResourceGroupByArgs['orderBy'] }
        : { orderBy?: LessonResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonResource model
   */
  readonly fields: LessonResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonResource model
   */
  interface LessonResourceFieldRefs {
    readonly lessonId: FieldRef<"LessonResource", 'String'>
    readonly resourceId: FieldRef<"LessonResource", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LessonResource findUnique
   */
  export type LessonResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceInclude<ExtArgs> | null
    /**
     * Filter, which LessonResource to fetch.
     */
    where: LessonResourceWhereUniqueInput
  }

  /**
   * LessonResource findUniqueOrThrow
   */
  export type LessonResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceInclude<ExtArgs> | null
    /**
     * Filter, which LessonResource to fetch.
     */
    where: LessonResourceWhereUniqueInput
  }

  /**
   * LessonResource findFirst
   */
  export type LessonResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceInclude<ExtArgs> | null
    /**
     * Filter, which LessonResource to fetch.
     */
    where?: LessonResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonResources to fetch.
     */
    orderBy?: LessonResourceOrderByWithRelationInput | LessonResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonResources.
     */
    cursor?: LessonResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonResources.
     */
    distinct?: LessonResourceScalarFieldEnum | LessonResourceScalarFieldEnum[]
  }

  /**
   * LessonResource findFirstOrThrow
   */
  export type LessonResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceInclude<ExtArgs> | null
    /**
     * Filter, which LessonResource to fetch.
     */
    where?: LessonResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonResources to fetch.
     */
    orderBy?: LessonResourceOrderByWithRelationInput | LessonResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonResources.
     */
    cursor?: LessonResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonResources.
     */
    distinct?: LessonResourceScalarFieldEnum | LessonResourceScalarFieldEnum[]
  }

  /**
   * LessonResource findMany
   */
  export type LessonResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceInclude<ExtArgs> | null
    /**
     * Filter, which LessonResources to fetch.
     */
    where?: LessonResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonResources to fetch.
     */
    orderBy?: LessonResourceOrderByWithRelationInput | LessonResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonResources.
     */
    cursor?: LessonResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonResources.
     */
    skip?: number
    distinct?: LessonResourceScalarFieldEnum | LessonResourceScalarFieldEnum[]
  }

  /**
   * LessonResource create
   */
  export type LessonResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonResource.
     */
    data: XOR<LessonResourceCreateInput, LessonResourceUncheckedCreateInput>
  }

  /**
   * LessonResource createMany
   */
  export type LessonResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonResources.
     */
    data: LessonResourceCreateManyInput | LessonResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonResource createManyAndReturn
   */
  export type LessonResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * The data used to create many LessonResources.
     */
    data: LessonResourceCreateManyInput | LessonResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonResource update
   */
  export type LessonResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonResource.
     */
    data: XOR<LessonResourceUpdateInput, LessonResourceUncheckedUpdateInput>
    /**
     * Choose, which LessonResource to update.
     */
    where: LessonResourceWhereUniqueInput
  }

  /**
   * LessonResource updateMany
   */
  export type LessonResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonResources.
     */
    data: XOR<LessonResourceUpdateManyMutationInput, LessonResourceUncheckedUpdateManyInput>
    /**
     * Filter which LessonResources to update
     */
    where?: LessonResourceWhereInput
    /**
     * Limit how many LessonResources to update.
     */
    limit?: number
  }

  /**
   * LessonResource updateManyAndReturn
   */
  export type LessonResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * The data used to update LessonResources.
     */
    data: XOR<LessonResourceUpdateManyMutationInput, LessonResourceUncheckedUpdateManyInput>
    /**
     * Filter which LessonResources to update
     */
    where?: LessonResourceWhereInput
    /**
     * Limit how many LessonResources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonResource upsert
   */
  export type LessonResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonResource to update in case it exists.
     */
    where: LessonResourceWhereUniqueInput
    /**
     * In case the LessonResource found by the `where` argument doesn't exist, create a new LessonResource with this data.
     */
    create: XOR<LessonResourceCreateInput, LessonResourceUncheckedCreateInput>
    /**
     * In case the LessonResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonResourceUpdateInput, LessonResourceUncheckedUpdateInput>
  }

  /**
   * LessonResource delete
   */
  export type LessonResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceInclude<ExtArgs> | null
    /**
     * Filter which LessonResource to delete.
     */
    where: LessonResourceWhereUniqueInput
  }

  /**
   * LessonResource deleteMany
   */
  export type LessonResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonResources to delete
     */
    where?: LessonResourceWhereInput
    /**
     * Limit how many LessonResources to delete.
     */
    limit?: number
  }

  /**
   * LessonResource without action
   */
  export type LessonResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonResource
     */
    select?: LessonResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonResource
     */
    omit?: LessonResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonResourceInclude<ExtArgs> | null
  }


  /**
   * Model WorkshopResource
   */

  export type AggregateWorkshopResource = {
    _count: WorkshopResourceCountAggregateOutputType | null
    _min: WorkshopResourceMinAggregateOutputType | null
    _max: WorkshopResourceMaxAggregateOutputType | null
  }

  export type WorkshopResourceMinAggregateOutputType = {
    workshopId: string | null
    resourceId: string | null
  }

  export type WorkshopResourceMaxAggregateOutputType = {
    workshopId: string | null
    resourceId: string | null
  }

  export type WorkshopResourceCountAggregateOutputType = {
    workshopId: number
    resourceId: number
    _all: number
  }


  export type WorkshopResourceMinAggregateInputType = {
    workshopId?: true
    resourceId?: true
  }

  export type WorkshopResourceMaxAggregateInputType = {
    workshopId?: true
    resourceId?: true
  }

  export type WorkshopResourceCountAggregateInputType = {
    workshopId?: true
    resourceId?: true
    _all?: true
  }

  export type WorkshopResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopResource to aggregate.
     */
    where?: WorkshopResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopResources to fetch.
     */
    orderBy?: WorkshopResourceOrderByWithRelationInput | WorkshopResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkshopResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkshopResources
    **/
    _count?: true | WorkshopResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkshopResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkshopResourceMaxAggregateInputType
  }

  export type GetWorkshopResourceAggregateType<T extends WorkshopResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkshopResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkshopResource[P]>
      : GetScalarType<T[P], AggregateWorkshopResource[P]>
  }




  export type WorkshopResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopResourceWhereInput
    orderBy?: WorkshopResourceOrderByWithAggregationInput | WorkshopResourceOrderByWithAggregationInput[]
    by: WorkshopResourceScalarFieldEnum[] | WorkshopResourceScalarFieldEnum
    having?: WorkshopResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkshopResourceCountAggregateInputType | true
    _min?: WorkshopResourceMinAggregateInputType
    _max?: WorkshopResourceMaxAggregateInputType
  }

  export type WorkshopResourceGroupByOutputType = {
    workshopId: string
    resourceId: string
    _count: WorkshopResourceCountAggregateOutputType | null
    _min: WorkshopResourceMinAggregateOutputType | null
    _max: WorkshopResourceMaxAggregateOutputType | null
  }

  type GetWorkshopResourceGroupByPayload<T extends WorkshopResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkshopResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkshopResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkshopResourceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkshopResourceGroupByOutputType[P]>
        }
      >
    >


  export type WorkshopResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workshopId?: boolean
    resourceId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopResource"]>

  export type WorkshopResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workshopId?: boolean
    resourceId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopResource"]>

  export type WorkshopResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workshopId?: boolean
    resourceId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopResource"]>

  export type WorkshopResourceSelectScalar = {
    workshopId?: boolean
    resourceId?: boolean
  }

  export type WorkshopResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workshopId" | "resourceId", ExtArgs["result"]["workshopResource"]>
  export type WorkshopResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type WorkshopResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type WorkshopResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $WorkshopResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkshopResource"
    objects: {
      workshop: Prisma.$WorkshopPayload<ExtArgs>
      resource: Prisma.$ResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workshopId: string
      resourceId: string
    }, ExtArgs["result"]["workshopResource"]>
    composites: {}
  }

  type WorkshopResourceGetPayload<S extends boolean | null | undefined | WorkshopResourceDefaultArgs> = $Result.GetResult<Prisma.$WorkshopResourcePayload, S>

  type WorkshopResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkshopResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkshopResourceCountAggregateInputType | true
    }

  export interface WorkshopResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkshopResource'], meta: { name: 'WorkshopResource' } }
    /**
     * Find zero or one WorkshopResource that matches the filter.
     * @param {WorkshopResourceFindUniqueArgs} args - Arguments to find a WorkshopResource
     * @example
     * // Get one WorkshopResource
     * const workshopResource = await prisma.workshopResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkshopResourceFindUniqueArgs>(args: SelectSubset<T, WorkshopResourceFindUniqueArgs<ExtArgs>>): Prisma__WorkshopResourceClient<$Result.GetResult<Prisma.$WorkshopResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkshopResource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkshopResourceFindUniqueOrThrowArgs} args - Arguments to find a WorkshopResource
     * @example
     * // Get one WorkshopResource
     * const workshopResource = await prisma.workshopResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkshopResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkshopResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkshopResourceClient<$Result.GetResult<Prisma.$WorkshopResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopResourceFindFirstArgs} args - Arguments to find a WorkshopResource
     * @example
     * // Get one WorkshopResource
     * const workshopResource = await prisma.workshopResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkshopResourceFindFirstArgs>(args?: SelectSubset<T, WorkshopResourceFindFirstArgs<ExtArgs>>): Prisma__WorkshopResourceClient<$Result.GetResult<Prisma.$WorkshopResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopResourceFindFirstOrThrowArgs} args - Arguments to find a WorkshopResource
     * @example
     * // Get one WorkshopResource
     * const workshopResource = await prisma.workshopResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkshopResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkshopResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkshopResourceClient<$Result.GetResult<Prisma.$WorkshopResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkshopResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkshopResources
     * const workshopResources = await prisma.workshopResource.findMany()
     * 
     * // Get first 10 WorkshopResources
     * const workshopResources = await prisma.workshopResource.findMany({ take: 10 })
     * 
     * // Only select the `workshopId`
     * const workshopResourceWithWorkshopIdOnly = await prisma.workshopResource.findMany({ select: { workshopId: true } })
     * 
     */
    findMany<T extends WorkshopResourceFindManyArgs>(args?: SelectSubset<T, WorkshopResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkshopResource.
     * @param {WorkshopResourceCreateArgs} args - Arguments to create a WorkshopResource.
     * @example
     * // Create one WorkshopResource
     * const WorkshopResource = await prisma.workshopResource.create({
     *   data: {
     *     // ... data to create a WorkshopResource
     *   }
     * })
     * 
     */
    create<T extends WorkshopResourceCreateArgs>(args: SelectSubset<T, WorkshopResourceCreateArgs<ExtArgs>>): Prisma__WorkshopResourceClient<$Result.GetResult<Prisma.$WorkshopResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkshopResources.
     * @param {WorkshopResourceCreateManyArgs} args - Arguments to create many WorkshopResources.
     * @example
     * // Create many WorkshopResources
     * const workshopResource = await prisma.workshopResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkshopResourceCreateManyArgs>(args?: SelectSubset<T, WorkshopResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkshopResources and returns the data saved in the database.
     * @param {WorkshopResourceCreateManyAndReturnArgs} args - Arguments to create many WorkshopResources.
     * @example
     * // Create many WorkshopResources
     * const workshopResource = await prisma.workshopResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkshopResources and only return the `workshopId`
     * const workshopResourceWithWorkshopIdOnly = await prisma.workshopResource.createManyAndReturn({
     *   select: { workshopId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkshopResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkshopResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkshopResource.
     * @param {WorkshopResourceDeleteArgs} args - Arguments to delete one WorkshopResource.
     * @example
     * // Delete one WorkshopResource
     * const WorkshopResource = await prisma.workshopResource.delete({
     *   where: {
     *     // ... filter to delete one WorkshopResource
     *   }
     * })
     * 
     */
    delete<T extends WorkshopResourceDeleteArgs>(args: SelectSubset<T, WorkshopResourceDeleteArgs<ExtArgs>>): Prisma__WorkshopResourceClient<$Result.GetResult<Prisma.$WorkshopResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkshopResource.
     * @param {WorkshopResourceUpdateArgs} args - Arguments to update one WorkshopResource.
     * @example
     * // Update one WorkshopResource
     * const workshopResource = await prisma.workshopResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkshopResourceUpdateArgs>(args: SelectSubset<T, WorkshopResourceUpdateArgs<ExtArgs>>): Prisma__WorkshopResourceClient<$Result.GetResult<Prisma.$WorkshopResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkshopResources.
     * @param {WorkshopResourceDeleteManyArgs} args - Arguments to filter WorkshopResources to delete.
     * @example
     * // Delete a few WorkshopResources
     * const { count } = await prisma.workshopResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkshopResourceDeleteManyArgs>(args?: SelectSubset<T, WorkshopResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkshopResources
     * const workshopResource = await prisma.workshopResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkshopResourceUpdateManyArgs>(args: SelectSubset<T, WorkshopResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopResources and returns the data updated in the database.
     * @param {WorkshopResourceUpdateManyAndReturnArgs} args - Arguments to update many WorkshopResources.
     * @example
     * // Update many WorkshopResources
     * const workshopResource = await prisma.workshopResource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkshopResources and only return the `workshopId`
     * const workshopResourceWithWorkshopIdOnly = await prisma.workshopResource.updateManyAndReturn({
     *   select: { workshopId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkshopResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkshopResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkshopResource.
     * @param {WorkshopResourceUpsertArgs} args - Arguments to update or create a WorkshopResource.
     * @example
     * // Update or create a WorkshopResource
     * const workshopResource = await prisma.workshopResource.upsert({
     *   create: {
     *     // ... data to create a WorkshopResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkshopResource we want to update
     *   }
     * })
     */
    upsert<T extends WorkshopResourceUpsertArgs>(args: SelectSubset<T, WorkshopResourceUpsertArgs<ExtArgs>>): Prisma__WorkshopResourceClient<$Result.GetResult<Prisma.$WorkshopResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkshopResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopResourceCountArgs} args - Arguments to filter WorkshopResources to count.
     * @example
     * // Count the number of WorkshopResources
     * const count = await prisma.workshopResource.count({
     *   where: {
     *     // ... the filter for the WorkshopResources we want to count
     *   }
     * })
    **/
    count<T extends WorkshopResourceCountArgs>(
      args?: Subset<T, WorkshopResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkshopResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkshopResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkshopResourceAggregateArgs>(args: Subset<T, WorkshopResourceAggregateArgs>): Prisma.PrismaPromise<GetWorkshopResourceAggregateType<T>>

    /**
     * Group by WorkshopResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkshopResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkshopResourceGroupByArgs['orderBy'] }
        : { orderBy?: WorkshopResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkshopResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkshopResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkshopResource model
   */
  readonly fields: WorkshopResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkshopResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkshopResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workshop<T extends WorkshopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkshopDefaultArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkshopResource model
   */
  interface WorkshopResourceFieldRefs {
    readonly workshopId: FieldRef<"WorkshopResource", 'String'>
    readonly resourceId: FieldRef<"WorkshopResource", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkshopResource findUnique
   */
  export type WorkshopResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopResource to fetch.
     */
    where: WorkshopResourceWhereUniqueInput
  }

  /**
   * WorkshopResource findUniqueOrThrow
   */
  export type WorkshopResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopResource to fetch.
     */
    where: WorkshopResourceWhereUniqueInput
  }

  /**
   * WorkshopResource findFirst
   */
  export type WorkshopResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopResource to fetch.
     */
    where?: WorkshopResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopResources to fetch.
     */
    orderBy?: WorkshopResourceOrderByWithRelationInput | WorkshopResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopResources.
     */
    cursor?: WorkshopResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopResources.
     */
    distinct?: WorkshopResourceScalarFieldEnum | WorkshopResourceScalarFieldEnum[]
  }

  /**
   * WorkshopResource findFirstOrThrow
   */
  export type WorkshopResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopResource to fetch.
     */
    where?: WorkshopResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopResources to fetch.
     */
    orderBy?: WorkshopResourceOrderByWithRelationInput | WorkshopResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopResources.
     */
    cursor?: WorkshopResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopResources.
     */
    distinct?: WorkshopResourceScalarFieldEnum | WorkshopResourceScalarFieldEnum[]
  }

  /**
   * WorkshopResource findMany
   */
  export type WorkshopResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopResources to fetch.
     */
    where?: WorkshopResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopResources to fetch.
     */
    orderBy?: WorkshopResourceOrderByWithRelationInput | WorkshopResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkshopResources.
     */
    cursor?: WorkshopResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopResources.
     */
    skip?: number
    distinct?: WorkshopResourceScalarFieldEnum | WorkshopResourceScalarFieldEnum[]
  }

  /**
   * WorkshopResource create
   */
  export type WorkshopResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkshopResource.
     */
    data: XOR<WorkshopResourceCreateInput, WorkshopResourceUncheckedCreateInput>
  }

  /**
   * WorkshopResource createMany
   */
  export type WorkshopResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkshopResources.
     */
    data: WorkshopResourceCreateManyInput | WorkshopResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkshopResource createManyAndReturn
   */
  export type WorkshopResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * The data used to create many WorkshopResources.
     */
    data: WorkshopResourceCreateManyInput | WorkshopResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopResource update
   */
  export type WorkshopResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkshopResource.
     */
    data: XOR<WorkshopResourceUpdateInput, WorkshopResourceUncheckedUpdateInput>
    /**
     * Choose, which WorkshopResource to update.
     */
    where: WorkshopResourceWhereUniqueInput
  }

  /**
   * WorkshopResource updateMany
   */
  export type WorkshopResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkshopResources.
     */
    data: XOR<WorkshopResourceUpdateManyMutationInput, WorkshopResourceUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopResources to update
     */
    where?: WorkshopResourceWhereInput
    /**
     * Limit how many WorkshopResources to update.
     */
    limit?: number
  }

  /**
   * WorkshopResource updateManyAndReturn
   */
  export type WorkshopResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * The data used to update WorkshopResources.
     */
    data: XOR<WorkshopResourceUpdateManyMutationInput, WorkshopResourceUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopResources to update
     */
    where?: WorkshopResourceWhereInput
    /**
     * Limit how many WorkshopResources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopResource upsert
   */
  export type WorkshopResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkshopResource to update in case it exists.
     */
    where: WorkshopResourceWhereUniqueInput
    /**
     * In case the WorkshopResource found by the `where` argument doesn't exist, create a new WorkshopResource with this data.
     */
    create: XOR<WorkshopResourceCreateInput, WorkshopResourceUncheckedCreateInput>
    /**
     * In case the WorkshopResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkshopResourceUpdateInput, WorkshopResourceUncheckedUpdateInput>
  }

  /**
   * WorkshopResource delete
   */
  export type WorkshopResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceInclude<ExtArgs> | null
    /**
     * Filter which WorkshopResource to delete.
     */
    where: WorkshopResourceWhereUniqueInput
  }

  /**
   * WorkshopResource deleteMany
   */
  export type WorkshopResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopResources to delete
     */
    where?: WorkshopResourceWhereInput
    /**
     * Limit how many WorkshopResources to delete.
     */
    limit?: number
  }

  /**
   * WorkshopResource without action
   */
  export type WorkshopResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopResource
     */
    select?: WorkshopResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopResource
     */
    omit?: WorkshopResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopResourceInclude<ExtArgs> | null
  }


  /**
   * Model LessonProgress
   */

  export type AggregateLessonProgress = {
    _count: LessonProgressCountAggregateOutputType | null
    _avg: LessonProgressAvgAggregateOutputType | null
    _sum: LessonProgressSumAggregateOutputType | null
    _min: LessonProgressMinAggregateOutputType | null
    _max: LessonProgressMaxAggregateOutputType | null
  }

  export type LessonProgressAvgAggregateOutputType = {
    watchedSeconds: number | null
  }

  export type LessonProgressSumAggregateOutputType = {
    watchedSeconds: number | null
  }

  export type LessonProgressMinAggregateOutputType = {
    id: string | null
    completed: boolean | null
    startTime: Date | null
    endTime: Date | null
    watchedSeconds: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    lessonId: string | null
  }

  export type LessonProgressMaxAggregateOutputType = {
    id: string | null
    completed: boolean | null
    startTime: Date | null
    endTime: Date | null
    watchedSeconds: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    lessonId: string | null
  }

  export type LessonProgressCountAggregateOutputType = {
    id: number
    completed: number
    startTime: number
    endTime: number
    watchedSeconds: number
    createdAt: number
    updatedAt: number
    userId: number
    lessonId: number
    _all: number
  }


  export type LessonProgressAvgAggregateInputType = {
    watchedSeconds?: true
  }

  export type LessonProgressSumAggregateInputType = {
    watchedSeconds?: true
  }

  export type LessonProgressMinAggregateInputType = {
    id?: true
    completed?: true
    startTime?: true
    endTime?: true
    watchedSeconds?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    lessonId?: true
  }

  export type LessonProgressMaxAggregateInputType = {
    id?: true
    completed?: true
    startTime?: true
    endTime?: true
    watchedSeconds?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    lessonId?: true
  }

  export type LessonProgressCountAggregateInputType = {
    id?: true
    completed?: true
    startTime?: true
    endTime?: true
    watchedSeconds?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    lessonId?: true
    _all?: true
  }

  export type LessonProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonProgress to aggregate.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonProgresses
    **/
    _count?: true | LessonProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonProgressMaxAggregateInputType
  }

  export type GetLessonProgressAggregateType<T extends LessonProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonProgress[P]>
      : GetScalarType<T[P], AggregateLessonProgress[P]>
  }




  export type LessonProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressWhereInput
    orderBy?: LessonProgressOrderByWithAggregationInput | LessonProgressOrderByWithAggregationInput[]
    by: LessonProgressScalarFieldEnum[] | LessonProgressScalarFieldEnum
    having?: LessonProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonProgressCountAggregateInputType | true
    _avg?: LessonProgressAvgAggregateInputType
    _sum?: LessonProgressSumAggregateInputType
    _min?: LessonProgressMinAggregateInputType
    _max?: LessonProgressMaxAggregateInputType
  }

  export type LessonProgressGroupByOutputType = {
    id: string
    completed: boolean
    startTime: Date | null
    endTime: Date | null
    watchedSeconds: number | null
    createdAt: Date
    updatedAt: Date
    userId: string
    lessonId: string
    _count: LessonProgressCountAggregateOutputType | null
    _avg: LessonProgressAvgAggregateOutputType | null
    _sum: LessonProgressSumAggregateOutputType | null
    _min: LessonProgressMinAggregateOutputType | null
    _max: LessonProgressMaxAggregateOutputType | null
  }

  type GetLessonProgressGroupByPayload<T extends LessonProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonProgressGroupByOutputType[P]>
            : GetScalarType<T[P], LessonProgressGroupByOutputType[P]>
        }
      >
    >


  export type LessonProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    completed?: boolean
    startTime?: boolean
    endTime?: boolean
    watchedSeconds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    lessonId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgress"]>

  export type LessonProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    completed?: boolean
    startTime?: boolean
    endTime?: boolean
    watchedSeconds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    lessonId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgress"]>

  export type LessonProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    completed?: boolean
    startTime?: boolean
    endTime?: boolean
    watchedSeconds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    lessonId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgress"]>

  export type LessonProgressSelectScalar = {
    id?: boolean
    completed?: boolean
    startTime?: boolean
    endTime?: boolean
    watchedSeconds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    lessonId?: boolean
  }

  export type LessonProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "completed" | "startTime" | "endTime" | "watchedSeconds" | "createdAt" | "updatedAt" | "userId" | "lessonId", ExtArgs["result"]["lessonProgress"]>
  export type LessonProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type LessonProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type LessonProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $LessonProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      Lesson: Prisma.$LessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      completed: boolean
      startTime: Date | null
      endTime: Date | null
      watchedSeconds: number | null
      createdAt: Date
      updatedAt: Date
      userId: string
      lessonId: string
    }, ExtArgs["result"]["lessonProgress"]>
    composites: {}
  }

  type LessonProgressGetPayload<S extends boolean | null | undefined | LessonProgressDefaultArgs> = $Result.GetResult<Prisma.$LessonProgressPayload, S>

  type LessonProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonProgressCountAggregateInputType | true
    }

  export interface LessonProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonProgress'], meta: { name: 'LessonProgress' } }
    /**
     * Find zero or one LessonProgress that matches the filter.
     * @param {LessonProgressFindUniqueArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonProgressFindUniqueArgs>(args: SelectSubset<T, LessonProgressFindUniqueArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LessonProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonProgressFindUniqueOrThrowArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressFindFirstArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonProgressFindFirstArgs>(args?: SelectSubset<T, LessonProgressFindFirstArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressFindFirstOrThrowArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LessonProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonProgresses
     * const lessonProgresses = await prisma.lessonProgress.findMany()
     * 
     * // Get first 10 LessonProgresses
     * const lessonProgresses = await prisma.lessonProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonProgressWithIdOnly = await prisma.lessonProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonProgressFindManyArgs>(args?: SelectSubset<T, LessonProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LessonProgress.
     * @param {LessonProgressCreateArgs} args - Arguments to create a LessonProgress.
     * @example
     * // Create one LessonProgress
     * const LessonProgress = await prisma.lessonProgress.create({
     *   data: {
     *     // ... data to create a LessonProgress
     *   }
     * })
     * 
     */
    create<T extends LessonProgressCreateArgs>(args: SelectSubset<T, LessonProgressCreateArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LessonProgresses.
     * @param {LessonProgressCreateManyArgs} args - Arguments to create many LessonProgresses.
     * @example
     * // Create many LessonProgresses
     * const lessonProgress = await prisma.lessonProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonProgressCreateManyArgs>(args?: SelectSubset<T, LessonProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonProgresses and returns the data saved in the database.
     * @param {LessonProgressCreateManyAndReturnArgs} args - Arguments to create many LessonProgresses.
     * @example
     * // Create many LessonProgresses
     * const lessonProgress = await prisma.lessonProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonProgresses and only return the `id`
     * const lessonProgressWithIdOnly = await prisma.lessonProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LessonProgress.
     * @param {LessonProgressDeleteArgs} args - Arguments to delete one LessonProgress.
     * @example
     * // Delete one LessonProgress
     * const LessonProgress = await prisma.lessonProgress.delete({
     *   where: {
     *     // ... filter to delete one LessonProgress
     *   }
     * })
     * 
     */
    delete<T extends LessonProgressDeleteArgs>(args: SelectSubset<T, LessonProgressDeleteArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LessonProgress.
     * @param {LessonProgressUpdateArgs} args - Arguments to update one LessonProgress.
     * @example
     * // Update one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonProgressUpdateArgs>(args: SelectSubset<T, LessonProgressUpdateArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LessonProgresses.
     * @param {LessonProgressDeleteManyArgs} args - Arguments to filter LessonProgresses to delete.
     * @example
     * // Delete a few LessonProgresses
     * const { count } = await prisma.lessonProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonProgressDeleteManyArgs>(args?: SelectSubset<T, LessonProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonProgresses
     * const lessonProgress = await prisma.lessonProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonProgressUpdateManyArgs>(args: SelectSubset<T, LessonProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonProgresses and returns the data updated in the database.
     * @param {LessonProgressUpdateManyAndReturnArgs} args - Arguments to update many LessonProgresses.
     * @example
     * // Update many LessonProgresses
     * const lessonProgress = await prisma.lessonProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonProgresses and only return the `id`
     * const lessonProgressWithIdOnly = await prisma.lessonProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LessonProgress.
     * @param {LessonProgressUpsertArgs} args - Arguments to update or create a LessonProgress.
     * @example
     * // Update or create a LessonProgress
     * const lessonProgress = await prisma.lessonProgress.upsert({
     *   create: {
     *     // ... data to create a LessonProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonProgress we want to update
     *   }
     * })
     */
    upsert<T extends LessonProgressUpsertArgs>(args: SelectSubset<T, LessonProgressUpsertArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LessonProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressCountArgs} args - Arguments to filter LessonProgresses to count.
     * @example
     * // Count the number of LessonProgresses
     * const count = await prisma.lessonProgress.count({
     *   where: {
     *     // ... the filter for the LessonProgresses we want to count
     *   }
     * })
    **/
    count<T extends LessonProgressCountArgs>(
      args?: Subset<T, LessonProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonProgressAggregateArgs>(args: Subset<T, LessonProgressAggregateArgs>): Prisma.PrismaPromise<GetLessonProgressAggregateType<T>>

    /**
     * Group by LessonProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonProgressGroupByArgs['orderBy'] }
        : { orderBy?: LessonProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonProgress model
   */
  readonly fields: LessonProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonProgress model
   */
  interface LessonProgressFieldRefs {
    readonly id: FieldRef<"LessonProgress", 'String'>
    readonly completed: FieldRef<"LessonProgress", 'Boolean'>
    readonly startTime: FieldRef<"LessonProgress", 'DateTime'>
    readonly endTime: FieldRef<"LessonProgress", 'DateTime'>
    readonly watchedSeconds: FieldRef<"LessonProgress", 'Int'>
    readonly createdAt: FieldRef<"LessonProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"LessonProgress", 'DateTime'>
    readonly userId: FieldRef<"LessonProgress", 'String'>
    readonly lessonId: FieldRef<"LessonProgress", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LessonProgress findUnique
   */
  export type LessonProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress findUniqueOrThrow
   */
  export type LessonProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress findFirst
   */
  export type LessonProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonProgresses.
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonProgresses.
     */
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * LessonProgress findFirstOrThrow
   */
  export type LessonProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonProgresses.
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonProgresses.
     */
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * LessonProgress findMany
   */
  export type LessonProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgresses to fetch.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonProgresses.
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * LessonProgress create
   */
  export type LessonProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonProgress.
     */
    data: XOR<LessonProgressCreateInput, LessonProgressUncheckedCreateInput>
  }

  /**
   * LessonProgress createMany
   */
  export type LessonProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonProgresses.
     */
    data: LessonProgressCreateManyInput | LessonProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonProgress createManyAndReturn
   */
  export type LessonProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * The data used to create many LessonProgresses.
     */
    data: LessonProgressCreateManyInput | LessonProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonProgress update
   */
  export type LessonProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonProgress.
     */
    data: XOR<LessonProgressUpdateInput, LessonProgressUncheckedUpdateInput>
    /**
     * Choose, which LessonProgress to update.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress updateMany
   */
  export type LessonProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonProgresses.
     */
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyInput>
    /**
     * Filter which LessonProgresses to update
     */
    where?: LessonProgressWhereInput
    /**
     * Limit how many LessonProgresses to update.
     */
    limit?: number
  }

  /**
   * LessonProgress updateManyAndReturn
   */
  export type LessonProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * The data used to update LessonProgresses.
     */
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyInput>
    /**
     * Filter which LessonProgresses to update
     */
    where?: LessonProgressWhereInput
    /**
     * Limit how many LessonProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonProgress upsert
   */
  export type LessonProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonProgress to update in case it exists.
     */
    where: LessonProgressWhereUniqueInput
    /**
     * In case the LessonProgress found by the `where` argument doesn't exist, create a new LessonProgress with this data.
     */
    create: XOR<LessonProgressCreateInput, LessonProgressUncheckedCreateInput>
    /**
     * In case the LessonProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonProgressUpdateInput, LessonProgressUncheckedUpdateInput>
  }

  /**
   * LessonProgress delete
   */
  export type LessonProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter which LessonProgress to delete.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress deleteMany
   */
  export type LessonProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonProgresses to delete
     */
    where?: LessonProgressWhereInput
    /**
     * Limit how many LessonProgresses to delete.
     */
    limit?: number
  }

  /**
   * LessonProgress without action
   */
  export type LessonProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
  }


  /**
   * Model UserProgress
   */

  export type AggregateUserProgress = {
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  export type UserProgressAvgAggregateOutputType = {
    progressPercentage: number | null
    timeSpent: number | null
  }

  export type UserProgressSumAggregateOutputType = {
    progressPercentage: number | null
    timeSpent: number | null
  }

  export type UserProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    itemId: string | null
    completed: boolean | null
    updatedAt: Date | null
    progressPercentage: number | null
    startedAt: Date | null
    completedAt: Date | null
    timeSpent: number | null
  }

  export type UserProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    itemId: string | null
    completed: boolean | null
    updatedAt: Date | null
    progressPercentage: number | null
    startedAt: Date | null
    completedAt: Date | null
    timeSpent: number | null
  }

  export type UserProgressCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    itemId: number
    completed: number
    updatedAt: number
    progressPercentage: number
    startedAt: number
    completedAt: number
    timeSpent: number
    _all: number
  }


  export type UserProgressAvgAggregateInputType = {
    progressPercentage?: true
    timeSpent?: true
  }

  export type UserProgressSumAggregateInputType = {
    progressPercentage?: true
    timeSpent?: true
  }

  export type UserProgressMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    itemId?: true
    completed?: true
    updatedAt?: true
    progressPercentage?: true
    startedAt?: true
    completedAt?: true
    timeSpent?: true
  }

  export type UserProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    itemId?: true
    completed?: true
    updatedAt?: true
    progressPercentage?: true
    startedAt?: true
    completedAt?: true
    timeSpent?: true
  }

  export type UserProgressCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    itemId?: true
    completed?: true
    updatedAt?: true
    progressPercentage?: true
    startedAt?: true
    completedAt?: true
    timeSpent?: true
    _all?: true
  }

  export type UserProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgress to aggregate.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProgresses
    **/
    _count?: true | UserProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProgressMaxAggregateInputType
  }

  export type GetUserProgressAggregateType<T extends UserProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProgress[P]>
      : GetScalarType<T[P], AggregateUserProgress[P]>
  }




  export type UserProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithAggregationInput | UserProgressOrderByWithAggregationInput[]
    by: UserProgressScalarFieldEnum[] | UserProgressScalarFieldEnum
    having?: UserProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProgressCountAggregateInputType | true
    _avg?: UserProgressAvgAggregateInputType
    _sum?: UserProgressSumAggregateInputType
    _min?: UserProgressMinAggregateInputType
    _max?: UserProgressMaxAggregateInputType
  }

  export type UserProgressGroupByOutputType = {
    id: string
    userId: string
    type: string
    itemId: string
    completed: boolean
    updatedAt: Date
    progressPercentage: number | null
    startedAt: Date | null
    completedAt: Date | null
    timeSpent: number | null
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  type GetUserProgressGroupByPayload<T extends UserProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    itemId?: boolean
    completed?: boolean
    updatedAt?: boolean
    progressPercentage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    timeSpent?: boolean
    course?: boolean | UserProgress$courseArgs<ExtArgs>
    workshop?: boolean | UserProgress$workshopArgs<ExtArgs>
    path?: boolean | UserProgress$pathArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    itemId?: boolean
    completed?: boolean
    updatedAt?: boolean
    progressPercentage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    timeSpent?: boolean
    course?: boolean | UserProgress$courseArgs<ExtArgs>
    workshop?: boolean | UserProgress$workshopArgs<ExtArgs>
    path?: boolean | UserProgress$pathArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    itemId?: boolean
    completed?: boolean
    updatedAt?: boolean
    progressPercentage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    timeSpent?: boolean
    course?: boolean | UserProgress$courseArgs<ExtArgs>
    workshop?: boolean | UserProgress$workshopArgs<ExtArgs>
    path?: boolean | UserProgress$pathArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    itemId?: boolean
    completed?: boolean
    updatedAt?: boolean
    progressPercentage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    timeSpent?: boolean
  }

  export type UserProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "itemId" | "completed" | "updatedAt" | "progressPercentage" | "startedAt" | "completedAt" | "timeSpent", ExtArgs["result"]["userProgress"]>
  export type UserProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | UserProgress$courseArgs<ExtArgs>
    workshop?: boolean | UserProgress$workshopArgs<ExtArgs>
    path?: boolean | UserProgress$pathArgs<ExtArgs>
  }
  export type UserProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | UserProgress$courseArgs<ExtArgs>
    workshop?: boolean | UserProgress$workshopArgs<ExtArgs>
    path?: boolean | UserProgress$pathArgs<ExtArgs>
  }
  export type UserProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | UserProgress$courseArgs<ExtArgs>
    workshop?: boolean | UserProgress$workshopArgs<ExtArgs>
    path?: boolean | UserProgress$pathArgs<ExtArgs>
  }

  export type $UserProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProgress"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs> | null
      workshop: Prisma.$WorkshopPayload<ExtArgs> | null
      path: Prisma.$LearningPathPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      itemId: string
      completed: boolean
      updatedAt: Date
      progressPercentage: number | null
      startedAt: Date | null
      completedAt: Date | null
      timeSpent: number | null
    }, ExtArgs["result"]["userProgress"]>
    composites: {}
  }

  type UserProgressGetPayload<S extends boolean | null | undefined | UserProgressDefaultArgs> = $Result.GetResult<Prisma.$UserProgressPayload, S>

  type UserProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProgressCountAggregateInputType | true
    }

  export interface UserProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProgress'], meta: { name: 'UserProgress' } }
    /**
     * Find zero or one UserProgress that matches the filter.
     * @param {UserProgressFindUniqueArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProgressFindUniqueArgs>(args: SelectSubset<T, UserProgressFindUniqueArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProgressFindUniqueOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProgressFindFirstArgs>(args?: SelectSubset<T, UserProgressFindFirstArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProgresses
     * const userProgresses = await prisma.userProgress.findMany()
     * 
     * // Get first 10 UserProgresses
     * const userProgresses = await prisma.userProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProgressFindManyArgs>(args?: SelectSubset<T, UserProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProgress.
     * @param {UserProgressCreateArgs} args - Arguments to create a UserProgress.
     * @example
     * // Create one UserProgress
     * const UserProgress = await prisma.userProgress.create({
     *   data: {
     *     // ... data to create a UserProgress
     *   }
     * })
     * 
     */
    create<T extends UserProgressCreateArgs>(args: SelectSubset<T, UserProgressCreateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProgresses.
     * @param {UserProgressCreateManyArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProgressCreateManyArgs>(args?: SelectSubset<T, UserProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProgresses and returns the data saved in the database.
     * @param {UserProgressCreateManyAndReturnArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProgresses and only return the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProgress.
     * @param {UserProgressDeleteArgs} args - Arguments to delete one UserProgress.
     * @example
     * // Delete one UserProgress
     * const UserProgress = await prisma.userProgress.delete({
     *   where: {
     *     // ... filter to delete one UserProgress
     *   }
     * })
     * 
     */
    delete<T extends UserProgressDeleteArgs>(args: SelectSubset<T, UserProgressDeleteArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProgress.
     * @param {UserProgressUpdateArgs} args - Arguments to update one UserProgress.
     * @example
     * // Update one UserProgress
     * const userProgress = await prisma.userProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProgressUpdateArgs>(args: SelectSubset<T, UserProgressUpdateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProgresses.
     * @param {UserProgressDeleteManyArgs} args - Arguments to filter UserProgresses to delete.
     * @example
     * // Delete a few UserProgresses
     * const { count } = await prisma.userProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProgressDeleteManyArgs>(args?: SelectSubset<T, UserProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProgressUpdateManyArgs>(args: SelectSubset<T, UserProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses and returns the data updated in the database.
     * @param {UserProgressUpdateManyAndReturnArgs} args - Arguments to update many UserProgresses.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProgresses and only return the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProgress.
     * @param {UserProgressUpsertArgs} args - Arguments to update or create a UserProgress.
     * @example
     * // Update or create a UserProgress
     * const userProgress = await prisma.userProgress.upsert({
     *   create: {
     *     // ... data to create a UserProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserProgressUpsertArgs>(args: SelectSubset<T, UserProgressUpsertArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressCountArgs} args - Arguments to filter UserProgresses to count.
     * @example
     * // Count the number of UserProgresses
     * const count = await prisma.userProgress.count({
     *   where: {
     *     // ... the filter for the UserProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserProgressCountArgs>(
      args?: Subset<T, UserProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProgressAggregateArgs>(args: Subset<T, UserProgressAggregateArgs>): Prisma.PrismaPromise<GetUserProgressAggregateType<T>>

    /**
     * Group by UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProgress model
   */
  readonly fields: UserProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends UserProgress$courseArgs<ExtArgs> = {}>(args?: Subset<T, UserProgress$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workshop<T extends UserProgress$workshopArgs<ExtArgs> = {}>(args?: Subset<T, UserProgress$workshopArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    path<T extends UserProgress$pathArgs<ExtArgs> = {}>(args?: Subset<T, UserProgress$pathArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProgress model
   */
  interface UserProgressFieldRefs {
    readonly id: FieldRef<"UserProgress", 'String'>
    readonly userId: FieldRef<"UserProgress", 'String'>
    readonly type: FieldRef<"UserProgress", 'String'>
    readonly itemId: FieldRef<"UserProgress", 'String'>
    readonly completed: FieldRef<"UserProgress", 'Boolean'>
    readonly updatedAt: FieldRef<"UserProgress", 'DateTime'>
    readonly progressPercentage: FieldRef<"UserProgress", 'Float'>
    readonly startedAt: FieldRef<"UserProgress", 'DateTime'>
    readonly completedAt: FieldRef<"UserProgress", 'DateTime'>
    readonly timeSpent: FieldRef<"UserProgress", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserProgress findUnique
   */
  export type UserProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findUniqueOrThrow
   */
  export type UserProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findFirst
   */
  export type UserProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findFirstOrThrow
   */
  export type UserProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findMany
   */
  export type UserProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgresses to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress create
   */
  export type UserProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProgress.
     */
    data: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
  }

  /**
   * UserProgress createMany
   */
  export type UserProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProgress createManyAndReturn
   */
  export type UserProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProgress update
   */
  export type UserProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProgress.
     */
    data: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
    /**
     * Choose, which UserProgress to update.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress updateMany
   */
  export type UserProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to update.
     */
    limit?: number
  }

  /**
   * UserProgress updateManyAndReturn
   */
  export type UserProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProgress upsert
   */
  export type UserProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProgress to update in case it exists.
     */
    where: UserProgressWhereUniqueInput
    /**
     * In case the UserProgress found by the `where` argument doesn't exist, create a new UserProgress with this data.
     */
    create: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
    /**
     * In case the UserProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
  }

  /**
   * UserProgress delete
   */
  export type UserProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter which UserProgress to delete.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress deleteMany
   */
  export type UserProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgresses to delete
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to delete.
     */
    limit?: number
  }

  /**
   * UserProgress.course
   */
  export type UserProgress$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * UserProgress.workshop
   */
  export type UserProgress$workshopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    where?: WorkshopWhereInput
  }

  /**
   * UserProgress.path
   */
  export type UserProgress$pathArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    where?: LearningPathWhereInput
  }

  /**
   * UserProgress without action
   */
  export type UserProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    title: string
    slug: string
    color: string | null
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseTags?: boolean | Tag$courseTagsArgs<ExtArgs>
    workshopTags?: boolean | Tag$workshopTagsArgs<ExtArgs>
    learningPathTags?: boolean | Tag$learningPathTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "color" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseTags?: boolean | Tag$courseTagsArgs<ExtArgs>
    workshopTags?: boolean | Tag$workshopTagsArgs<ExtArgs>
    learningPathTags?: boolean | Tag$learningPathTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      courseTags: Prisma.$CourseTagPayload<ExtArgs>[]
      workshopTags: Prisma.$WorkshopTagPayload<ExtArgs>[]
      learningPathTags: Prisma.$LearningPathTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      color: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courseTags<T extends Tag$courseTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$courseTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workshopTags<T extends Tag$workshopTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$workshopTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningPathTags<T extends Tag$learningPathTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$learningPathTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly title: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.courseTags
   */
  export type Tag$courseTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    where?: CourseTagWhereInput
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    cursor?: CourseTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * Tag.workshopTags
   */
  export type Tag$workshopTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagInclude<ExtArgs> | null
    where?: WorkshopTagWhereInput
    orderBy?: WorkshopTagOrderByWithRelationInput | WorkshopTagOrderByWithRelationInput[]
    cursor?: WorkshopTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopTagScalarFieldEnum | WorkshopTagScalarFieldEnum[]
  }

  /**
   * Tag.learningPathTags
   */
  export type Tag$learningPathTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagInclude<ExtArgs> | null
    where?: LearningPathTagWhereInput
    orderBy?: LearningPathTagOrderByWithRelationInput | LearningPathTagOrderByWithRelationInput[]
    cursor?: LearningPathTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathTagScalarFieldEnum | LearningPathTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model CourseTag
   */

  export type AggregateCourseTag = {
    _count: CourseTagCountAggregateOutputType | null
    _min: CourseTagMinAggregateOutputType | null
    _max: CourseTagMaxAggregateOutputType | null
  }

  export type CourseTagMinAggregateOutputType = {
    courseId: string | null
    tagId: string | null
  }

  export type CourseTagMaxAggregateOutputType = {
    courseId: string | null
    tagId: string | null
  }

  export type CourseTagCountAggregateOutputType = {
    courseId: number
    tagId: number
    _all: number
  }


  export type CourseTagMinAggregateInputType = {
    courseId?: true
    tagId?: true
  }

  export type CourseTagMaxAggregateInputType = {
    courseId?: true
    tagId?: true
  }

  export type CourseTagCountAggregateInputType = {
    courseId?: true
    tagId?: true
    _all?: true
  }

  export type CourseTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTag to aggregate.
     */
    where?: CourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseTags
    **/
    _count?: true | CourseTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseTagMaxAggregateInputType
  }

  export type GetCourseTagAggregateType<T extends CourseTagAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseTag[P]>
      : GetScalarType<T[P], AggregateCourseTag[P]>
  }




  export type CourseTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTagWhereInput
    orderBy?: CourseTagOrderByWithAggregationInput | CourseTagOrderByWithAggregationInput[]
    by: CourseTagScalarFieldEnum[] | CourseTagScalarFieldEnum
    having?: CourseTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseTagCountAggregateInputType | true
    _min?: CourseTagMinAggregateInputType
    _max?: CourseTagMaxAggregateInputType
  }

  export type CourseTagGroupByOutputType = {
    courseId: string
    tagId: string
    _count: CourseTagCountAggregateOutputType | null
    _min: CourseTagMinAggregateOutputType | null
    _max: CourseTagMaxAggregateOutputType | null
  }

  type GetCourseTagGroupByPayload<T extends CourseTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseTagGroupByOutputType[P]>
            : GetScalarType<T[P], CourseTagGroupByOutputType[P]>
        }
      >
    >


  export type CourseTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    tagId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTag"]>

  export type CourseTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    tagId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTag"]>

  export type CourseTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    tagId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTag"]>

  export type CourseTagSelectScalar = {
    courseId?: boolean
    tagId?: boolean
  }

  export type CourseTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"courseId" | "tagId", ExtArgs["result"]["courseTag"]>
  export type CourseTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type CourseTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type CourseTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $CourseTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseTag"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      courseId: string
      tagId: string
    }, ExtArgs["result"]["courseTag"]>
    composites: {}
  }

  type CourseTagGetPayload<S extends boolean | null | undefined | CourseTagDefaultArgs> = $Result.GetResult<Prisma.$CourseTagPayload, S>

  type CourseTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseTagCountAggregateInputType | true
    }

  export interface CourseTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseTag'], meta: { name: 'CourseTag' } }
    /**
     * Find zero or one CourseTag that matches the filter.
     * @param {CourseTagFindUniqueArgs} args - Arguments to find a CourseTag
     * @example
     * // Get one CourseTag
     * const courseTag = await prisma.courseTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseTagFindUniqueArgs>(args: SelectSubset<T, CourseTagFindUniqueArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseTagFindUniqueOrThrowArgs} args - Arguments to find a CourseTag
     * @example
     * // Get one CourseTag
     * const courseTag = await prisma.courseTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseTagFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagFindFirstArgs} args - Arguments to find a CourseTag
     * @example
     * // Get one CourseTag
     * const courseTag = await prisma.courseTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseTagFindFirstArgs>(args?: SelectSubset<T, CourseTagFindFirstArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagFindFirstOrThrowArgs} args - Arguments to find a CourseTag
     * @example
     * // Get one CourseTag
     * const courseTag = await prisma.courseTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseTagFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseTags
     * const courseTags = await prisma.courseTag.findMany()
     * 
     * // Get first 10 CourseTags
     * const courseTags = await prisma.courseTag.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const courseTagWithCourseIdOnly = await prisma.courseTag.findMany({ select: { courseId: true } })
     * 
     */
    findMany<T extends CourseTagFindManyArgs>(args?: SelectSubset<T, CourseTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseTag.
     * @param {CourseTagCreateArgs} args - Arguments to create a CourseTag.
     * @example
     * // Create one CourseTag
     * const CourseTag = await prisma.courseTag.create({
     *   data: {
     *     // ... data to create a CourseTag
     *   }
     * })
     * 
     */
    create<T extends CourseTagCreateArgs>(args: SelectSubset<T, CourseTagCreateArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseTags.
     * @param {CourseTagCreateManyArgs} args - Arguments to create many CourseTags.
     * @example
     * // Create many CourseTags
     * const courseTag = await prisma.courseTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseTagCreateManyArgs>(args?: SelectSubset<T, CourseTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseTags and returns the data saved in the database.
     * @param {CourseTagCreateManyAndReturnArgs} args - Arguments to create many CourseTags.
     * @example
     * // Create many CourseTags
     * const courseTag = await prisma.courseTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseTags and only return the `courseId`
     * const courseTagWithCourseIdOnly = await prisma.courseTag.createManyAndReturn({
     *   select: { courseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseTagCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseTag.
     * @param {CourseTagDeleteArgs} args - Arguments to delete one CourseTag.
     * @example
     * // Delete one CourseTag
     * const CourseTag = await prisma.courseTag.delete({
     *   where: {
     *     // ... filter to delete one CourseTag
     *   }
     * })
     * 
     */
    delete<T extends CourseTagDeleteArgs>(args: SelectSubset<T, CourseTagDeleteArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseTag.
     * @param {CourseTagUpdateArgs} args - Arguments to update one CourseTag.
     * @example
     * // Update one CourseTag
     * const courseTag = await prisma.courseTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseTagUpdateArgs>(args: SelectSubset<T, CourseTagUpdateArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseTags.
     * @param {CourseTagDeleteManyArgs} args - Arguments to filter CourseTags to delete.
     * @example
     * // Delete a few CourseTags
     * const { count } = await prisma.courseTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseTagDeleteManyArgs>(args?: SelectSubset<T, CourseTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseTags
     * const courseTag = await prisma.courseTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseTagUpdateManyArgs>(args: SelectSubset<T, CourseTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseTags and returns the data updated in the database.
     * @param {CourseTagUpdateManyAndReturnArgs} args - Arguments to update many CourseTags.
     * @example
     * // Update many CourseTags
     * const courseTag = await prisma.courseTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseTags and only return the `courseId`
     * const courseTagWithCourseIdOnly = await prisma.courseTag.updateManyAndReturn({
     *   select: { courseId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseTagUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseTag.
     * @param {CourseTagUpsertArgs} args - Arguments to update or create a CourseTag.
     * @example
     * // Update or create a CourseTag
     * const courseTag = await prisma.courseTag.upsert({
     *   create: {
     *     // ... data to create a CourseTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseTag we want to update
     *   }
     * })
     */
    upsert<T extends CourseTagUpsertArgs>(args: SelectSubset<T, CourseTagUpsertArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagCountArgs} args - Arguments to filter CourseTags to count.
     * @example
     * // Count the number of CourseTags
     * const count = await prisma.courseTag.count({
     *   where: {
     *     // ... the filter for the CourseTags we want to count
     *   }
     * })
    **/
    count<T extends CourseTagCountArgs>(
      args?: Subset<T, CourseTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseTagAggregateArgs>(args: Subset<T, CourseTagAggregateArgs>): Prisma.PrismaPromise<GetCourseTagAggregateType<T>>

    /**
     * Group by CourseTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseTagGroupByArgs['orderBy'] }
        : { orderBy?: CourseTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseTag model
   */
  readonly fields: CourseTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseTag model
   */
  interface CourseTagFieldRefs {
    readonly courseId: FieldRef<"CourseTag", 'String'>
    readonly tagId: FieldRef<"CourseTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseTag findUnique
   */
  export type CourseTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTag to fetch.
     */
    where: CourseTagWhereUniqueInput
  }

  /**
   * CourseTag findUniqueOrThrow
   */
  export type CourseTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTag to fetch.
     */
    where: CourseTagWhereUniqueInput
  }

  /**
   * CourseTag findFirst
   */
  export type CourseTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTag to fetch.
     */
    where?: CourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTags.
     */
    cursor?: CourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTags.
     */
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * CourseTag findFirstOrThrow
   */
  export type CourseTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTag to fetch.
     */
    where?: CourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTags.
     */
    cursor?: CourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTags.
     */
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * CourseTag findMany
   */
  export type CourseTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTags to fetch.
     */
    where?: CourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseTags.
     */
    cursor?: CourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * CourseTag create
   */
  export type CourseTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseTag.
     */
    data: XOR<CourseTagCreateInput, CourseTagUncheckedCreateInput>
  }

  /**
   * CourseTag createMany
   */
  export type CourseTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseTags.
     */
    data: CourseTagCreateManyInput | CourseTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseTag createManyAndReturn
   */
  export type CourseTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * The data used to create many CourseTags.
     */
    data: CourseTagCreateManyInput | CourseTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseTag update
   */
  export type CourseTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseTag.
     */
    data: XOR<CourseTagUpdateInput, CourseTagUncheckedUpdateInput>
    /**
     * Choose, which CourseTag to update.
     */
    where: CourseTagWhereUniqueInput
  }

  /**
   * CourseTag updateMany
   */
  export type CourseTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseTags.
     */
    data: XOR<CourseTagUpdateManyMutationInput, CourseTagUncheckedUpdateManyInput>
    /**
     * Filter which CourseTags to update
     */
    where?: CourseTagWhereInput
    /**
     * Limit how many CourseTags to update.
     */
    limit?: number
  }

  /**
   * CourseTag updateManyAndReturn
   */
  export type CourseTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * The data used to update CourseTags.
     */
    data: XOR<CourseTagUpdateManyMutationInput, CourseTagUncheckedUpdateManyInput>
    /**
     * Filter which CourseTags to update
     */
    where?: CourseTagWhereInput
    /**
     * Limit how many CourseTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseTag upsert
   */
  export type CourseTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseTag to update in case it exists.
     */
    where: CourseTagWhereUniqueInput
    /**
     * In case the CourseTag found by the `where` argument doesn't exist, create a new CourseTag with this data.
     */
    create: XOR<CourseTagCreateInput, CourseTagUncheckedCreateInput>
    /**
     * In case the CourseTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseTagUpdateInput, CourseTagUncheckedUpdateInput>
  }

  /**
   * CourseTag delete
   */
  export type CourseTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter which CourseTag to delete.
     */
    where: CourseTagWhereUniqueInput
  }

  /**
   * CourseTag deleteMany
   */
  export type CourseTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTags to delete
     */
    where?: CourseTagWhereInput
    /**
     * Limit how many CourseTags to delete.
     */
    limit?: number
  }

  /**
   * CourseTag without action
   */
  export type CourseTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
  }


  /**
   * Model WorkshopTag
   */

  export type AggregateWorkshopTag = {
    _count: WorkshopTagCountAggregateOutputType | null
    _min: WorkshopTagMinAggregateOutputType | null
    _max: WorkshopTagMaxAggregateOutputType | null
  }

  export type WorkshopTagMinAggregateOutputType = {
    workshopId: string | null
    tagId: string | null
  }

  export type WorkshopTagMaxAggregateOutputType = {
    workshopId: string | null
    tagId: string | null
  }

  export type WorkshopTagCountAggregateOutputType = {
    workshopId: number
    tagId: number
    _all: number
  }


  export type WorkshopTagMinAggregateInputType = {
    workshopId?: true
    tagId?: true
  }

  export type WorkshopTagMaxAggregateInputType = {
    workshopId?: true
    tagId?: true
  }

  export type WorkshopTagCountAggregateInputType = {
    workshopId?: true
    tagId?: true
    _all?: true
  }

  export type WorkshopTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopTag to aggregate.
     */
    where?: WorkshopTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopTags to fetch.
     */
    orderBy?: WorkshopTagOrderByWithRelationInput | WorkshopTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkshopTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkshopTags
    **/
    _count?: true | WorkshopTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkshopTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkshopTagMaxAggregateInputType
  }

  export type GetWorkshopTagAggregateType<T extends WorkshopTagAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkshopTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkshopTag[P]>
      : GetScalarType<T[P], AggregateWorkshopTag[P]>
  }




  export type WorkshopTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopTagWhereInput
    orderBy?: WorkshopTagOrderByWithAggregationInput | WorkshopTagOrderByWithAggregationInput[]
    by: WorkshopTagScalarFieldEnum[] | WorkshopTagScalarFieldEnum
    having?: WorkshopTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkshopTagCountAggregateInputType | true
    _min?: WorkshopTagMinAggregateInputType
    _max?: WorkshopTagMaxAggregateInputType
  }

  export type WorkshopTagGroupByOutputType = {
    workshopId: string
    tagId: string
    _count: WorkshopTagCountAggregateOutputType | null
    _min: WorkshopTagMinAggregateOutputType | null
    _max: WorkshopTagMaxAggregateOutputType | null
  }

  type GetWorkshopTagGroupByPayload<T extends WorkshopTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkshopTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkshopTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkshopTagGroupByOutputType[P]>
            : GetScalarType<T[P], WorkshopTagGroupByOutputType[P]>
        }
      >
    >


  export type WorkshopTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workshopId?: boolean
    tagId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopTag"]>

  export type WorkshopTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workshopId?: boolean
    tagId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopTag"]>

  export type WorkshopTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workshopId?: boolean
    tagId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopTag"]>

  export type WorkshopTagSelectScalar = {
    workshopId?: boolean
    tagId?: boolean
  }

  export type WorkshopTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workshopId" | "tagId", ExtArgs["result"]["workshopTag"]>
  export type WorkshopTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type WorkshopTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type WorkshopTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $WorkshopTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkshopTag"
    objects: {
      workshop: Prisma.$WorkshopPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workshopId: string
      tagId: string
    }, ExtArgs["result"]["workshopTag"]>
    composites: {}
  }

  type WorkshopTagGetPayload<S extends boolean | null | undefined | WorkshopTagDefaultArgs> = $Result.GetResult<Prisma.$WorkshopTagPayload, S>

  type WorkshopTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkshopTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkshopTagCountAggregateInputType | true
    }

  export interface WorkshopTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkshopTag'], meta: { name: 'WorkshopTag' } }
    /**
     * Find zero or one WorkshopTag that matches the filter.
     * @param {WorkshopTagFindUniqueArgs} args - Arguments to find a WorkshopTag
     * @example
     * // Get one WorkshopTag
     * const workshopTag = await prisma.workshopTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkshopTagFindUniqueArgs>(args: SelectSubset<T, WorkshopTagFindUniqueArgs<ExtArgs>>): Prisma__WorkshopTagClient<$Result.GetResult<Prisma.$WorkshopTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkshopTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkshopTagFindUniqueOrThrowArgs} args - Arguments to find a WorkshopTag
     * @example
     * // Get one WorkshopTag
     * const workshopTag = await prisma.workshopTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkshopTagFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkshopTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkshopTagClient<$Result.GetResult<Prisma.$WorkshopTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTagFindFirstArgs} args - Arguments to find a WorkshopTag
     * @example
     * // Get one WorkshopTag
     * const workshopTag = await prisma.workshopTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkshopTagFindFirstArgs>(args?: SelectSubset<T, WorkshopTagFindFirstArgs<ExtArgs>>): Prisma__WorkshopTagClient<$Result.GetResult<Prisma.$WorkshopTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTagFindFirstOrThrowArgs} args - Arguments to find a WorkshopTag
     * @example
     * // Get one WorkshopTag
     * const workshopTag = await prisma.workshopTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkshopTagFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkshopTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkshopTagClient<$Result.GetResult<Prisma.$WorkshopTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkshopTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkshopTags
     * const workshopTags = await prisma.workshopTag.findMany()
     * 
     * // Get first 10 WorkshopTags
     * const workshopTags = await prisma.workshopTag.findMany({ take: 10 })
     * 
     * // Only select the `workshopId`
     * const workshopTagWithWorkshopIdOnly = await prisma.workshopTag.findMany({ select: { workshopId: true } })
     * 
     */
    findMany<T extends WorkshopTagFindManyArgs>(args?: SelectSubset<T, WorkshopTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkshopTag.
     * @param {WorkshopTagCreateArgs} args - Arguments to create a WorkshopTag.
     * @example
     * // Create one WorkshopTag
     * const WorkshopTag = await prisma.workshopTag.create({
     *   data: {
     *     // ... data to create a WorkshopTag
     *   }
     * })
     * 
     */
    create<T extends WorkshopTagCreateArgs>(args: SelectSubset<T, WorkshopTagCreateArgs<ExtArgs>>): Prisma__WorkshopTagClient<$Result.GetResult<Prisma.$WorkshopTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkshopTags.
     * @param {WorkshopTagCreateManyArgs} args - Arguments to create many WorkshopTags.
     * @example
     * // Create many WorkshopTags
     * const workshopTag = await prisma.workshopTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkshopTagCreateManyArgs>(args?: SelectSubset<T, WorkshopTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkshopTags and returns the data saved in the database.
     * @param {WorkshopTagCreateManyAndReturnArgs} args - Arguments to create many WorkshopTags.
     * @example
     * // Create many WorkshopTags
     * const workshopTag = await prisma.workshopTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkshopTags and only return the `workshopId`
     * const workshopTagWithWorkshopIdOnly = await prisma.workshopTag.createManyAndReturn({
     *   select: { workshopId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkshopTagCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkshopTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkshopTag.
     * @param {WorkshopTagDeleteArgs} args - Arguments to delete one WorkshopTag.
     * @example
     * // Delete one WorkshopTag
     * const WorkshopTag = await prisma.workshopTag.delete({
     *   where: {
     *     // ... filter to delete one WorkshopTag
     *   }
     * })
     * 
     */
    delete<T extends WorkshopTagDeleteArgs>(args: SelectSubset<T, WorkshopTagDeleteArgs<ExtArgs>>): Prisma__WorkshopTagClient<$Result.GetResult<Prisma.$WorkshopTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkshopTag.
     * @param {WorkshopTagUpdateArgs} args - Arguments to update one WorkshopTag.
     * @example
     * // Update one WorkshopTag
     * const workshopTag = await prisma.workshopTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkshopTagUpdateArgs>(args: SelectSubset<T, WorkshopTagUpdateArgs<ExtArgs>>): Prisma__WorkshopTagClient<$Result.GetResult<Prisma.$WorkshopTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkshopTags.
     * @param {WorkshopTagDeleteManyArgs} args - Arguments to filter WorkshopTags to delete.
     * @example
     * // Delete a few WorkshopTags
     * const { count } = await prisma.workshopTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkshopTagDeleteManyArgs>(args?: SelectSubset<T, WorkshopTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkshopTags
     * const workshopTag = await prisma.workshopTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkshopTagUpdateManyArgs>(args: SelectSubset<T, WorkshopTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopTags and returns the data updated in the database.
     * @param {WorkshopTagUpdateManyAndReturnArgs} args - Arguments to update many WorkshopTags.
     * @example
     * // Update many WorkshopTags
     * const workshopTag = await prisma.workshopTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkshopTags and only return the `workshopId`
     * const workshopTagWithWorkshopIdOnly = await prisma.workshopTag.updateManyAndReturn({
     *   select: { workshopId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkshopTagUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkshopTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkshopTag.
     * @param {WorkshopTagUpsertArgs} args - Arguments to update or create a WorkshopTag.
     * @example
     * // Update or create a WorkshopTag
     * const workshopTag = await prisma.workshopTag.upsert({
     *   create: {
     *     // ... data to create a WorkshopTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkshopTag we want to update
     *   }
     * })
     */
    upsert<T extends WorkshopTagUpsertArgs>(args: SelectSubset<T, WorkshopTagUpsertArgs<ExtArgs>>): Prisma__WorkshopTagClient<$Result.GetResult<Prisma.$WorkshopTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkshopTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTagCountArgs} args - Arguments to filter WorkshopTags to count.
     * @example
     * // Count the number of WorkshopTags
     * const count = await prisma.workshopTag.count({
     *   where: {
     *     // ... the filter for the WorkshopTags we want to count
     *   }
     * })
    **/
    count<T extends WorkshopTagCountArgs>(
      args?: Subset<T, WorkshopTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkshopTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkshopTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkshopTagAggregateArgs>(args: Subset<T, WorkshopTagAggregateArgs>): Prisma.PrismaPromise<GetWorkshopTagAggregateType<T>>

    /**
     * Group by WorkshopTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkshopTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkshopTagGroupByArgs['orderBy'] }
        : { orderBy?: WorkshopTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkshopTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkshopTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkshopTag model
   */
  readonly fields: WorkshopTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkshopTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkshopTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workshop<T extends WorkshopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkshopDefaultArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkshopTag model
   */
  interface WorkshopTagFieldRefs {
    readonly workshopId: FieldRef<"WorkshopTag", 'String'>
    readonly tagId: FieldRef<"WorkshopTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkshopTag findUnique
   */
  export type WorkshopTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopTag to fetch.
     */
    where: WorkshopTagWhereUniqueInput
  }

  /**
   * WorkshopTag findUniqueOrThrow
   */
  export type WorkshopTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopTag to fetch.
     */
    where: WorkshopTagWhereUniqueInput
  }

  /**
   * WorkshopTag findFirst
   */
  export type WorkshopTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopTag to fetch.
     */
    where?: WorkshopTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopTags to fetch.
     */
    orderBy?: WorkshopTagOrderByWithRelationInput | WorkshopTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopTags.
     */
    cursor?: WorkshopTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopTags.
     */
    distinct?: WorkshopTagScalarFieldEnum | WorkshopTagScalarFieldEnum[]
  }

  /**
   * WorkshopTag findFirstOrThrow
   */
  export type WorkshopTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopTag to fetch.
     */
    where?: WorkshopTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopTags to fetch.
     */
    orderBy?: WorkshopTagOrderByWithRelationInput | WorkshopTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopTags.
     */
    cursor?: WorkshopTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopTags.
     */
    distinct?: WorkshopTagScalarFieldEnum | WorkshopTagScalarFieldEnum[]
  }

  /**
   * WorkshopTag findMany
   */
  export type WorkshopTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopTags to fetch.
     */
    where?: WorkshopTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopTags to fetch.
     */
    orderBy?: WorkshopTagOrderByWithRelationInput | WorkshopTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkshopTags.
     */
    cursor?: WorkshopTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopTags.
     */
    skip?: number
    distinct?: WorkshopTagScalarFieldEnum | WorkshopTagScalarFieldEnum[]
  }

  /**
   * WorkshopTag create
   */
  export type WorkshopTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkshopTag.
     */
    data: XOR<WorkshopTagCreateInput, WorkshopTagUncheckedCreateInput>
  }

  /**
   * WorkshopTag createMany
   */
  export type WorkshopTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkshopTags.
     */
    data: WorkshopTagCreateManyInput | WorkshopTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkshopTag createManyAndReturn
   */
  export type WorkshopTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * The data used to create many WorkshopTags.
     */
    data: WorkshopTagCreateManyInput | WorkshopTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopTag update
   */
  export type WorkshopTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkshopTag.
     */
    data: XOR<WorkshopTagUpdateInput, WorkshopTagUncheckedUpdateInput>
    /**
     * Choose, which WorkshopTag to update.
     */
    where: WorkshopTagWhereUniqueInput
  }

  /**
   * WorkshopTag updateMany
   */
  export type WorkshopTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkshopTags.
     */
    data: XOR<WorkshopTagUpdateManyMutationInput, WorkshopTagUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopTags to update
     */
    where?: WorkshopTagWhereInput
    /**
     * Limit how many WorkshopTags to update.
     */
    limit?: number
  }

  /**
   * WorkshopTag updateManyAndReturn
   */
  export type WorkshopTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * The data used to update WorkshopTags.
     */
    data: XOR<WorkshopTagUpdateManyMutationInput, WorkshopTagUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopTags to update
     */
    where?: WorkshopTagWhereInput
    /**
     * Limit how many WorkshopTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopTag upsert
   */
  export type WorkshopTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkshopTag to update in case it exists.
     */
    where: WorkshopTagWhereUniqueInput
    /**
     * In case the WorkshopTag found by the `where` argument doesn't exist, create a new WorkshopTag with this data.
     */
    create: XOR<WorkshopTagCreateInput, WorkshopTagUncheckedCreateInput>
    /**
     * In case the WorkshopTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkshopTagUpdateInput, WorkshopTagUncheckedUpdateInput>
  }

  /**
   * WorkshopTag delete
   */
  export type WorkshopTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagInclude<ExtArgs> | null
    /**
     * Filter which WorkshopTag to delete.
     */
    where: WorkshopTagWhereUniqueInput
  }

  /**
   * WorkshopTag deleteMany
   */
  export type WorkshopTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopTags to delete
     */
    where?: WorkshopTagWhereInput
    /**
     * Limit how many WorkshopTags to delete.
     */
    limit?: number
  }

  /**
   * WorkshopTag without action
   */
  export type WorkshopTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTag
     */
    select?: WorkshopTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTag
     */
    omit?: WorkshopTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTagInclude<ExtArgs> | null
  }


  /**
   * Model LearningPathTag
   */

  export type AggregateLearningPathTag = {
    _count: LearningPathTagCountAggregateOutputType | null
    _min: LearningPathTagMinAggregateOutputType | null
    _max: LearningPathTagMaxAggregateOutputType | null
  }

  export type LearningPathTagMinAggregateOutputType = {
    learningPathId: string | null
    tagId: string | null
  }

  export type LearningPathTagMaxAggregateOutputType = {
    learningPathId: string | null
    tagId: string | null
  }

  export type LearningPathTagCountAggregateOutputType = {
    learningPathId: number
    tagId: number
    _all: number
  }


  export type LearningPathTagMinAggregateInputType = {
    learningPathId?: true
    tagId?: true
  }

  export type LearningPathTagMaxAggregateInputType = {
    learningPathId?: true
    tagId?: true
  }

  export type LearningPathTagCountAggregateInputType = {
    learningPathId?: true
    tagId?: true
    _all?: true
  }

  export type LearningPathTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPathTag to aggregate.
     */
    where?: LearningPathTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathTags to fetch.
     */
    orderBy?: LearningPathTagOrderByWithRelationInput | LearningPathTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningPathTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningPathTags
    **/
    _count?: true | LearningPathTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningPathTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningPathTagMaxAggregateInputType
  }

  export type GetLearningPathTagAggregateType<T extends LearningPathTagAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningPathTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningPathTag[P]>
      : GetScalarType<T[P], AggregateLearningPathTag[P]>
  }




  export type LearningPathTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathTagWhereInput
    orderBy?: LearningPathTagOrderByWithAggregationInput | LearningPathTagOrderByWithAggregationInput[]
    by: LearningPathTagScalarFieldEnum[] | LearningPathTagScalarFieldEnum
    having?: LearningPathTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningPathTagCountAggregateInputType | true
    _min?: LearningPathTagMinAggregateInputType
    _max?: LearningPathTagMaxAggregateInputType
  }

  export type LearningPathTagGroupByOutputType = {
    learningPathId: string
    tagId: string
    _count: LearningPathTagCountAggregateOutputType | null
    _min: LearningPathTagMinAggregateOutputType | null
    _max: LearningPathTagMaxAggregateOutputType | null
  }

  type GetLearningPathTagGroupByPayload<T extends LearningPathTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningPathTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningPathTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningPathTagGroupByOutputType[P]>
            : GetScalarType<T[P], LearningPathTagGroupByOutputType[P]>
        }
      >
    >


  export type LearningPathTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learningPathId?: boolean
    tagId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathTag"]>

  export type LearningPathTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learningPathId?: boolean
    tagId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathTag"]>

  export type LearningPathTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learningPathId?: boolean
    tagId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathTag"]>

  export type LearningPathTagSelectScalar = {
    learningPathId?: boolean
    tagId?: boolean
  }

  export type LearningPathTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"learningPathId" | "tagId", ExtArgs["result"]["learningPathTag"]>
  export type LearningPathTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type LearningPathTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type LearningPathTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $LearningPathTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningPathTag"
    objects: {
      learningPath: Prisma.$LearningPathPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      learningPathId: string
      tagId: string
    }, ExtArgs["result"]["learningPathTag"]>
    composites: {}
  }

  type LearningPathTagGetPayload<S extends boolean | null | undefined | LearningPathTagDefaultArgs> = $Result.GetResult<Prisma.$LearningPathTagPayload, S>

  type LearningPathTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningPathTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningPathTagCountAggregateInputType | true
    }

  export interface LearningPathTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningPathTag'], meta: { name: 'LearningPathTag' } }
    /**
     * Find zero or one LearningPathTag that matches the filter.
     * @param {LearningPathTagFindUniqueArgs} args - Arguments to find a LearningPathTag
     * @example
     * // Get one LearningPathTag
     * const learningPathTag = await prisma.learningPathTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningPathTagFindUniqueArgs>(args: SelectSubset<T, LearningPathTagFindUniqueArgs<ExtArgs>>): Prisma__LearningPathTagClient<$Result.GetResult<Prisma.$LearningPathTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LearningPathTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningPathTagFindUniqueOrThrowArgs} args - Arguments to find a LearningPathTag
     * @example
     * // Get one LearningPathTag
     * const learningPathTag = await prisma.learningPathTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningPathTagFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningPathTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningPathTagClient<$Result.GetResult<Prisma.$LearningPathTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningPathTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathTagFindFirstArgs} args - Arguments to find a LearningPathTag
     * @example
     * // Get one LearningPathTag
     * const learningPathTag = await prisma.learningPathTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningPathTagFindFirstArgs>(args?: SelectSubset<T, LearningPathTagFindFirstArgs<ExtArgs>>): Prisma__LearningPathTagClient<$Result.GetResult<Prisma.$LearningPathTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningPathTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathTagFindFirstOrThrowArgs} args - Arguments to find a LearningPathTag
     * @example
     * // Get one LearningPathTag
     * const learningPathTag = await prisma.learningPathTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningPathTagFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningPathTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningPathTagClient<$Result.GetResult<Prisma.$LearningPathTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LearningPathTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningPathTags
     * const learningPathTags = await prisma.learningPathTag.findMany()
     * 
     * // Get first 10 LearningPathTags
     * const learningPathTags = await prisma.learningPathTag.findMany({ take: 10 })
     * 
     * // Only select the `learningPathId`
     * const learningPathTagWithLearningPathIdOnly = await prisma.learningPathTag.findMany({ select: { learningPathId: true } })
     * 
     */
    findMany<T extends LearningPathTagFindManyArgs>(args?: SelectSubset<T, LearningPathTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LearningPathTag.
     * @param {LearningPathTagCreateArgs} args - Arguments to create a LearningPathTag.
     * @example
     * // Create one LearningPathTag
     * const LearningPathTag = await prisma.learningPathTag.create({
     *   data: {
     *     // ... data to create a LearningPathTag
     *   }
     * })
     * 
     */
    create<T extends LearningPathTagCreateArgs>(args: SelectSubset<T, LearningPathTagCreateArgs<ExtArgs>>): Prisma__LearningPathTagClient<$Result.GetResult<Prisma.$LearningPathTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LearningPathTags.
     * @param {LearningPathTagCreateManyArgs} args - Arguments to create many LearningPathTags.
     * @example
     * // Create many LearningPathTags
     * const learningPathTag = await prisma.learningPathTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningPathTagCreateManyArgs>(args?: SelectSubset<T, LearningPathTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningPathTags and returns the data saved in the database.
     * @param {LearningPathTagCreateManyAndReturnArgs} args - Arguments to create many LearningPathTags.
     * @example
     * // Create many LearningPathTags
     * const learningPathTag = await prisma.learningPathTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningPathTags and only return the `learningPathId`
     * const learningPathTagWithLearningPathIdOnly = await prisma.learningPathTag.createManyAndReturn({
     *   select: { learningPathId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningPathTagCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningPathTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LearningPathTag.
     * @param {LearningPathTagDeleteArgs} args - Arguments to delete one LearningPathTag.
     * @example
     * // Delete one LearningPathTag
     * const LearningPathTag = await prisma.learningPathTag.delete({
     *   where: {
     *     // ... filter to delete one LearningPathTag
     *   }
     * })
     * 
     */
    delete<T extends LearningPathTagDeleteArgs>(args: SelectSubset<T, LearningPathTagDeleteArgs<ExtArgs>>): Prisma__LearningPathTagClient<$Result.GetResult<Prisma.$LearningPathTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LearningPathTag.
     * @param {LearningPathTagUpdateArgs} args - Arguments to update one LearningPathTag.
     * @example
     * // Update one LearningPathTag
     * const learningPathTag = await prisma.learningPathTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningPathTagUpdateArgs>(args: SelectSubset<T, LearningPathTagUpdateArgs<ExtArgs>>): Prisma__LearningPathTagClient<$Result.GetResult<Prisma.$LearningPathTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LearningPathTags.
     * @param {LearningPathTagDeleteManyArgs} args - Arguments to filter LearningPathTags to delete.
     * @example
     * // Delete a few LearningPathTags
     * const { count } = await prisma.learningPathTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningPathTagDeleteManyArgs>(args?: SelectSubset<T, LearningPathTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPathTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningPathTags
     * const learningPathTag = await prisma.learningPathTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningPathTagUpdateManyArgs>(args: SelectSubset<T, LearningPathTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPathTags and returns the data updated in the database.
     * @param {LearningPathTagUpdateManyAndReturnArgs} args - Arguments to update many LearningPathTags.
     * @example
     * // Update many LearningPathTags
     * const learningPathTag = await prisma.learningPathTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningPathTags and only return the `learningPathId`
     * const learningPathTagWithLearningPathIdOnly = await prisma.learningPathTag.updateManyAndReturn({
     *   select: { learningPathId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningPathTagUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningPathTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LearningPathTag.
     * @param {LearningPathTagUpsertArgs} args - Arguments to update or create a LearningPathTag.
     * @example
     * // Update or create a LearningPathTag
     * const learningPathTag = await prisma.learningPathTag.upsert({
     *   create: {
     *     // ... data to create a LearningPathTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningPathTag we want to update
     *   }
     * })
     */
    upsert<T extends LearningPathTagUpsertArgs>(args: SelectSubset<T, LearningPathTagUpsertArgs<ExtArgs>>): Prisma__LearningPathTagClient<$Result.GetResult<Prisma.$LearningPathTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LearningPathTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathTagCountArgs} args - Arguments to filter LearningPathTags to count.
     * @example
     * // Count the number of LearningPathTags
     * const count = await prisma.learningPathTag.count({
     *   where: {
     *     // ... the filter for the LearningPathTags we want to count
     *   }
     * })
    **/
    count<T extends LearningPathTagCountArgs>(
      args?: Subset<T, LearningPathTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningPathTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningPathTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningPathTagAggregateArgs>(args: Subset<T, LearningPathTagAggregateArgs>): Prisma.PrismaPromise<GetLearningPathTagAggregateType<T>>

    /**
     * Group by LearningPathTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningPathTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningPathTagGroupByArgs['orderBy'] }
        : { orderBy?: LearningPathTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningPathTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningPathTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningPathTag model
   */
  readonly fields: LearningPathTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningPathTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningPathTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learningPath<T extends LearningPathDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathDefaultArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningPathTag model
   */
  interface LearningPathTagFieldRefs {
    readonly learningPathId: FieldRef<"LearningPathTag", 'String'>
    readonly tagId: FieldRef<"LearningPathTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LearningPathTag findUnique
   */
  export type LearningPathTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathTag to fetch.
     */
    where: LearningPathTagWhereUniqueInput
  }

  /**
   * LearningPathTag findUniqueOrThrow
   */
  export type LearningPathTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathTag to fetch.
     */
    where: LearningPathTagWhereUniqueInput
  }

  /**
   * LearningPathTag findFirst
   */
  export type LearningPathTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathTag to fetch.
     */
    where?: LearningPathTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathTags to fetch.
     */
    orderBy?: LearningPathTagOrderByWithRelationInput | LearningPathTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPathTags.
     */
    cursor?: LearningPathTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPathTags.
     */
    distinct?: LearningPathTagScalarFieldEnum | LearningPathTagScalarFieldEnum[]
  }

  /**
   * LearningPathTag findFirstOrThrow
   */
  export type LearningPathTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathTag to fetch.
     */
    where?: LearningPathTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathTags to fetch.
     */
    orderBy?: LearningPathTagOrderByWithRelationInput | LearningPathTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPathTags.
     */
    cursor?: LearningPathTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPathTags.
     */
    distinct?: LearningPathTagScalarFieldEnum | LearningPathTagScalarFieldEnum[]
  }

  /**
   * LearningPathTag findMany
   */
  export type LearningPathTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathTags to fetch.
     */
    where?: LearningPathTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathTags to fetch.
     */
    orderBy?: LearningPathTagOrderByWithRelationInput | LearningPathTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningPathTags.
     */
    cursor?: LearningPathTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathTags.
     */
    skip?: number
    distinct?: LearningPathTagScalarFieldEnum | LearningPathTagScalarFieldEnum[]
  }

  /**
   * LearningPathTag create
   */
  export type LearningPathTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningPathTag.
     */
    data: XOR<LearningPathTagCreateInput, LearningPathTagUncheckedCreateInput>
  }

  /**
   * LearningPathTag createMany
   */
  export type LearningPathTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningPathTags.
     */
    data: LearningPathTagCreateManyInput | LearningPathTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningPathTag createManyAndReturn
   */
  export type LearningPathTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * The data used to create many LearningPathTags.
     */
    data: LearningPathTagCreateManyInput | LearningPathTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPathTag update
   */
  export type LearningPathTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningPathTag.
     */
    data: XOR<LearningPathTagUpdateInput, LearningPathTagUncheckedUpdateInput>
    /**
     * Choose, which LearningPathTag to update.
     */
    where: LearningPathTagWhereUniqueInput
  }

  /**
   * LearningPathTag updateMany
   */
  export type LearningPathTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningPathTags.
     */
    data: XOR<LearningPathTagUpdateManyMutationInput, LearningPathTagUncheckedUpdateManyInput>
    /**
     * Filter which LearningPathTags to update
     */
    where?: LearningPathTagWhereInput
    /**
     * Limit how many LearningPathTags to update.
     */
    limit?: number
  }

  /**
   * LearningPathTag updateManyAndReturn
   */
  export type LearningPathTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * The data used to update LearningPathTags.
     */
    data: XOR<LearningPathTagUpdateManyMutationInput, LearningPathTagUncheckedUpdateManyInput>
    /**
     * Filter which LearningPathTags to update
     */
    where?: LearningPathTagWhereInput
    /**
     * Limit how many LearningPathTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPathTag upsert
   */
  export type LearningPathTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningPathTag to update in case it exists.
     */
    where: LearningPathTagWhereUniqueInput
    /**
     * In case the LearningPathTag found by the `where` argument doesn't exist, create a new LearningPathTag with this data.
     */
    create: XOR<LearningPathTagCreateInput, LearningPathTagUncheckedCreateInput>
    /**
     * In case the LearningPathTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningPathTagUpdateInput, LearningPathTagUncheckedUpdateInput>
  }

  /**
   * LearningPathTag delete
   */
  export type LearningPathTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagInclude<ExtArgs> | null
    /**
     * Filter which LearningPathTag to delete.
     */
    where: LearningPathTagWhereUniqueInput
  }

  /**
   * LearningPathTag deleteMany
   */
  export type LearningPathTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPathTags to delete
     */
    where?: LearningPathTagWhereInput
    /**
     * Limit how many LearningPathTags to delete.
     */
    limit?: number
  }

  /**
   * LearningPathTag without action
   */
  export type LearningPathTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathTag
     */
    select?: LearningPathTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathTag
     */
    omit?: LearningPathTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathTagInclude<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    discount: number | null
  }

  export type PromotionSumAggregateOutputType = {
    discount: number | null
  }

  export type PromotionMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    discount: number | null
    type: string | null
    startsAt: Date | null
    endsAt: Date | null
    active: boolean | null
    itemType: string | null
    courseId: string | null
    workshopId: string | null
    learningPathId: string | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    discount: number | null
    type: string | null
    startsAt: Date | null
    endsAt: Date | null
    active: boolean | null
    itemType: string | null
    courseId: string | null
    workshopId: string | null
    learningPathId: string | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    discount: number
    type: number
    startsAt: number
    endsAt: number
    active: number
    itemType: number
    courseId: number
    workshopId: number
    learningPathId: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    discount?: true
  }

  export type PromotionSumAggregateInputType = {
    discount?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    discount?: true
    type?: true
    startsAt?: true
    endsAt?: true
    active?: true
    itemType?: true
    courseId?: true
    workshopId?: true
    learningPathId?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    discount?: true
    type?: true
    startsAt?: true
    endsAt?: true
    active?: true
    itemType?: true
    courseId?: true
    workshopId?: true
    learningPathId?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    discount?: true
    type?: true
    startsAt?: true
    endsAt?: true
    active?: true
    itemType?: true
    courseId?: true
    workshopId?: true
    learningPathId?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: string
    title: string
    description: string | null
    discount: number
    type: string
    startsAt: Date
    endsAt: Date
    active: boolean
    itemType: string
    courseId: string | null
    workshopId: string | null
    learningPathId: string | null
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    discount?: boolean
    type?: boolean
    startsAt?: boolean
    endsAt?: boolean
    active?: boolean
    itemType?: boolean
    courseId?: boolean
    workshopId?: boolean
    learningPathId?: boolean
    course?: boolean | Promotion$courseArgs<ExtArgs>
    workshop?: boolean | Promotion$workshopArgs<ExtArgs>
    learningPath?: boolean | Promotion$learningPathArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    discount?: boolean
    type?: boolean
    startsAt?: boolean
    endsAt?: boolean
    active?: boolean
    itemType?: boolean
    courseId?: boolean
    workshopId?: boolean
    learningPathId?: boolean
    course?: boolean | Promotion$courseArgs<ExtArgs>
    workshop?: boolean | Promotion$workshopArgs<ExtArgs>
    learningPath?: boolean | Promotion$learningPathArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    discount?: boolean
    type?: boolean
    startsAt?: boolean
    endsAt?: boolean
    active?: boolean
    itemType?: boolean
    courseId?: boolean
    workshopId?: boolean
    learningPathId?: boolean
    course?: boolean | Promotion$courseArgs<ExtArgs>
    workshop?: boolean | Promotion$workshopArgs<ExtArgs>
    learningPath?: boolean | Promotion$learningPathArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    discount?: boolean
    type?: boolean
    startsAt?: boolean
    endsAt?: boolean
    active?: boolean
    itemType?: boolean
    courseId?: boolean
    workshopId?: boolean
    learningPathId?: boolean
  }

  export type PromotionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "discount" | "type" | "startsAt" | "endsAt" | "active" | "itemType" | "courseId" | "workshopId" | "learningPathId", ExtArgs["result"]["promotion"]>
  export type PromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Promotion$courseArgs<ExtArgs>
    workshop?: boolean | Promotion$workshopArgs<ExtArgs>
    learningPath?: boolean | Promotion$learningPathArgs<ExtArgs>
  }
  export type PromotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Promotion$courseArgs<ExtArgs>
    workshop?: boolean | Promotion$workshopArgs<ExtArgs>
    learningPath?: boolean | Promotion$learningPathArgs<ExtArgs>
  }
  export type PromotionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Promotion$courseArgs<ExtArgs>
    workshop?: boolean | Promotion$workshopArgs<ExtArgs>
    learningPath?: boolean | Promotion$learningPathArgs<ExtArgs>
  }

  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs> | null
      workshop: Prisma.$WorkshopPayload<ExtArgs> | null
      learningPath: Prisma.$LearningPathPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      discount: number
      type: string
      startsAt: Date
      endsAt: Date
      active: boolean
      itemType: string
      courseId: string | null
      workshopId: string | null
      learningPathId: string | null
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Promotions and returns the data saved in the database.
     * @param {PromotionCreateManyAndReturnArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions and returns the data updated in the database.
     * @param {PromotionUpdateManyAndReturnArgs} args - Arguments to update many Promotions.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromotionUpdateManyAndReturnArgs>(args: SelectSubset<T, PromotionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends Promotion$courseArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workshop<T extends Promotion$workshopArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$workshopArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    learningPath<T extends Promotion$learningPathArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$learningPathArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'String'>
    readonly title: FieldRef<"Promotion", 'String'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly discount: FieldRef<"Promotion", 'Int'>
    readonly type: FieldRef<"Promotion", 'String'>
    readonly startsAt: FieldRef<"Promotion", 'DateTime'>
    readonly endsAt: FieldRef<"Promotion", 'DateTime'>
    readonly active: FieldRef<"Promotion", 'Boolean'>
    readonly itemType: FieldRef<"Promotion", 'String'>
    readonly courseId: FieldRef<"Promotion", 'String'>
    readonly workshopId: FieldRef<"Promotion", 'String'>
    readonly learningPathId: FieldRef<"Promotion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion createManyAndReturn
   */
  export type PromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion updateManyAndReturn
   */
  export type PromotionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to delete.
     */
    limit?: number
  }

  /**
   * Promotion.course
   */
  export type Promotion$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * Promotion.workshop
   */
  export type Promotion$workshopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    where?: WorkshopWhereInput
  }

  /**
   * Promotion.learningPath
   */
  export type Promotion$learningPathArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    where?: LearningPathWhereInput
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
  }


  /**
   * Model PromoCode
   */

  export type AggregatePromoCode = {
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  export type PromoCodeAvgAggregateOutputType = {
    discount: number | null
    usageLimit: number | null
    usedCount: number | null
  }

  export type PromoCodeSumAggregateOutputType = {
    discount: number | null
    usageLimit: number | null
    usedCount: number | null
  }

  export type PromoCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    discount: number | null
    type: string | null
    usageLimit: number | null
    usedCount: number | null
    startsAt: Date | null
    endsAt: Date | null
    active: boolean | null
  }

  export type PromoCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    discount: number | null
    type: string | null
    usageLimit: number | null
    usedCount: number | null
    startsAt: Date | null
    endsAt: Date | null
    active: boolean | null
  }

  export type PromoCodeCountAggregateOutputType = {
    id: number
    code: number
    description: number
    discount: number
    type: number
    usageLimit: number
    usedCount: number
    startsAt: number
    endsAt: number
    active: number
    _all: number
  }


  export type PromoCodeAvgAggregateInputType = {
    discount?: true
    usageLimit?: true
    usedCount?: true
  }

  export type PromoCodeSumAggregateInputType = {
    discount?: true
    usageLimit?: true
    usedCount?: true
  }

  export type PromoCodeMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discount?: true
    type?: true
    usageLimit?: true
    usedCount?: true
    startsAt?: true
    endsAt?: true
    active?: true
  }

  export type PromoCodeMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discount?: true
    type?: true
    usageLimit?: true
    usedCount?: true
    startsAt?: true
    endsAt?: true
    active?: true
  }

  export type PromoCodeCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discount?: true
    type?: true
    usageLimit?: true
    usedCount?: true
    startsAt?: true
    endsAt?: true
    active?: true
    _all?: true
  }

  export type PromoCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCode to aggregate.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoCodes
    **/
    _count?: true | PromoCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromoCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromoCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoCodeMaxAggregateInputType
  }

  export type GetPromoCodeAggregateType<T extends PromoCodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCode[P]>
      : GetScalarType<T[P], AggregatePromoCode[P]>
  }




  export type PromoCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithAggregationInput | PromoCodeOrderByWithAggregationInput[]
    by: PromoCodeScalarFieldEnum[] | PromoCodeScalarFieldEnum
    having?: PromoCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoCodeCountAggregateInputType | true
    _avg?: PromoCodeAvgAggregateInputType
    _sum?: PromoCodeSumAggregateInputType
    _min?: PromoCodeMinAggregateInputType
    _max?: PromoCodeMaxAggregateInputType
  }

  export type PromoCodeGroupByOutputType = {
    id: string
    code: string
    description: string | null
    discount: number
    type: string
    usageLimit: number | null
    usedCount: number
    startsAt: Date
    endsAt: Date
    active: boolean
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  type GetPromoCodeGroupByPayload<T extends PromoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
            : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
        }
      >
    >


  export type PromoCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discount?: boolean
    type?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    startsAt?: boolean
    endsAt?: boolean
    active?: boolean
    applicableCourses?: boolean | PromoCode$applicableCoursesArgs<ExtArgs>
    applicableWorkshops?: boolean | PromoCode$applicableWorkshopsArgs<ExtArgs>
    applicableLearningPaths?: boolean | PromoCode$applicableLearningPathsArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discount?: boolean
    type?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    startsAt?: boolean
    endsAt?: boolean
    active?: boolean
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discount?: boolean
    type?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    startsAt?: boolean
    endsAt?: boolean
    active?: boolean
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    discount?: boolean
    type?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    startsAt?: boolean
    endsAt?: boolean
    active?: boolean
  }

  export type PromoCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "discount" | "type" | "usageLimit" | "usedCount" | "startsAt" | "endsAt" | "active", ExtArgs["result"]["promoCode"]>
  export type PromoCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicableCourses?: boolean | PromoCode$applicableCoursesArgs<ExtArgs>
    applicableWorkshops?: boolean | PromoCode$applicableWorkshopsArgs<ExtArgs>
    applicableLearningPaths?: boolean | PromoCode$applicableLearningPathsArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromoCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PromoCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromoCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoCode"
    objects: {
      applicableCourses: Prisma.$CoursePayload<ExtArgs>[]
      applicableWorkshops: Prisma.$WorkshopPayload<ExtArgs>[]
      applicableLearningPaths: Prisma.$LearningPathPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      discount: number
      type: string
      usageLimit: number | null
      usedCount: number
      startsAt: Date
      endsAt: Date
      active: boolean
    }, ExtArgs["result"]["promoCode"]>
    composites: {}
  }

  type PromoCodeGetPayload<S extends boolean | null | undefined | PromoCodeDefaultArgs> = $Result.GetResult<Prisma.$PromoCodePayload, S>

  type PromoCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromoCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromoCodeCountAggregateInputType | true
    }

  export interface PromoCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoCode'], meta: { name: 'PromoCode' } }
    /**
     * Find zero or one PromoCode that matches the filter.
     * @param {PromoCodeFindUniqueArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoCodeFindUniqueArgs>(args: SelectSubset<T, PromoCodeFindUniqueArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromoCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromoCodeFindUniqueOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoCodeFindFirstArgs>(args?: SelectSubset<T, PromoCodeFindFirstArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodes
     * const promoCodes = await prisma.promoCode.findMany()
     * 
     * // Get first 10 PromoCodes
     * const promoCodes = await prisma.promoCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoCodeFindManyArgs>(args?: SelectSubset<T, PromoCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromoCode.
     * @param {PromoCodeCreateArgs} args - Arguments to create a PromoCode.
     * @example
     * // Create one PromoCode
     * const PromoCode = await prisma.promoCode.create({
     *   data: {
     *     // ... data to create a PromoCode
     *   }
     * })
     * 
     */
    create<T extends PromoCodeCreateArgs>(args: SelectSubset<T, PromoCodeCreateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromoCodes.
     * @param {PromoCodeCreateManyArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoCodeCreateManyArgs>(args?: SelectSubset<T, PromoCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromoCodes and returns the data saved in the database.
     * @param {PromoCodeCreateManyAndReturnArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromoCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, PromoCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromoCode.
     * @param {PromoCodeDeleteArgs} args - Arguments to delete one PromoCode.
     * @example
     * // Delete one PromoCode
     * const PromoCode = await prisma.promoCode.delete({
     *   where: {
     *     // ... filter to delete one PromoCode
     *   }
     * })
     * 
     */
    delete<T extends PromoCodeDeleteArgs>(args: SelectSubset<T, PromoCodeDeleteArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromoCode.
     * @param {PromoCodeUpdateArgs} args - Arguments to update one PromoCode.
     * @example
     * // Update one PromoCode
     * const promoCode = await prisma.promoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoCodeUpdateArgs>(args: SelectSubset<T, PromoCodeUpdateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromoCodes.
     * @param {PromoCodeDeleteManyArgs} args - Arguments to filter PromoCodes to delete.
     * @example
     * // Delete a few PromoCodes
     * const { count } = await prisma.promoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoCodeDeleteManyArgs>(args?: SelectSubset<T, PromoCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoCodeUpdateManyArgs>(args: SelectSubset<T, PromoCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes and returns the data updated in the database.
     * @param {PromoCodeUpdateManyAndReturnArgs} args - Arguments to update many PromoCodes.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromoCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, PromoCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromoCode.
     * @param {PromoCodeUpsertArgs} args - Arguments to update or create a PromoCode.
     * @example
     * // Update or create a PromoCode
     * const promoCode = await prisma.promoCode.upsert({
     *   create: {
     *     // ... data to create a PromoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCode we want to update
     *   }
     * })
     */
    upsert<T extends PromoCodeUpsertArgs>(args: SelectSubset<T, PromoCodeUpsertArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeCountArgs} args - Arguments to filter PromoCodes to count.
     * @example
     * // Count the number of PromoCodes
     * const count = await prisma.promoCode.count({
     *   where: {
     *     // ... the filter for the PromoCodes we want to count
     *   }
     * })
    **/
    count<T extends PromoCodeCountArgs>(
      args?: Subset<T, PromoCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoCodeAggregateArgs>(args: Subset<T, PromoCodeAggregateArgs>): Prisma.PrismaPromise<GetPromoCodeAggregateType<T>>

    /**
     * Group by PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoCode model
   */
  readonly fields: PromoCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicableCourses<T extends PromoCode$applicableCoursesArgs<ExtArgs> = {}>(args?: Subset<T, PromoCode$applicableCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applicableWorkshops<T extends PromoCode$applicableWorkshopsArgs<ExtArgs> = {}>(args?: Subset<T, PromoCode$applicableWorkshopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applicableLearningPaths<T extends PromoCode$applicableLearningPathsArgs<ExtArgs> = {}>(args?: Subset<T, PromoCode$applicableLearningPathsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoCode model
   */
  interface PromoCodeFieldRefs {
    readonly id: FieldRef<"PromoCode", 'String'>
    readonly code: FieldRef<"PromoCode", 'String'>
    readonly description: FieldRef<"PromoCode", 'String'>
    readonly discount: FieldRef<"PromoCode", 'Int'>
    readonly type: FieldRef<"PromoCode", 'String'>
    readonly usageLimit: FieldRef<"PromoCode", 'Int'>
    readonly usedCount: FieldRef<"PromoCode", 'Int'>
    readonly startsAt: FieldRef<"PromoCode", 'DateTime'>
    readonly endsAt: FieldRef<"PromoCode", 'DateTime'>
    readonly active: FieldRef<"PromoCode", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PromoCode findUnique
   */
  export type PromoCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findUniqueOrThrow
   */
  export type PromoCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findFirst
   */
  export type PromoCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findFirstOrThrow
   */
  export type PromoCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findMany
   */
  export type PromoCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodes to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode create
   */
  export type PromoCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoCode.
     */
    data: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
  }

  /**
   * PromoCode createMany
   */
  export type PromoCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCode createManyAndReturn
   */
  export type PromoCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCode update
   */
  export type PromoCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoCode.
     */
    data: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
    /**
     * Choose, which PromoCode to update.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode updateMany
   */
  export type PromoCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to update.
     */
    limit?: number
  }

  /**
   * PromoCode updateManyAndReturn
   */
  export type PromoCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to update.
     */
    limit?: number
  }

  /**
   * PromoCode upsert
   */
  export type PromoCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoCode to update in case it exists.
     */
    where: PromoCodeWhereUniqueInput
    /**
     * In case the PromoCode found by the `where` argument doesn't exist, create a new PromoCode with this data.
     */
    create: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
    /**
     * In case the PromoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
  }

  /**
   * PromoCode delete
   */
  export type PromoCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter which PromoCode to delete.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode deleteMany
   */
  export type PromoCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodes to delete
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to delete.
     */
    limit?: number
  }

  /**
   * PromoCode.applicableCourses
   */
  export type PromoCode$applicableCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * PromoCode.applicableWorkshops
   */
  export type PromoCode$applicableWorkshopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    where?: WorkshopWhereInput
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    cursor?: WorkshopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopScalarFieldEnum | WorkshopScalarFieldEnum[]
  }

  /**
   * PromoCode.applicableLearningPaths
   */
  export type PromoCode$applicableLearningPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    where?: LearningPathWhereInput
    orderBy?: LearningPathOrderByWithRelationInput | LearningPathOrderByWithRelationInput[]
    cursor?: LearningPathWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathScalarFieldEnum | LearningPathScalarFieldEnum[]
  }

  /**
   * PromoCode without action
   */
  export type PromoCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
  }


  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentAvgAggregateOutputType = {
    amount: number | null
  }

  export type EnrollmentSumAggregateOutputType = {
    amount: number | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: string | null
    amount: number | null
    status: $Enums.enrollmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    courseId: string | null
    learningPathId: string | null
    workshopId: string | null
    userId: string | null
    paymentId: string | null
    deletedAt: Date | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    status: $Enums.enrollmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    courseId: string | null
    learningPathId: string | null
    workshopId: string | null
    userId: string | null
    paymentId: string | null
    deletedAt: Date | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    courseId: number
    learningPathId: number
    workshopId: number
    userId: number
    paymentId: number
    deletedAt: number
    _all: number
  }


  export type EnrollmentAvgAggregateInputType = {
    amount?: true
  }

  export type EnrollmentSumAggregateInputType = {
    amount?: true
  }

  export type EnrollmentMinAggregateInputType = {
    id?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    courseId?: true
    learningPathId?: true
    workshopId?: true
    userId?: true
    paymentId?: true
    deletedAt?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    courseId?: true
    learningPathId?: true
    workshopId?: true
    userId?: true
    paymentId?: true
    deletedAt?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    courseId?: true
    learningPathId?: true
    workshopId?: true
    userId?: true
    paymentId?: true
    deletedAt?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithAggregationInput | EnrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: EnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _avg?: EnrollmentAvgAggregateInputType
    _sum?: EnrollmentSumAggregateInputType
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: string
    amount: number
    status: $Enums.enrollmentStatus
    createdAt: Date
    updatedAt: Date
    courseId: string | null
    learningPathId: string | null
    workshopId: string | null
    userId: string
    paymentId: string | null
    deletedAt: Date | null
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    learningPathId?: boolean
    workshopId?: boolean
    userId?: boolean
    paymentId?: boolean
    deletedAt?: boolean
    course?: boolean | Enrollment$courseArgs<ExtArgs>
    learningPath?: boolean | Enrollment$learningPathArgs<ExtArgs>
    workshop?: boolean | Enrollment$workshopArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Enrollment$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    learningPathId?: boolean
    workshopId?: boolean
    userId?: boolean
    paymentId?: boolean
    deletedAt?: boolean
    course?: boolean | Enrollment$courseArgs<ExtArgs>
    learningPath?: boolean | Enrollment$learningPathArgs<ExtArgs>
    workshop?: boolean | Enrollment$workshopArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Enrollment$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    learningPathId?: boolean
    workshopId?: boolean
    userId?: boolean
    paymentId?: boolean
    deletedAt?: boolean
    course?: boolean | Enrollment$courseArgs<ExtArgs>
    learningPath?: boolean | Enrollment$learningPathArgs<ExtArgs>
    workshop?: boolean | Enrollment$workshopArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Enrollment$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectScalar = {
    id?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    learningPathId?: boolean
    workshopId?: boolean
    userId?: boolean
    paymentId?: boolean
    deletedAt?: boolean
  }

  export type EnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "status" | "createdAt" | "updatedAt" | "courseId" | "learningPathId" | "workshopId" | "userId" | "paymentId" | "deletedAt", ExtArgs["result"]["enrollment"]>
  export type EnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Enrollment$courseArgs<ExtArgs>
    learningPath?: boolean | Enrollment$learningPathArgs<ExtArgs>
    workshop?: boolean | Enrollment$workshopArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Enrollment$paymentArgs<ExtArgs>
  }
  export type EnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Enrollment$courseArgs<ExtArgs>
    learningPath?: boolean | Enrollment$learningPathArgs<ExtArgs>
    workshop?: boolean | Enrollment$workshopArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Enrollment$paymentArgs<ExtArgs>
  }
  export type EnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Enrollment$courseArgs<ExtArgs>
    learningPath?: boolean | Enrollment$learningPathArgs<ExtArgs>
    workshop?: boolean | Enrollment$workshopArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Enrollment$paymentArgs<ExtArgs>
  }

  export type $EnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollment"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs> | null
      learningPath: Prisma.$LearningPathPayload<ExtArgs> | null
      workshop: Prisma.$WorkshopPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      status: $Enums.enrollmentStatus
      createdAt: Date
      updatedAt: Date
      courseId: string | null
      learningPathId: string | null
      workshopId: string | null
      userId: string
      paymentId: string | null
      deletedAt: Date | null
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type EnrollmentGetPayload<S extends boolean | null | undefined | EnrollmentDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentPayload, S>

  type EnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface EnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'], meta: { name: 'Enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentFindManyArgs>(args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends EnrollmentCreateArgs>(args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentCreateManyArgs>(args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enrollments and returns the data saved in the database.
     * @param {EnrollmentCreateManyAndReturnArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentDeleteArgs>(args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentUpdateArgs>(args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments and returns the data updated in the database.
     * @param {EnrollmentUpdateManyAndReturnArgs} args - Arguments to update many Enrollments.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollment model
   */
  readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends Enrollment$courseArgs<ExtArgs> = {}>(args?: Subset<T, Enrollment$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    learningPath<T extends Enrollment$learningPathArgs<ExtArgs> = {}>(args?: Subset<T, Enrollment$learningPathArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workshop<T extends Enrollment$workshopArgs<ExtArgs> = {}>(args?: Subset<T, Enrollment$workshopArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment<T extends Enrollment$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Enrollment$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enrollment model
   */
  interface EnrollmentFieldRefs {
    readonly id: FieldRef<"Enrollment", 'String'>
    readonly amount: FieldRef<"Enrollment", 'Int'>
    readonly status: FieldRef<"Enrollment", 'enrollmentStatus'>
    readonly createdAt: FieldRef<"Enrollment", 'DateTime'>
    readonly updatedAt: FieldRef<"Enrollment", 'DateTime'>
    readonly courseId: FieldRef<"Enrollment", 'String'>
    readonly learningPathId: FieldRef<"Enrollment", 'String'>
    readonly workshopId: FieldRef<"Enrollment", 'String'>
    readonly userId: FieldRef<"Enrollment", 'String'>
    readonly paymentId: FieldRef<"Enrollment", 'String'>
    readonly deletedAt: FieldRef<"Enrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
  }

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enrollment createManyAndReturn
   */
  export type EnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
  }

  /**
   * Enrollment updateManyAndReturn
   */
  export type EnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
  }

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to delete.
     */
    limit?: number
  }

  /**
   * Enrollment.course
   */
  export type Enrollment$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * Enrollment.learningPath
   */
  export type Enrollment$learningPathArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    where?: LearningPathWhereInput
  }

  /**
   * Enrollment.workshop
   */
  export type Enrollment$workshopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    where?: WorkshopWhereInput
  }

  /**
   * Enrollment.payment
   */
  export type Enrollment$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    stripeId: string | null
    userId: string | null
    courseId: string | null
    learningPathId: string | null
    workshopId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    method: string | null
    receiptUrl: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    stripeId: string | null
    userId: string | null
    courseId: string | null
    learningPathId: string | null
    workshopId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    method: string | null
    receiptUrl: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    stripeId: number
    userId: number
    courseId: number
    learningPathId: number
    workshopId: number
    amount: number
    currency: number
    status: number
    method: number
    receiptUrl: number
    createdAt: number
    deletedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    stripeId?: true
    userId?: true
    courseId?: true
    learningPathId?: true
    workshopId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    receiptUrl?: true
    createdAt?: true
    deletedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    stripeId?: true
    userId?: true
    courseId?: true
    learningPathId?: true
    workshopId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    receiptUrl?: true
    createdAt?: true
    deletedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    stripeId?: true
    userId?: true
    courseId?: true
    learningPathId?: true
    workshopId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    receiptUrl?: true
    createdAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    stripeId: string
    userId: string
    courseId: string | null
    learningPathId: string | null
    workshopId: string | null
    amount: number
    currency: string
    status: string
    method: string | null
    receiptUrl: string | null
    createdAt: Date
    deletedAt: Date | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripeId?: boolean
    userId?: boolean
    courseId?: boolean
    learningPathId?: boolean
    workshopId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    receiptUrl?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Payment$courseArgs<ExtArgs>
    learningPath?: boolean | Payment$learningPathArgs<ExtArgs>
    workshop?: boolean | Payment$workshopArgs<ExtArgs>
    enrollment?: boolean | Payment$enrollmentArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripeId?: boolean
    userId?: boolean
    courseId?: boolean
    learningPathId?: boolean
    workshopId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    receiptUrl?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Payment$courseArgs<ExtArgs>
    learningPath?: boolean | Payment$learningPathArgs<ExtArgs>
    workshop?: boolean | Payment$workshopArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripeId?: boolean
    userId?: boolean
    courseId?: boolean
    learningPathId?: boolean
    workshopId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    receiptUrl?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Payment$courseArgs<ExtArgs>
    learningPath?: boolean | Payment$learningPathArgs<ExtArgs>
    workshop?: boolean | Payment$workshopArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    stripeId?: boolean
    userId?: boolean
    courseId?: boolean
    learningPathId?: boolean
    workshopId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    receiptUrl?: boolean
    createdAt?: boolean
    deletedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stripeId" | "userId" | "courseId" | "learningPathId" | "workshopId" | "amount" | "currency" | "status" | "method" | "receiptUrl" | "createdAt" | "deletedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Payment$courseArgs<ExtArgs>
    learningPath?: boolean | Payment$learningPathArgs<ExtArgs>
    workshop?: boolean | Payment$workshopArgs<ExtArgs>
    enrollment?: boolean | Payment$enrollmentArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Payment$courseArgs<ExtArgs>
    learningPath?: boolean | Payment$learningPathArgs<ExtArgs>
    workshop?: boolean | Payment$workshopArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Payment$courseArgs<ExtArgs>
    learningPath?: boolean | Payment$learningPathArgs<ExtArgs>
    workshop?: boolean | Payment$workshopArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs> | null
      learningPath: Prisma.$LearningPathPayload<ExtArgs> | null
      workshop: Prisma.$WorkshopPayload<ExtArgs> | null
      enrollment: Prisma.$EnrollmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stripeId: string
      userId: string
      courseId: string | null
      learningPathId: string | null
      workshopId: string | null
      amount: number
      currency: string
      status: string
      method: string | null
      receiptUrl: string | null
      createdAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends Payment$courseArgs<ExtArgs> = {}>(args?: Subset<T, Payment$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    learningPath<T extends Payment$learningPathArgs<ExtArgs> = {}>(args?: Subset<T, Payment$learningPathArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workshop<T extends Payment$workshopArgs<ExtArgs> = {}>(args?: Subset<T, Payment$workshopArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    enrollment<T extends Payment$enrollmentArgs<ExtArgs> = {}>(args?: Subset<T, Payment$enrollmentArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly stripeId: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly courseId: FieldRef<"Payment", 'String'>
    readonly learningPathId: FieldRef<"Payment", 'String'>
    readonly workshopId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Int'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly receiptUrl: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly deletedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.course
   */
  export type Payment$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * Payment.learningPath
   */
  export type Payment$learningPathArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    where?: LearningPathWhereInput
  }

  /**
   * Payment.workshop
   */
  export type Payment$workshopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    where?: WorkshopWhereInput
  }

  /**
   * Payment.enrollment
   */
  export type Payment$enrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    number: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    pdfUrl: string | null
    date: Date | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    number: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    pdfUrl: string | null
    date: Date | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    number: number
    userId: number
    amount: number
    currency: number
    pdfUrl: number
    date: number
    createdAt: number
    deletedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    number?: true
    userId?: true
    amount?: true
    currency?: true
    pdfUrl?: true
    date?: true
    createdAt?: true
    deletedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    number?: true
    userId?: true
    amount?: true
    currency?: true
    pdfUrl?: true
    date?: true
    createdAt?: true
    deletedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    number?: true
    userId?: true
    amount?: true
    currency?: true
    pdfUrl?: true
    date?: true
    createdAt?: true
    deletedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    number: string
    userId: string
    amount: number
    currency: string
    pdfUrl: string | null
    date: Date
    createdAt: Date
    deletedAt: Date | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    pdfUrl?: boolean
    date?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    pdfUrl?: boolean
    date?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    pdfUrl?: boolean
    date?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    number?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    pdfUrl?: boolean
    date?: boolean
    createdAt?: boolean
    deletedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "userId" | "amount" | "currency" | "pdfUrl" | "date" | "createdAt" | "deletedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: string
      userId: string
      amount: number
      currency: string
      pdfUrl: string | null
      date: Date
      createdAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly number: FieldRef<"Invoice", 'String'>
    readonly userId: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Int'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly pdfUrl: FieldRef<"Invoice", 'String'>
    readonly date: FieldRef<"Invoice", 'DateTime'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly deletedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    title: string | null
    type: string | null
    referenceId: string | null
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    title: string | null
    type: string | null
    referenceId: string | null
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    title: number
    type: number
    referenceId: number
    quantity: number
    unitPrice: number
    total: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    title?: true
    type?: true
    referenceId?: true
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    title?: true
    type?: true
    referenceId?: true
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    title?: true
    type?: true
    referenceId?: true
    quantity?: true
    unitPrice?: true
    total?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    title: string
    type: string
    referenceId: string
    quantity: number
    unitPrice: number
    total: number
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    title?: boolean
    type?: boolean
    referenceId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    title?: boolean
    type?: boolean
    referenceId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    title?: boolean
    type?: boolean
    referenceId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    title?: boolean
    type?: boolean
    referenceId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
  }

  export type InvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "title" | "type" | "referenceId" | "quantity" | "unitPrice" | "total", ExtArgs["result"]["invoiceItem"]>
  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      title: string
      type: string
      referenceId: string
      quantity: number
      unitPrice: number
      total: number
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems and returns the data updated in the database.
     * @param {InvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many InvoiceItems.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'String'>
    readonly title: FieldRef<"InvoiceItem", 'String'>
    readonly type: FieldRef<"InvoiceItem", 'String'>
    readonly referenceId: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Int'>
    readonly unitPrice: FieldRef<"InvoiceItem", 'Int'>
    readonly total: FieldRef<"InvoiceItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
  }

  /**
   * InvoiceItem updateManyAndReturn
   */
  export type InvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Objective
   */

  export type AggregateObjective = {
    _count: ObjectiveCountAggregateOutputType | null
    _min: ObjectiveMinAggregateOutputType | null
    _max: ObjectiveMaxAggregateOutputType | null
  }

  export type ObjectiveMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
  }

  export type ObjectiveMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
  }

  export type ObjectiveCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    _all: number
  }


  export type ObjectiveMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
  }

  export type ObjectiveMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
  }

  export type ObjectiveCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type ObjectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Objective to aggregate.
     */
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     */
    orderBy?: ObjectiveOrderByWithRelationInput | ObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Objectives
    **/
    _count?: true | ObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectiveMaxAggregateInputType
  }

  export type GetObjectiveAggregateType<T extends ObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjective[P]>
      : GetScalarType<T[P], AggregateObjective[P]>
  }




  export type ObjectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectiveWhereInput
    orderBy?: ObjectiveOrderByWithAggregationInput | ObjectiveOrderByWithAggregationInput[]
    by: ObjectiveScalarFieldEnum[] | ObjectiveScalarFieldEnum
    having?: ObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectiveCountAggregateInputType | true
    _min?: ObjectiveMinAggregateInputType
    _max?: ObjectiveMaxAggregateInputType
  }

  export type ObjectiveGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    _count: ObjectiveCountAggregateOutputType | null
    _min: ObjectiveMinAggregateOutputType | null
    _max: ObjectiveMaxAggregateOutputType | null
  }

  type GetObjectiveGroupByPayload<T extends ObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type ObjectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    courses?: boolean | Objective$coursesArgs<ExtArgs>
    workshops?: boolean | Objective$workshopsArgs<ExtArgs>
    learningPaths?: boolean | Objective$learningPathsArgs<ExtArgs>
    _count?: boolean | ObjectiveCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objective"]>

  export type ObjectiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["objective"]>

  export type ObjectiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["objective"]>

  export type ObjectiveSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type ObjectiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt", ExtArgs["result"]["objective"]>
  export type ObjectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | Objective$coursesArgs<ExtArgs>
    workshops?: boolean | Objective$workshopsArgs<ExtArgs>
    learningPaths?: boolean | Objective$learningPathsArgs<ExtArgs>
    _count?: boolean | ObjectiveCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ObjectiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ObjectiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ObjectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Objective"
    objects: {
      courses: Prisma.$CourseObjectivePayload<ExtArgs>[]
      workshops: Prisma.$WorkshopObjectivePayload<ExtArgs>[]
      learningPaths: Prisma.$LearningPathObjectivePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["objective"]>
    composites: {}
  }

  type ObjectiveGetPayload<S extends boolean | null | undefined | ObjectiveDefaultArgs> = $Result.GetResult<Prisma.$ObjectivePayload, S>

  type ObjectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ObjectiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ObjectiveCountAggregateInputType | true
    }

  export interface ObjectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Objective'], meta: { name: 'Objective' } }
    /**
     * Find zero or one Objective that matches the filter.
     * @param {ObjectiveFindUniqueArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObjectiveFindUniqueArgs>(args: SelectSubset<T, ObjectiveFindUniqueArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Objective that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ObjectiveFindUniqueOrThrowArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObjectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, ObjectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Objective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveFindFirstArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObjectiveFindFirstArgs>(args?: SelectSubset<T, ObjectiveFindFirstArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Objective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveFindFirstOrThrowArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObjectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, ObjectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Objectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Objectives
     * const objectives = await prisma.objective.findMany()
     * 
     * // Get first 10 Objectives
     * const objectives = await prisma.objective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectiveWithIdOnly = await prisma.objective.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObjectiveFindManyArgs>(args?: SelectSubset<T, ObjectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Objective.
     * @param {ObjectiveCreateArgs} args - Arguments to create a Objective.
     * @example
     * // Create one Objective
     * const Objective = await prisma.objective.create({
     *   data: {
     *     // ... data to create a Objective
     *   }
     * })
     * 
     */
    create<T extends ObjectiveCreateArgs>(args: SelectSubset<T, ObjectiveCreateArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Objectives.
     * @param {ObjectiveCreateManyArgs} args - Arguments to create many Objectives.
     * @example
     * // Create many Objectives
     * const objective = await prisma.objective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObjectiveCreateManyArgs>(args?: SelectSubset<T, ObjectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Objectives and returns the data saved in the database.
     * @param {ObjectiveCreateManyAndReturnArgs} args - Arguments to create many Objectives.
     * @example
     * // Create many Objectives
     * const objective = await prisma.objective.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Objectives and only return the `id`
     * const objectiveWithIdOnly = await prisma.objective.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ObjectiveCreateManyAndReturnArgs>(args?: SelectSubset<T, ObjectiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Objective.
     * @param {ObjectiveDeleteArgs} args - Arguments to delete one Objective.
     * @example
     * // Delete one Objective
     * const Objective = await prisma.objective.delete({
     *   where: {
     *     // ... filter to delete one Objective
     *   }
     * })
     * 
     */
    delete<T extends ObjectiveDeleteArgs>(args: SelectSubset<T, ObjectiveDeleteArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Objective.
     * @param {ObjectiveUpdateArgs} args - Arguments to update one Objective.
     * @example
     * // Update one Objective
     * const objective = await prisma.objective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObjectiveUpdateArgs>(args: SelectSubset<T, ObjectiveUpdateArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Objectives.
     * @param {ObjectiveDeleteManyArgs} args - Arguments to filter Objectives to delete.
     * @example
     * // Delete a few Objectives
     * const { count } = await prisma.objective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObjectiveDeleteManyArgs>(args?: SelectSubset<T, ObjectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Objectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Objectives
     * const objective = await prisma.objective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObjectiveUpdateManyArgs>(args: SelectSubset<T, ObjectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Objectives and returns the data updated in the database.
     * @param {ObjectiveUpdateManyAndReturnArgs} args - Arguments to update many Objectives.
     * @example
     * // Update many Objectives
     * const objective = await prisma.objective.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Objectives and only return the `id`
     * const objectiveWithIdOnly = await prisma.objective.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ObjectiveUpdateManyAndReturnArgs>(args: SelectSubset<T, ObjectiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Objective.
     * @param {ObjectiveUpsertArgs} args - Arguments to update or create a Objective.
     * @example
     * // Update or create a Objective
     * const objective = await prisma.objective.upsert({
     *   create: {
     *     // ... data to create a Objective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Objective we want to update
     *   }
     * })
     */
    upsert<T extends ObjectiveUpsertArgs>(args: SelectSubset<T, ObjectiveUpsertArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Objectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveCountArgs} args - Arguments to filter Objectives to count.
     * @example
     * // Count the number of Objectives
     * const count = await prisma.objective.count({
     *   where: {
     *     // ... the filter for the Objectives we want to count
     *   }
     * })
    **/
    count<T extends ObjectiveCountArgs>(
      args?: Subset<T, ObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Objective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectiveAggregateArgs>(args: Subset<T, ObjectiveAggregateArgs>): Prisma.PrismaPromise<GetObjectiveAggregateType<T>>

    /**
     * Group by Objective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: ObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Objective model
   */
  readonly fields: ObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Objective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends Objective$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Objective$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workshops<T extends Objective$workshopsArgs<ExtArgs> = {}>(args?: Subset<T, Objective$workshopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningPaths<T extends Objective$learningPathsArgs<ExtArgs> = {}>(args?: Subset<T, Objective$learningPathsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Objective model
   */
  interface ObjectiveFieldRefs {
    readonly id: FieldRef<"Objective", 'String'>
    readonly content: FieldRef<"Objective", 'String'>
    readonly createdAt: FieldRef<"Objective", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Objective findUnique
   */
  export type ObjectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which Objective to fetch.
     */
    where: ObjectiveWhereUniqueInput
  }

  /**
   * Objective findUniqueOrThrow
   */
  export type ObjectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which Objective to fetch.
     */
    where: ObjectiveWhereUniqueInput
  }

  /**
   * Objective findFirst
   */
  export type ObjectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which Objective to fetch.
     */
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     */
    orderBy?: ObjectiveOrderByWithRelationInput | ObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objectives.
     */
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objectives.
     */
    distinct?: ObjectiveScalarFieldEnum | ObjectiveScalarFieldEnum[]
  }

  /**
   * Objective findFirstOrThrow
   */
  export type ObjectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which Objective to fetch.
     */
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     */
    orderBy?: ObjectiveOrderByWithRelationInput | ObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objectives.
     */
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objectives.
     */
    distinct?: ObjectiveScalarFieldEnum | ObjectiveScalarFieldEnum[]
  }

  /**
   * Objective findMany
   */
  export type ObjectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which Objectives to fetch.
     */
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     */
    orderBy?: ObjectiveOrderByWithRelationInput | ObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Objectives.
     */
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     */
    skip?: number
    distinct?: ObjectiveScalarFieldEnum | ObjectiveScalarFieldEnum[]
  }

  /**
   * Objective create
   */
  export type ObjectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a Objective.
     */
    data: XOR<ObjectiveCreateInput, ObjectiveUncheckedCreateInput>
  }

  /**
   * Objective createMany
   */
  export type ObjectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Objectives.
     */
    data: ObjectiveCreateManyInput | ObjectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Objective createManyAndReturn
   */
  export type ObjectiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * The data used to create many Objectives.
     */
    data: ObjectiveCreateManyInput | ObjectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Objective update
   */
  export type ObjectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a Objective.
     */
    data: XOR<ObjectiveUpdateInput, ObjectiveUncheckedUpdateInput>
    /**
     * Choose, which Objective to update.
     */
    where: ObjectiveWhereUniqueInput
  }

  /**
   * Objective updateMany
   */
  export type ObjectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Objectives.
     */
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which Objectives to update
     */
    where?: ObjectiveWhereInput
    /**
     * Limit how many Objectives to update.
     */
    limit?: number
  }

  /**
   * Objective updateManyAndReturn
   */
  export type ObjectiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * The data used to update Objectives.
     */
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which Objectives to update
     */
    where?: ObjectiveWhereInput
    /**
     * Limit how many Objectives to update.
     */
    limit?: number
  }

  /**
   * Objective upsert
   */
  export type ObjectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the Objective to update in case it exists.
     */
    where: ObjectiveWhereUniqueInput
    /**
     * In case the Objective found by the `where` argument doesn't exist, create a new Objective with this data.
     */
    create: XOR<ObjectiveCreateInput, ObjectiveUncheckedCreateInput>
    /**
     * In case the Objective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectiveUpdateInput, ObjectiveUncheckedUpdateInput>
  }

  /**
   * Objective delete
   */
  export type ObjectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * Filter which Objective to delete.
     */
    where: ObjectiveWhereUniqueInput
  }

  /**
   * Objective deleteMany
   */
  export type ObjectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Objectives to delete
     */
    where?: ObjectiveWhereInput
    /**
     * Limit how many Objectives to delete.
     */
    limit?: number
  }

  /**
   * Objective.courses
   */
  export type Objective$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null
    where?: CourseObjectiveWhereInput
    orderBy?: CourseObjectiveOrderByWithRelationInput | CourseObjectiveOrderByWithRelationInput[]
    cursor?: CourseObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseObjectiveScalarFieldEnum | CourseObjectiveScalarFieldEnum[]
  }

  /**
   * Objective.workshops
   */
  export type Objective$workshopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveInclude<ExtArgs> | null
    where?: WorkshopObjectiveWhereInput
    orderBy?: WorkshopObjectiveOrderByWithRelationInput | WorkshopObjectiveOrderByWithRelationInput[]
    cursor?: WorkshopObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopObjectiveScalarFieldEnum | WorkshopObjectiveScalarFieldEnum[]
  }

  /**
   * Objective.learningPaths
   */
  export type Objective$learningPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveInclude<ExtArgs> | null
    where?: LearningPathObjectiveWhereInput
    orderBy?: LearningPathObjectiveOrderByWithRelationInput | LearningPathObjectiveOrderByWithRelationInput[]
    cursor?: LearningPathObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathObjectiveScalarFieldEnum | LearningPathObjectiveScalarFieldEnum[]
  }

  /**
   * Objective without action
   */
  export type ObjectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
  }


  /**
   * Model Prerequisite
   */

  export type AggregatePrerequisite = {
    _count: PrerequisiteCountAggregateOutputType | null
    _min: PrerequisiteMinAggregateOutputType | null
    _max: PrerequisiteMaxAggregateOutputType | null
  }

  export type PrerequisiteMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
  }

  export type PrerequisiteMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
  }

  export type PrerequisiteCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    _all: number
  }


  export type PrerequisiteMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
  }

  export type PrerequisiteMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
  }

  export type PrerequisiteCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type PrerequisiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prerequisite to aggregate.
     */
    where?: PrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prerequisites to fetch.
     */
    orderBy?: PrerequisiteOrderByWithRelationInput | PrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prerequisites
    **/
    _count?: true | PrerequisiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrerequisiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrerequisiteMaxAggregateInputType
  }

  export type GetPrerequisiteAggregateType<T extends PrerequisiteAggregateArgs> = {
        [P in keyof T & keyof AggregatePrerequisite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrerequisite[P]>
      : GetScalarType<T[P], AggregatePrerequisite[P]>
  }




  export type PrerequisiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrerequisiteWhereInput
    orderBy?: PrerequisiteOrderByWithAggregationInput | PrerequisiteOrderByWithAggregationInput[]
    by: PrerequisiteScalarFieldEnum[] | PrerequisiteScalarFieldEnum
    having?: PrerequisiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrerequisiteCountAggregateInputType | true
    _min?: PrerequisiteMinAggregateInputType
    _max?: PrerequisiteMaxAggregateInputType
  }

  export type PrerequisiteGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    _count: PrerequisiteCountAggregateOutputType | null
    _min: PrerequisiteMinAggregateOutputType | null
    _max: PrerequisiteMaxAggregateOutputType | null
  }

  type GetPrerequisiteGroupByPayload<T extends PrerequisiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrerequisiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrerequisiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrerequisiteGroupByOutputType[P]>
            : GetScalarType<T[P], PrerequisiteGroupByOutputType[P]>
        }
      >
    >


  export type PrerequisiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    courses?: boolean | Prerequisite$coursesArgs<ExtArgs>
    workshops?: boolean | Prerequisite$workshopsArgs<ExtArgs>
    learningPaths?: boolean | Prerequisite$learningPathsArgs<ExtArgs>
    _count?: boolean | PrerequisiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prerequisite"]>

  export type PrerequisiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["prerequisite"]>

  export type PrerequisiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["prerequisite"]>

  export type PrerequisiteSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type PrerequisiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt", ExtArgs["result"]["prerequisite"]>
  export type PrerequisiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | Prerequisite$coursesArgs<ExtArgs>
    workshops?: boolean | Prerequisite$workshopsArgs<ExtArgs>
    learningPaths?: boolean | Prerequisite$learningPathsArgs<ExtArgs>
    _count?: boolean | PrerequisiteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrerequisiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PrerequisiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PrerequisitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prerequisite"
    objects: {
      courses: Prisma.$CoursePrerequisitePayload<ExtArgs>[]
      workshops: Prisma.$WorkshopPrerequisitePayload<ExtArgs>[]
      learningPaths: Prisma.$LearningPathPrerequisitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["prerequisite"]>
    composites: {}
  }

  type PrerequisiteGetPayload<S extends boolean | null | undefined | PrerequisiteDefaultArgs> = $Result.GetResult<Prisma.$PrerequisitePayload, S>

  type PrerequisiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrerequisiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrerequisiteCountAggregateInputType | true
    }

  export interface PrerequisiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prerequisite'], meta: { name: 'Prerequisite' } }
    /**
     * Find zero or one Prerequisite that matches the filter.
     * @param {PrerequisiteFindUniqueArgs} args - Arguments to find a Prerequisite
     * @example
     * // Get one Prerequisite
     * const prerequisite = await prisma.prerequisite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrerequisiteFindUniqueArgs>(args: SelectSubset<T, PrerequisiteFindUniqueArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prerequisite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrerequisiteFindUniqueOrThrowArgs} args - Arguments to find a Prerequisite
     * @example
     * // Get one Prerequisite
     * const prerequisite = await prisma.prerequisite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrerequisiteFindUniqueOrThrowArgs>(args: SelectSubset<T, PrerequisiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prerequisite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteFindFirstArgs} args - Arguments to find a Prerequisite
     * @example
     * // Get one Prerequisite
     * const prerequisite = await prisma.prerequisite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrerequisiteFindFirstArgs>(args?: SelectSubset<T, PrerequisiteFindFirstArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prerequisite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteFindFirstOrThrowArgs} args - Arguments to find a Prerequisite
     * @example
     * // Get one Prerequisite
     * const prerequisite = await prisma.prerequisite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrerequisiteFindFirstOrThrowArgs>(args?: SelectSubset<T, PrerequisiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prerequisites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prerequisites
     * const prerequisites = await prisma.prerequisite.findMany()
     * 
     * // Get first 10 Prerequisites
     * const prerequisites = await prisma.prerequisite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prerequisiteWithIdOnly = await prisma.prerequisite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrerequisiteFindManyArgs>(args?: SelectSubset<T, PrerequisiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prerequisite.
     * @param {PrerequisiteCreateArgs} args - Arguments to create a Prerequisite.
     * @example
     * // Create one Prerequisite
     * const Prerequisite = await prisma.prerequisite.create({
     *   data: {
     *     // ... data to create a Prerequisite
     *   }
     * })
     * 
     */
    create<T extends PrerequisiteCreateArgs>(args: SelectSubset<T, PrerequisiteCreateArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prerequisites.
     * @param {PrerequisiteCreateManyArgs} args - Arguments to create many Prerequisites.
     * @example
     * // Create many Prerequisites
     * const prerequisite = await prisma.prerequisite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrerequisiteCreateManyArgs>(args?: SelectSubset<T, PrerequisiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prerequisites and returns the data saved in the database.
     * @param {PrerequisiteCreateManyAndReturnArgs} args - Arguments to create many Prerequisites.
     * @example
     * // Create many Prerequisites
     * const prerequisite = await prisma.prerequisite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prerequisites and only return the `id`
     * const prerequisiteWithIdOnly = await prisma.prerequisite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrerequisiteCreateManyAndReturnArgs>(args?: SelectSubset<T, PrerequisiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prerequisite.
     * @param {PrerequisiteDeleteArgs} args - Arguments to delete one Prerequisite.
     * @example
     * // Delete one Prerequisite
     * const Prerequisite = await prisma.prerequisite.delete({
     *   where: {
     *     // ... filter to delete one Prerequisite
     *   }
     * })
     * 
     */
    delete<T extends PrerequisiteDeleteArgs>(args: SelectSubset<T, PrerequisiteDeleteArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prerequisite.
     * @param {PrerequisiteUpdateArgs} args - Arguments to update one Prerequisite.
     * @example
     * // Update one Prerequisite
     * const prerequisite = await prisma.prerequisite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrerequisiteUpdateArgs>(args: SelectSubset<T, PrerequisiteUpdateArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prerequisites.
     * @param {PrerequisiteDeleteManyArgs} args - Arguments to filter Prerequisites to delete.
     * @example
     * // Delete a few Prerequisites
     * const { count } = await prisma.prerequisite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrerequisiteDeleteManyArgs>(args?: SelectSubset<T, PrerequisiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prerequisites
     * const prerequisite = await prisma.prerequisite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrerequisiteUpdateManyArgs>(args: SelectSubset<T, PrerequisiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prerequisites and returns the data updated in the database.
     * @param {PrerequisiteUpdateManyAndReturnArgs} args - Arguments to update many Prerequisites.
     * @example
     * // Update many Prerequisites
     * const prerequisite = await prisma.prerequisite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prerequisites and only return the `id`
     * const prerequisiteWithIdOnly = await prisma.prerequisite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrerequisiteUpdateManyAndReturnArgs>(args: SelectSubset<T, PrerequisiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prerequisite.
     * @param {PrerequisiteUpsertArgs} args - Arguments to update or create a Prerequisite.
     * @example
     * // Update or create a Prerequisite
     * const prerequisite = await prisma.prerequisite.upsert({
     *   create: {
     *     // ... data to create a Prerequisite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prerequisite we want to update
     *   }
     * })
     */
    upsert<T extends PrerequisiteUpsertArgs>(args: SelectSubset<T, PrerequisiteUpsertArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteCountArgs} args - Arguments to filter Prerequisites to count.
     * @example
     * // Count the number of Prerequisites
     * const count = await prisma.prerequisite.count({
     *   where: {
     *     // ... the filter for the Prerequisites we want to count
     *   }
     * })
    **/
    count<T extends PrerequisiteCountArgs>(
      args?: Subset<T, PrerequisiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrerequisiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrerequisiteAggregateArgs>(args: Subset<T, PrerequisiteAggregateArgs>): Prisma.PrismaPromise<GetPrerequisiteAggregateType<T>>

    /**
     * Group by Prerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrerequisiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrerequisiteGroupByArgs['orderBy'] }
        : { orderBy?: PrerequisiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrerequisiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrerequisiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prerequisite model
   */
  readonly fields: PrerequisiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prerequisite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrerequisiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends Prerequisite$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Prerequisite$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workshops<T extends Prerequisite$workshopsArgs<ExtArgs> = {}>(args?: Subset<T, Prerequisite$workshopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningPaths<T extends Prerequisite$learningPathsArgs<ExtArgs> = {}>(args?: Subset<T, Prerequisite$learningPathsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prerequisite model
   */
  interface PrerequisiteFieldRefs {
    readonly id: FieldRef<"Prerequisite", 'String'>
    readonly content: FieldRef<"Prerequisite", 'String'>
    readonly createdAt: FieldRef<"Prerequisite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prerequisite findUnique
   */
  export type PrerequisiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisite to fetch.
     */
    where: PrerequisiteWhereUniqueInput
  }

  /**
   * Prerequisite findUniqueOrThrow
   */
  export type PrerequisiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisite to fetch.
     */
    where: PrerequisiteWhereUniqueInput
  }

  /**
   * Prerequisite findFirst
   */
  export type PrerequisiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisite to fetch.
     */
    where?: PrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prerequisites to fetch.
     */
    orderBy?: PrerequisiteOrderByWithRelationInput | PrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prerequisites.
     */
    cursor?: PrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prerequisites.
     */
    distinct?: PrerequisiteScalarFieldEnum | PrerequisiteScalarFieldEnum[]
  }

  /**
   * Prerequisite findFirstOrThrow
   */
  export type PrerequisiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisite to fetch.
     */
    where?: PrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prerequisites to fetch.
     */
    orderBy?: PrerequisiteOrderByWithRelationInput | PrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prerequisites.
     */
    cursor?: PrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prerequisites.
     */
    distinct?: PrerequisiteScalarFieldEnum | PrerequisiteScalarFieldEnum[]
  }

  /**
   * Prerequisite findMany
   */
  export type PrerequisiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisites to fetch.
     */
    where?: PrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prerequisites to fetch.
     */
    orderBy?: PrerequisiteOrderByWithRelationInput | PrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prerequisites.
     */
    cursor?: PrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prerequisites.
     */
    skip?: number
    distinct?: PrerequisiteScalarFieldEnum | PrerequisiteScalarFieldEnum[]
  }

  /**
   * Prerequisite create
   */
  export type PrerequisiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Prerequisite.
     */
    data: XOR<PrerequisiteCreateInput, PrerequisiteUncheckedCreateInput>
  }

  /**
   * Prerequisite createMany
   */
  export type PrerequisiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prerequisites.
     */
    data: PrerequisiteCreateManyInput | PrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prerequisite createManyAndReturn
   */
  export type PrerequisiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to create many Prerequisites.
     */
    data: PrerequisiteCreateManyInput | PrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prerequisite update
   */
  export type PrerequisiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Prerequisite.
     */
    data: XOR<PrerequisiteUpdateInput, PrerequisiteUncheckedUpdateInput>
    /**
     * Choose, which Prerequisite to update.
     */
    where: PrerequisiteWhereUniqueInput
  }

  /**
   * Prerequisite updateMany
   */
  export type PrerequisiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prerequisites.
     */
    data: XOR<PrerequisiteUpdateManyMutationInput, PrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which Prerequisites to update
     */
    where?: PrerequisiteWhereInput
    /**
     * Limit how many Prerequisites to update.
     */
    limit?: number
  }

  /**
   * Prerequisite updateManyAndReturn
   */
  export type PrerequisiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to update Prerequisites.
     */
    data: XOR<PrerequisiteUpdateManyMutationInput, PrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which Prerequisites to update
     */
    where?: PrerequisiteWhereInput
    /**
     * Limit how many Prerequisites to update.
     */
    limit?: number
  }

  /**
   * Prerequisite upsert
   */
  export type PrerequisiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Prerequisite to update in case it exists.
     */
    where: PrerequisiteWhereUniqueInput
    /**
     * In case the Prerequisite found by the `where` argument doesn't exist, create a new Prerequisite with this data.
     */
    create: XOR<PrerequisiteCreateInput, PrerequisiteUncheckedCreateInput>
    /**
     * In case the Prerequisite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrerequisiteUpdateInput, PrerequisiteUncheckedUpdateInput>
  }

  /**
   * Prerequisite delete
   */
  export type PrerequisiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * Filter which Prerequisite to delete.
     */
    where: PrerequisiteWhereUniqueInput
  }

  /**
   * Prerequisite deleteMany
   */
  export type PrerequisiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prerequisites to delete
     */
    where?: PrerequisiteWhereInput
    /**
     * Limit how many Prerequisites to delete.
     */
    limit?: number
  }

  /**
   * Prerequisite.courses
   */
  export type Prerequisite$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteInclude<ExtArgs> | null
    where?: CoursePrerequisiteWhereInput
    orderBy?: CoursePrerequisiteOrderByWithRelationInput | CoursePrerequisiteOrderByWithRelationInput[]
    cursor?: CoursePrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoursePrerequisiteScalarFieldEnum | CoursePrerequisiteScalarFieldEnum[]
  }

  /**
   * Prerequisite.workshops
   */
  export type Prerequisite$workshopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteInclude<ExtArgs> | null
    where?: WorkshopPrerequisiteWhereInput
    orderBy?: WorkshopPrerequisiteOrderByWithRelationInput | WorkshopPrerequisiteOrderByWithRelationInput[]
    cursor?: WorkshopPrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopPrerequisiteScalarFieldEnum | WorkshopPrerequisiteScalarFieldEnum[]
  }

  /**
   * Prerequisite.learningPaths
   */
  export type Prerequisite$learningPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteInclude<ExtArgs> | null
    where?: LearningPathPrerequisiteWhereInput
    orderBy?: LearningPathPrerequisiteOrderByWithRelationInput | LearningPathPrerequisiteOrderByWithRelationInput[]
    cursor?: LearningPathPrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathPrerequisiteScalarFieldEnum | LearningPathPrerequisiteScalarFieldEnum[]
  }

  /**
   * Prerequisite without action
   */
  export type PrerequisiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
  }


  /**
   * Model CourseObjective
   */

  export type AggregateCourseObjective = {
    _count: CourseObjectiveCountAggregateOutputType | null
    _min: CourseObjectiveMinAggregateOutputType | null
    _max: CourseObjectiveMaxAggregateOutputType | null
  }

  export type CourseObjectiveMinAggregateOutputType = {
    courseId: string | null
    objectiveId: string | null
  }

  export type CourseObjectiveMaxAggregateOutputType = {
    courseId: string | null
    objectiveId: string | null
  }

  export type CourseObjectiveCountAggregateOutputType = {
    courseId: number
    objectiveId: number
    _all: number
  }


  export type CourseObjectiveMinAggregateInputType = {
    courseId?: true
    objectiveId?: true
  }

  export type CourseObjectiveMaxAggregateInputType = {
    courseId?: true
    objectiveId?: true
  }

  export type CourseObjectiveCountAggregateInputType = {
    courseId?: true
    objectiveId?: true
    _all?: true
  }

  export type CourseObjectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseObjective to aggregate.
     */
    where?: CourseObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseObjectives to fetch.
     */
    orderBy?: CourseObjectiveOrderByWithRelationInput | CourseObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseObjectives
    **/
    _count?: true | CourseObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseObjectiveMaxAggregateInputType
  }

  export type GetCourseObjectiveAggregateType<T extends CourseObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseObjective[P]>
      : GetScalarType<T[P], AggregateCourseObjective[P]>
  }




  export type CourseObjectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseObjectiveWhereInput
    orderBy?: CourseObjectiveOrderByWithAggregationInput | CourseObjectiveOrderByWithAggregationInput[]
    by: CourseObjectiveScalarFieldEnum[] | CourseObjectiveScalarFieldEnum
    having?: CourseObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseObjectiveCountAggregateInputType | true
    _min?: CourseObjectiveMinAggregateInputType
    _max?: CourseObjectiveMaxAggregateInputType
  }

  export type CourseObjectiveGroupByOutputType = {
    courseId: string
    objectiveId: string
    _count: CourseObjectiveCountAggregateOutputType | null
    _min: CourseObjectiveMinAggregateOutputType | null
    _max: CourseObjectiveMaxAggregateOutputType | null
  }

  type GetCourseObjectiveGroupByPayload<T extends CourseObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], CourseObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type CourseObjectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    objectiveId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseObjective"]>

  export type CourseObjectiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    objectiveId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseObjective"]>

  export type CourseObjectiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    objectiveId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseObjective"]>

  export type CourseObjectiveSelectScalar = {
    courseId?: boolean
    objectiveId?: boolean
  }

  export type CourseObjectiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"courseId" | "objectiveId", ExtArgs["result"]["courseObjective"]>
  export type CourseObjectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }
  export type CourseObjectiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }
  export type CourseObjectiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }

  export type $CourseObjectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseObjective"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      objective: Prisma.$ObjectivePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      courseId: string
      objectiveId: string
    }, ExtArgs["result"]["courseObjective"]>
    composites: {}
  }

  type CourseObjectiveGetPayload<S extends boolean | null | undefined | CourseObjectiveDefaultArgs> = $Result.GetResult<Prisma.$CourseObjectivePayload, S>

  type CourseObjectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseObjectiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseObjectiveCountAggregateInputType | true
    }

  export interface CourseObjectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseObjective'], meta: { name: 'CourseObjective' } }
    /**
     * Find zero or one CourseObjective that matches the filter.
     * @param {CourseObjectiveFindUniqueArgs} args - Arguments to find a CourseObjective
     * @example
     * // Get one CourseObjective
     * const courseObjective = await prisma.courseObjective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseObjectiveFindUniqueArgs>(args: SelectSubset<T, CourseObjectiveFindUniqueArgs<ExtArgs>>): Prisma__CourseObjectiveClient<$Result.GetResult<Prisma.$CourseObjectivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseObjective that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseObjectiveFindUniqueOrThrowArgs} args - Arguments to find a CourseObjective
     * @example
     * // Get one CourseObjective
     * const courseObjective = await prisma.courseObjective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseObjectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseObjectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseObjectiveClient<$Result.GetResult<Prisma.$CourseObjectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseObjective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveFindFirstArgs} args - Arguments to find a CourseObjective
     * @example
     * // Get one CourseObjective
     * const courseObjective = await prisma.courseObjective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseObjectiveFindFirstArgs>(args?: SelectSubset<T, CourseObjectiveFindFirstArgs<ExtArgs>>): Prisma__CourseObjectiveClient<$Result.GetResult<Prisma.$CourseObjectivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseObjective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveFindFirstOrThrowArgs} args - Arguments to find a CourseObjective
     * @example
     * // Get one CourseObjective
     * const courseObjective = await prisma.courseObjective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseObjectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseObjectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseObjectiveClient<$Result.GetResult<Prisma.$CourseObjectivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseObjectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseObjectives
     * const courseObjectives = await prisma.courseObjective.findMany()
     * 
     * // Get first 10 CourseObjectives
     * const courseObjectives = await prisma.courseObjective.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const courseObjectiveWithCourseIdOnly = await prisma.courseObjective.findMany({ select: { courseId: true } })
     * 
     */
    findMany<T extends CourseObjectiveFindManyArgs>(args?: SelectSubset<T, CourseObjectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseObjective.
     * @param {CourseObjectiveCreateArgs} args - Arguments to create a CourseObjective.
     * @example
     * // Create one CourseObjective
     * const CourseObjective = await prisma.courseObjective.create({
     *   data: {
     *     // ... data to create a CourseObjective
     *   }
     * })
     * 
     */
    create<T extends CourseObjectiveCreateArgs>(args: SelectSubset<T, CourseObjectiveCreateArgs<ExtArgs>>): Prisma__CourseObjectiveClient<$Result.GetResult<Prisma.$CourseObjectivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseObjectives.
     * @param {CourseObjectiveCreateManyArgs} args - Arguments to create many CourseObjectives.
     * @example
     * // Create many CourseObjectives
     * const courseObjective = await prisma.courseObjective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseObjectiveCreateManyArgs>(args?: SelectSubset<T, CourseObjectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseObjectives and returns the data saved in the database.
     * @param {CourseObjectiveCreateManyAndReturnArgs} args - Arguments to create many CourseObjectives.
     * @example
     * // Create many CourseObjectives
     * const courseObjective = await prisma.courseObjective.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseObjectives and only return the `courseId`
     * const courseObjectiveWithCourseIdOnly = await prisma.courseObjective.createManyAndReturn({
     *   select: { courseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseObjectiveCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseObjectiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseObjectivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseObjective.
     * @param {CourseObjectiveDeleteArgs} args - Arguments to delete one CourseObjective.
     * @example
     * // Delete one CourseObjective
     * const CourseObjective = await prisma.courseObjective.delete({
     *   where: {
     *     // ... filter to delete one CourseObjective
     *   }
     * })
     * 
     */
    delete<T extends CourseObjectiveDeleteArgs>(args: SelectSubset<T, CourseObjectiveDeleteArgs<ExtArgs>>): Prisma__CourseObjectiveClient<$Result.GetResult<Prisma.$CourseObjectivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseObjective.
     * @param {CourseObjectiveUpdateArgs} args - Arguments to update one CourseObjective.
     * @example
     * // Update one CourseObjective
     * const courseObjective = await prisma.courseObjective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseObjectiveUpdateArgs>(args: SelectSubset<T, CourseObjectiveUpdateArgs<ExtArgs>>): Prisma__CourseObjectiveClient<$Result.GetResult<Prisma.$CourseObjectivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseObjectives.
     * @param {CourseObjectiveDeleteManyArgs} args - Arguments to filter CourseObjectives to delete.
     * @example
     * // Delete a few CourseObjectives
     * const { count } = await prisma.courseObjective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseObjectiveDeleteManyArgs>(args?: SelectSubset<T, CourseObjectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseObjectives
     * const courseObjective = await prisma.courseObjective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseObjectiveUpdateManyArgs>(args: SelectSubset<T, CourseObjectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseObjectives and returns the data updated in the database.
     * @param {CourseObjectiveUpdateManyAndReturnArgs} args - Arguments to update many CourseObjectives.
     * @example
     * // Update many CourseObjectives
     * const courseObjective = await prisma.courseObjective.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseObjectives and only return the `courseId`
     * const courseObjectiveWithCourseIdOnly = await prisma.courseObjective.updateManyAndReturn({
     *   select: { courseId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseObjectiveUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseObjectiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseObjectivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseObjective.
     * @param {CourseObjectiveUpsertArgs} args - Arguments to update or create a CourseObjective.
     * @example
     * // Update or create a CourseObjective
     * const courseObjective = await prisma.courseObjective.upsert({
     *   create: {
     *     // ... data to create a CourseObjective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseObjective we want to update
     *   }
     * })
     */
    upsert<T extends CourseObjectiveUpsertArgs>(args: SelectSubset<T, CourseObjectiveUpsertArgs<ExtArgs>>): Prisma__CourseObjectiveClient<$Result.GetResult<Prisma.$CourseObjectivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveCountArgs} args - Arguments to filter CourseObjectives to count.
     * @example
     * // Count the number of CourseObjectives
     * const count = await prisma.courseObjective.count({
     *   where: {
     *     // ... the filter for the CourseObjectives we want to count
     *   }
     * })
    **/
    count<T extends CourseObjectiveCountArgs>(
      args?: Subset<T, CourseObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseObjectiveAggregateArgs>(args: Subset<T, CourseObjectiveAggregateArgs>): Prisma.PrismaPromise<GetCourseObjectiveAggregateType<T>>

    /**
     * Group by CourseObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: CourseObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseObjective model
   */
  readonly fields: CourseObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseObjective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseObjectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    objective<T extends ObjectiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectiveDefaultArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseObjective model
   */
  interface CourseObjectiveFieldRefs {
    readonly courseId: FieldRef<"CourseObjective", 'String'>
    readonly objectiveId: FieldRef<"CourseObjective", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseObjective findUnique
   */
  export type CourseObjectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which CourseObjective to fetch.
     */
    where: CourseObjectiveWhereUniqueInput
  }

  /**
   * CourseObjective findUniqueOrThrow
   */
  export type CourseObjectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which CourseObjective to fetch.
     */
    where: CourseObjectiveWhereUniqueInput
  }

  /**
   * CourseObjective findFirst
   */
  export type CourseObjectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which CourseObjective to fetch.
     */
    where?: CourseObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseObjectives to fetch.
     */
    orderBy?: CourseObjectiveOrderByWithRelationInput | CourseObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseObjectives.
     */
    cursor?: CourseObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseObjectives.
     */
    distinct?: CourseObjectiveScalarFieldEnum | CourseObjectiveScalarFieldEnum[]
  }

  /**
   * CourseObjective findFirstOrThrow
   */
  export type CourseObjectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which CourseObjective to fetch.
     */
    where?: CourseObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseObjectives to fetch.
     */
    orderBy?: CourseObjectiveOrderByWithRelationInput | CourseObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseObjectives.
     */
    cursor?: CourseObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseObjectives.
     */
    distinct?: CourseObjectiveScalarFieldEnum | CourseObjectiveScalarFieldEnum[]
  }

  /**
   * CourseObjective findMany
   */
  export type CourseObjectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which CourseObjectives to fetch.
     */
    where?: CourseObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseObjectives to fetch.
     */
    orderBy?: CourseObjectiveOrderByWithRelationInput | CourseObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseObjectives.
     */
    cursor?: CourseObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseObjectives.
     */
    skip?: number
    distinct?: CourseObjectiveScalarFieldEnum | CourseObjectiveScalarFieldEnum[]
  }

  /**
   * CourseObjective create
   */
  export type CourseObjectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseObjective.
     */
    data: XOR<CourseObjectiveCreateInput, CourseObjectiveUncheckedCreateInput>
  }

  /**
   * CourseObjective createMany
   */
  export type CourseObjectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseObjectives.
     */
    data: CourseObjectiveCreateManyInput | CourseObjectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseObjective createManyAndReturn
   */
  export type CourseObjectiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * The data used to create many CourseObjectives.
     */
    data: CourseObjectiveCreateManyInput | CourseObjectiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseObjective update
   */
  export type CourseObjectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseObjective.
     */
    data: XOR<CourseObjectiveUpdateInput, CourseObjectiveUncheckedUpdateInput>
    /**
     * Choose, which CourseObjective to update.
     */
    where: CourseObjectiveWhereUniqueInput
  }

  /**
   * CourseObjective updateMany
   */
  export type CourseObjectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseObjectives.
     */
    data: XOR<CourseObjectiveUpdateManyMutationInput, CourseObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which CourseObjectives to update
     */
    where?: CourseObjectiveWhereInput
    /**
     * Limit how many CourseObjectives to update.
     */
    limit?: number
  }

  /**
   * CourseObjective updateManyAndReturn
   */
  export type CourseObjectiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * The data used to update CourseObjectives.
     */
    data: XOR<CourseObjectiveUpdateManyMutationInput, CourseObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which CourseObjectives to update
     */
    where?: CourseObjectiveWhereInput
    /**
     * Limit how many CourseObjectives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseObjective upsert
   */
  export type CourseObjectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseObjective to update in case it exists.
     */
    where: CourseObjectiveWhereUniqueInput
    /**
     * In case the CourseObjective found by the `where` argument doesn't exist, create a new CourseObjective with this data.
     */
    create: XOR<CourseObjectiveCreateInput, CourseObjectiveUncheckedCreateInput>
    /**
     * In case the CourseObjective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseObjectiveUpdateInput, CourseObjectiveUncheckedUpdateInput>
  }

  /**
   * CourseObjective delete
   */
  export type CourseObjectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null
    /**
     * Filter which CourseObjective to delete.
     */
    where: CourseObjectiveWhereUniqueInput
  }

  /**
   * CourseObjective deleteMany
   */
  export type CourseObjectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseObjectives to delete
     */
    where?: CourseObjectiveWhereInput
    /**
     * Limit how many CourseObjectives to delete.
     */
    limit?: number
  }

  /**
   * CourseObjective without action
   */
  export type CourseObjectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseObjective
     */
    select?: CourseObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseObjective
     */
    omit?: CourseObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseObjectiveInclude<ExtArgs> | null
  }


  /**
   * Model CoursePrerequisite
   */

  export type AggregateCoursePrerequisite = {
    _count: CoursePrerequisiteCountAggregateOutputType | null
    _min: CoursePrerequisiteMinAggregateOutputType | null
    _max: CoursePrerequisiteMaxAggregateOutputType | null
  }

  export type CoursePrerequisiteMinAggregateOutputType = {
    courseId: string | null
    prerequisiteId: string | null
  }

  export type CoursePrerequisiteMaxAggregateOutputType = {
    courseId: string | null
    prerequisiteId: string | null
  }

  export type CoursePrerequisiteCountAggregateOutputType = {
    courseId: number
    prerequisiteId: number
    _all: number
  }


  export type CoursePrerequisiteMinAggregateInputType = {
    courseId?: true
    prerequisiteId?: true
  }

  export type CoursePrerequisiteMaxAggregateInputType = {
    courseId?: true
    prerequisiteId?: true
  }

  export type CoursePrerequisiteCountAggregateInputType = {
    courseId?: true
    prerequisiteId?: true
    _all?: true
  }

  export type CoursePrerequisiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoursePrerequisite to aggregate.
     */
    where?: CoursePrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePrerequisites to fetch.
     */
    orderBy?: CoursePrerequisiteOrderByWithRelationInput | CoursePrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoursePrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoursePrerequisites
    **/
    _count?: true | CoursePrerequisiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoursePrerequisiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoursePrerequisiteMaxAggregateInputType
  }

  export type GetCoursePrerequisiteAggregateType<T extends CoursePrerequisiteAggregateArgs> = {
        [P in keyof T & keyof AggregateCoursePrerequisite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoursePrerequisite[P]>
      : GetScalarType<T[P], AggregateCoursePrerequisite[P]>
  }




  export type CoursePrerequisiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursePrerequisiteWhereInput
    orderBy?: CoursePrerequisiteOrderByWithAggregationInput | CoursePrerequisiteOrderByWithAggregationInput[]
    by: CoursePrerequisiteScalarFieldEnum[] | CoursePrerequisiteScalarFieldEnum
    having?: CoursePrerequisiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoursePrerequisiteCountAggregateInputType | true
    _min?: CoursePrerequisiteMinAggregateInputType
    _max?: CoursePrerequisiteMaxAggregateInputType
  }

  export type CoursePrerequisiteGroupByOutputType = {
    courseId: string
    prerequisiteId: string
    _count: CoursePrerequisiteCountAggregateOutputType | null
    _min: CoursePrerequisiteMinAggregateOutputType | null
    _max: CoursePrerequisiteMaxAggregateOutputType | null
  }

  type GetCoursePrerequisiteGroupByPayload<T extends CoursePrerequisiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoursePrerequisiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoursePrerequisiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoursePrerequisiteGroupByOutputType[P]>
            : GetScalarType<T[P], CoursePrerequisiteGroupByOutputType[P]>
        }
      >
    >


  export type CoursePrerequisiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    prerequisiteId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coursePrerequisite"]>

  export type CoursePrerequisiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    prerequisiteId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coursePrerequisite"]>

  export type CoursePrerequisiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    prerequisiteId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coursePrerequisite"]>

  export type CoursePrerequisiteSelectScalar = {
    courseId?: boolean
    prerequisiteId?: boolean
  }

  export type CoursePrerequisiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"courseId" | "prerequisiteId", ExtArgs["result"]["coursePrerequisite"]>
  export type CoursePrerequisiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }
  export type CoursePrerequisiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }
  export type CoursePrerequisiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }

  export type $CoursePrerequisitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoursePrerequisite"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      prerequisite: Prisma.$PrerequisitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      courseId: string
      prerequisiteId: string
    }, ExtArgs["result"]["coursePrerequisite"]>
    composites: {}
  }

  type CoursePrerequisiteGetPayload<S extends boolean | null | undefined | CoursePrerequisiteDefaultArgs> = $Result.GetResult<Prisma.$CoursePrerequisitePayload, S>

  type CoursePrerequisiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoursePrerequisiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoursePrerequisiteCountAggregateInputType | true
    }

  export interface CoursePrerequisiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoursePrerequisite'], meta: { name: 'CoursePrerequisite' } }
    /**
     * Find zero or one CoursePrerequisite that matches the filter.
     * @param {CoursePrerequisiteFindUniqueArgs} args - Arguments to find a CoursePrerequisite
     * @example
     * // Get one CoursePrerequisite
     * const coursePrerequisite = await prisma.coursePrerequisite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoursePrerequisiteFindUniqueArgs>(args: SelectSubset<T, CoursePrerequisiteFindUniqueArgs<ExtArgs>>): Prisma__CoursePrerequisiteClient<$Result.GetResult<Prisma.$CoursePrerequisitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CoursePrerequisite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoursePrerequisiteFindUniqueOrThrowArgs} args - Arguments to find a CoursePrerequisite
     * @example
     * // Get one CoursePrerequisite
     * const coursePrerequisite = await prisma.coursePrerequisite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoursePrerequisiteFindUniqueOrThrowArgs>(args: SelectSubset<T, CoursePrerequisiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoursePrerequisiteClient<$Result.GetResult<Prisma.$CoursePrerequisitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoursePrerequisite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePrerequisiteFindFirstArgs} args - Arguments to find a CoursePrerequisite
     * @example
     * // Get one CoursePrerequisite
     * const coursePrerequisite = await prisma.coursePrerequisite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoursePrerequisiteFindFirstArgs>(args?: SelectSubset<T, CoursePrerequisiteFindFirstArgs<ExtArgs>>): Prisma__CoursePrerequisiteClient<$Result.GetResult<Prisma.$CoursePrerequisitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoursePrerequisite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePrerequisiteFindFirstOrThrowArgs} args - Arguments to find a CoursePrerequisite
     * @example
     * // Get one CoursePrerequisite
     * const coursePrerequisite = await prisma.coursePrerequisite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoursePrerequisiteFindFirstOrThrowArgs>(args?: SelectSubset<T, CoursePrerequisiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoursePrerequisiteClient<$Result.GetResult<Prisma.$CoursePrerequisitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CoursePrerequisites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePrerequisiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoursePrerequisites
     * const coursePrerequisites = await prisma.coursePrerequisite.findMany()
     * 
     * // Get first 10 CoursePrerequisites
     * const coursePrerequisites = await prisma.coursePrerequisite.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const coursePrerequisiteWithCourseIdOnly = await prisma.coursePrerequisite.findMany({ select: { courseId: true } })
     * 
     */
    findMany<T extends CoursePrerequisiteFindManyArgs>(args?: SelectSubset<T, CoursePrerequisiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CoursePrerequisite.
     * @param {CoursePrerequisiteCreateArgs} args - Arguments to create a CoursePrerequisite.
     * @example
     * // Create one CoursePrerequisite
     * const CoursePrerequisite = await prisma.coursePrerequisite.create({
     *   data: {
     *     // ... data to create a CoursePrerequisite
     *   }
     * })
     * 
     */
    create<T extends CoursePrerequisiteCreateArgs>(args: SelectSubset<T, CoursePrerequisiteCreateArgs<ExtArgs>>): Prisma__CoursePrerequisiteClient<$Result.GetResult<Prisma.$CoursePrerequisitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CoursePrerequisites.
     * @param {CoursePrerequisiteCreateManyArgs} args - Arguments to create many CoursePrerequisites.
     * @example
     * // Create many CoursePrerequisites
     * const coursePrerequisite = await prisma.coursePrerequisite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoursePrerequisiteCreateManyArgs>(args?: SelectSubset<T, CoursePrerequisiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoursePrerequisites and returns the data saved in the database.
     * @param {CoursePrerequisiteCreateManyAndReturnArgs} args - Arguments to create many CoursePrerequisites.
     * @example
     * // Create many CoursePrerequisites
     * const coursePrerequisite = await prisma.coursePrerequisite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoursePrerequisites and only return the `courseId`
     * const coursePrerequisiteWithCourseIdOnly = await prisma.coursePrerequisite.createManyAndReturn({
     *   select: { courseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoursePrerequisiteCreateManyAndReturnArgs>(args?: SelectSubset<T, CoursePrerequisiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePrerequisitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CoursePrerequisite.
     * @param {CoursePrerequisiteDeleteArgs} args - Arguments to delete one CoursePrerequisite.
     * @example
     * // Delete one CoursePrerequisite
     * const CoursePrerequisite = await prisma.coursePrerequisite.delete({
     *   where: {
     *     // ... filter to delete one CoursePrerequisite
     *   }
     * })
     * 
     */
    delete<T extends CoursePrerequisiteDeleteArgs>(args: SelectSubset<T, CoursePrerequisiteDeleteArgs<ExtArgs>>): Prisma__CoursePrerequisiteClient<$Result.GetResult<Prisma.$CoursePrerequisitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CoursePrerequisite.
     * @param {CoursePrerequisiteUpdateArgs} args - Arguments to update one CoursePrerequisite.
     * @example
     * // Update one CoursePrerequisite
     * const coursePrerequisite = await prisma.coursePrerequisite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoursePrerequisiteUpdateArgs>(args: SelectSubset<T, CoursePrerequisiteUpdateArgs<ExtArgs>>): Prisma__CoursePrerequisiteClient<$Result.GetResult<Prisma.$CoursePrerequisitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CoursePrerequisites.
     * @param {CoursePrerequisiteDeleteManyArgs} args - Arguments to filter CoursePrerequisites to delete.
     * @example
     * // Delete a few CoursePrerequisites
     * const { count } = await prisma.coursePrerequisite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoursePrerequisiteDeleteManyArgs>(args?: SelectSubset<T, CoursePrerequisiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoursePrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePrerequisiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoursePrerequisites
     * const coursePrerequisite = await prisma.coursePrerequisite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoursePrerequisiteUpdateManyArgs>(args: SelectSubset<T, CoursePrerequisiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoursePrerequisites and returns the data updated in the database.
     * @param {CoursePrerequisiteUpdateManyAndReturnArgs} args - Arguments to update many CoursePrerequisites.
     * @example
     * // Update many CoursePrerequisites
     * const coursePrerequisite = await prisma.coursePrerequisite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CoursePrerequisites and only return the `courseId`
     * const coursePrerequisiteWithCourseIdOnly = await prisma.coursePrerequisite.updateManyAndReturn({
     *   select: { courseId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoursePrerequisiteUpdateManyAndReturnArgs>(args: SelectSubset<T, CoursePrerequisiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePrerequisitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CoursePrerequisite.
     * @param {CoursePrerequisiteUpsertArgs} args - Arguments to update or create a CoursePrerequisite.
     * @example
     * // Update or create a CoursePrerequisite
     * const coursePrerequisite = await prisma.coursePrerequisite.upsert({
     *   create: {
     *     // ... data to create a CoursePrerequisite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoursePrerequisite we want to update
     *   }
     * })
     */
    upsert<T extends CoursePrerequisiteUpsertArgs>(args: SelectSubset<T, CoursePrerequisiteUpsertArgs<ExtArgs>>): Prisma__CoursePrerequisiteClient<$Result.GetResult<Prisma.$CoursePrerequisitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CoursePrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePrerequisiteCountArgs} args - Arguments to filter CoursePrerequisites to count.
     * @example
     * // Count the number of CoursePrerequisites
     * const count = await prisma.coursePrerequisite.count({
     *   where: {
     *     // ... the filter for the CoursePrerequisites we want to count
     *   }
     * })
    **/
    count<T extends CoursePrerequisiteCountArgs>(
      args?: Subset<T, CoursePrerequisiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoursePrerequisiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoursePrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePrerequisiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoursePrerequisiteAggregateArgs>(args: Subset<T, CoursePrerequisiteAggregateArgs>): Prisma.PrismaPromise<GetCoursePrerequisiteAggregateType<T>>

    /**
     * Group by CoursePrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePrerequisiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoursePrerequisiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoursePrerequisiteGroupByArgs['orderBy'] }
        : { orderBy?: CoursePrerequisiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoursePrerequisiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoursePrerequisiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoursePrerequisite model
   */
  readonly fields: CoursePrerequisiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoursePrerequisite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoursePrerequisiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prerequisite<T extends PrerequisiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrerequisiteDefaultArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoursePrerequisite model
   */
  interface CoursePrerequisiteFieldRefs {
    readonly courseId: FieldRef<"CoursePrerequisite", 'String'>
    readonly prerequisiteId: FieldRef<"CoursePrerequisite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CoursePrerequisite findUnique
   */
  export type CoursePrerequisiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CoursePrerequisite to fetch.
     */
    where: CoursePrerequisiteWhereUniqueInput
  }

  /**
   * CoursePrerequisite findUniqueOrThrow
   */
  export type CoursePrerequisiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CoursePrerequisite to fetch.
     */
    where: CoursePrerequisiteWhereUniqueInput
  }

  /**
   * CoursePrerequisite findFirst
   */
  export type CoursePrerequisiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CoursePrerequisite to fetch.
     */
    where?: CoursePrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePrerequisites to fetch.
     */
    orderBy?: CoursePrerequisiteOrderByWithRelationInput | CoursePrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoursePrerequisites.
     */
    cursor?: CoursePrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoursePrerequisites.
     */
    distinct?: CoursePrerequisiteScalarFieldEnum | CoursePrerequisiteScalarFieldEnum[]
  }

  /**
   * CoursePrerequisite findFirstOrThrow
   */
  export type CoursePrerequisiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CoursePrerequisite to fetch.
     */
    where?: CoursePrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePrerequisites to fetch.
     */
    orderBy?: CoursePrerequisiteOrderByWithRelationInput | CoursePrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoursePrerequisites.
     */
    cursor?: CoursePrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoursePrerequisites.
     */
    distinct?: CoursePrerequisiteScalarFieldEnum | CoursePrerequisiteScalarFieldEnum[]
  }

  /**
   * CoursePrerequisite findMany
   */
  export type CoursePrerequisiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CoursePrerequisites to fetch.
     */
    where?: CoursePrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePrerequisites to fetch.
     */
    orderBy?: CoursePrerequisiteOrderByWithRelationInput | CoursePrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoursePrerequisites.
     */
    cursor?: CoursePrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePrerequisites.
     */
    skip?: number
    distinct?: CoursePrerequisiteScalarFieldEnum | CoursePrerequisiteScalarFieldEnum[]
  }

  /**
   * CoursePrerequisite create
   */
  export type CoursePrerequisiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to create a CoursePrerequisite.
     */
    data: XOR<CoursePrerequisiteCreateInput, CoursePrerequisiteUncheckedCreateInput>
  }

  /**
   * CoursePrerequisite createMany
   */
  export type CoursePrerequisiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoursePrerequisites.
     */
    data: CoursePrerequisiteCreateManyInput | CoursePrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoursePrerequisite createManyAndReturn
   */
  export type CoursePrerequisiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to create many CoursePrerequisites.
     */
    data: CoursePrerequisiteCreateManyInput | CoursePrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoursePrerequisite update
   */
  export type CoursePrerequisiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to update a CoursePrerequisite.
     */
    data: XOR<CoursePrerequisiteUpdateInput, CoursePrerequisiteUncheckedUpdateInput>
    /**
     * Choose, which CoursePrerequisite to update.
     */
    where: CoursePrerequisiteWhereUniqueInput
  }

  /**
   * CoursePrerequisite updateMany
   */
  export type CoursePrerequisiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoursePrerequisites.
     */
    data: XOR<CoursePrerequisiteUpdateManyMutationInput, CoursePrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which CoursePrerequisites to update
     */
    where?: CoursePrerequisiteWhereInput
    /**
     * Limit how many CoursePrerequisites to update.
     */
    limit?: number
  }

  /**
   * CoursePrerequisite updateManyAndReturn
   */
  export type CoursePrerequisiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to update CoursePrerequisites.
     */
    data: XOR<CoursePrerequisiteUpdateManyMutationInput, CoursePrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which CoursePrerequisites to update
     */
    where?: CoursePrerequisiteWhereInput
    /**
     * Limit how many CoursePrerequisites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoursePrerequisite upsert
   */
  export type CoursePrerequisiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteInclude<ExtArgs> | null
    /**
     * The filter to search for the CoursePrerequisite to update in case it exists.
     */
    where: CoursePrerequisiteWhereUniqueInput
    /**
     * In case the CoursePrerequisite found by the `where` argument doesn't exist, create a new CoursePrerequisite with this data.
     */
    create: XOR<CoursePrerequisiteCreateInput, CoursePrerequisiteUncheckedCreateInput>
    /**
     * In case the CoursePrerequisite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoursePrerequisiteUpdateInput, CoursePrerequisiteUncheckedUpdateInput>
  }

  /**
   * CoursePrerequisite delete
   */
  export type CoursePrerequisiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter which CoursePrerequisite to delete.
     */
    where: CoursePrerequisiteWhereUniqueInput
  }

  /**
   * CoursePrerequisite deleteMany
   */
  export type CoursePrerequisiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoursePrerequisites to delete
     */
    where?: CoursePrerequisiteWhereInput
    /**
     * Limit how many CoursePrerequisites to delete.
     */
    limit?: number
  }

  /**
   * CoursePrerequisite without action
   */
  export type CoursePrerequisiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePrerequisite
     */
    select?: CoursePrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePrerequisite
     */
    omit?: CoursePrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePrerequisiteInclude<ExtArgs> | null
  }


  /**
   * Model WorkshopObjective
   */

  export type AggregateWorkshopObjective = {
    _count: WorkshopObjectiveCountAggregateOutputType | null
    _min: WorkshopObjectiveMinAggregateOutputType | null
    _max: WorkshopObjectiveMaxAggregateOutputType | null
  }

  export type WorkshopObjectiveMinAggregateOutputType = {
    workshopId: string | null
    objectiveId: string | null
  }

  export type WorkshopObjectiveMaxAggregateOutputType = {
    workshopId: string | null
    objectiveId: string | null
  }

  export type WorkshopObjectiveCountAggregateOutputType = {
    workshopId: number
    objectiveId: number
    _all: number
  }


  export type WorkshopObjectiveMinAggregateInputType = {
    workshopId?: true
    objectiveId?: true
  }

  export type WorkshopObjectiveMaxAggregateInputType = {
    workshopId?: true
    objectiveId?: true
  }

  export type WorkshopObjectiveCountAggregateInputType = {
    workshopId?: true
    objectiveId?: true
    _all?: true
  }

  export type WorkshopObjectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopObjective to aggregate.
     */
    where?: WorkshopObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopObjectives to fetch.
     */
    orderBy?: WorkshopObjectiveOrderByWithRelationInput | WorkshopObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkshopObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkshopObjectives
    **/
    _count?: true | WorkshopObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkshopObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkshopObjectiveMaxAggregateInputType
  }

  export type GetWorkshopObjectiveAggregateType<T extends WorkshopObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkshopObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkshopObjective[P]>
      : GetScalarType<T[P], AggregateWorkshopObjective[P]>
  }




  export type WorkshopObjectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopObjectiveWhereInput
    orderBy?: WorkshopObjectiveOrderByWithAggregationInput | WorkshopObjectiveOrderByWithAggregationInput[]
    by: WorkshopObjectiveScalarFieldEnum[] | WorkshopObjectiveScalarFieldEnum
    having?: WorkshopObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkshopObjectiveCountAggregateInputType | true
    _min?: WorkshopObjectiveMinAggregateInputType
    _max?: WorkshopObjectiveMaxAggregateInputType
  }

  export type WorkshopObjectiveGroupByOutputType = {
    workshopId: string
    objectiveId: string
    _count: WorkshopObjectiveCountAggregateOutputType | null
    _min: WorkshopObjectiveMinAggregateOutputType | null
    _max: WorkshopObjectiveMaxAggregateOutputType | null
  }

  type GetWorkshopObjectiveGroupByPayload<T extends WorkshopObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkshopObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkshopObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkshopObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], WorkshopObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type WorkshopObjectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workshopId?: boolean
    objectiveId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopObjective"]>

  export type WorkshopObjectiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workshopId?: boolean
    objectiveId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopObjective"]>

  export type WorkshopObjectiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workshopId?: boolean
    objectiveId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopObjective"]>

  export type WorkshopObjectiveSelectScalar = {
    workshopId?: boolean
    objectiveId?: boolean
  }

  export type WorkshopObjectiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workshopId" | "objectiveId", ExtArgs["result"]["workshopObjective"]>
  export type WorkshopObjectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }
  export type WorkshopObjectiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }
  export type WorkshopObjectiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }

  export type $WorkshopObjectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkshopObjective"
    objects: {
      workshop: Prisma.$WorkshopPayload<ExtArgs>
      objective: Prisma.$ObjectivePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workshopId: string
      objectiveId: string
    }, ExtArgs["result"]["workshopObjective"]>
    composites: {}
  }

  type WorkshopObjectiveGetPayload<S extends boolean | null | undefined | WorkshopObjectiveDefaultArgs> = $Result.GetResult<Prisma.$WorkshopObjectivePayload, S>

  type WorkshopObjectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkshopObjectiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkshopObjectiveCountAggregateInputType | true
    }

  export interface WorkshopObjectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkshopObjective'], meta: { name: 'WorkshopObjective' } }
    /**
     * Find zero or one WorkshopObjective that matches the filter.
     * @param {WorkshopObjectiveFindUniqueArgs} args - Arguments to find a WorkshopObjective
     * @example
     * // Get one WorkshopObjective
     * const workshopObjective = await prisma.workshopObjective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkshopObjectiveFindUniqueArgs>(args: SelectSubset<T, WorkshopObjectiveFindUniqueArgs<ExtArgs>>): Prisma__WorkshopObjectiveClient<$Result.GetResult<Prisma.$WorkshopObjectivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkshopObjective that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkshopObjectiveFindUniqueOrThrowArgs} args - Arguments to find a WorkshopObjective
     * @example
     * // Get one WorkshopObjective
     * const workshopObjective = await prisma.workshopObjective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkshopObjectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkshopObjectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkshopObjectiveClient<$Result.GetResult<Prisma.$WorkshopObjectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopObjective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopObjectiveFindFirstArgs} args - Arguments to find a WorkshopObjective
     * @example
     * // Get one WorkshopObjective
     * const workshopObjective = await prisma.workshopObjective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkshopObjectiveFindFirstArgs>(args?: SelectSubset<T, WorkshopObjectiveFindFirstArgs<ExtArgs>>): Prisma__WorkshopObjectiveClient<$Result.GetResult<Prisma.$WorkshopObjectivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopObjective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopObjectiveFindFirstOrThrowArgs} args - Arguments to find a WorkshopObjective
     * @example
     * // Get one WorkshopObjective
     * const workshopObjective = await prisma.workshopObjective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkshopObjectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkshopObjectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkshopObjectiveClient<$Result.GetResult<Prisma.$WorkshopObjectivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkshopObjectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkshopObjectives
     * const workshopObjectives = await prisma.workshopObjective.findMany()
     * 
     * // Get first 10 WorkshopObjectives
     * const workshopObjectives = await prisma.workshopObjective.findMany({ take: 10 })
     * 
     * // Only select the `workshopId`
     * const workshopObjectiveWithWorkshopIdOnly = await prisma.workshopObjective.findMany({ select: { workshopId: true } })
     * 
     */
    findMany<T extends WorkshopObjectiveFindManyArgs>(args?: SelectSubset<T, WorkshopObjectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkshopObjective.
     * @param {WorkshopObjectiveCreateArgs} args - Arguments to create a WorkshopObjective.
     * @example
     * // Create one WorkshopObjective
     * const WorkshopObjective = await prisma.workshopObjective.create({
     *   data: {
     *     // ... data to create a WorkshopObjective
     *   }
     * })
     * 
     */
    create<T extends WorkshopObjectiveCreateArgs>(args: SelectSubset<T, WorkshopObjectiveCreateArgs<ExtArgs>>): Prisma__WorkshopObjectiveClient<$Result.GetResult<Prisma.$WorkshopObjectivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkshopObjectives.
     * @param {WorkshopObjectiveCreateManyArgs} args - Arguments to create many WorkshopObjectives.
     * @example
     * // Create many WorkshopObjectives
     * const workshopObjective = await prisma.workshopObjective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkshopObjectiveCreateManyArgs>(args?: SelectSubset<T, WorkshopObjectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkshopObjectives and returns the data saved in the database.
     * @param {WorkshopObjectiveCreateManyAndReturnArgs} args - Arguments to create many WorkshopObjectives.
     * @example
     * // Create many WorkshopObjectives
     * const workshopObjective = await prisma.workshopObjective.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkshopObjectives and only return the `workshopId`
     * const workshopObjectiveWithWorkshopIdOnly = await prisma.workshopObjective.createManyAndReturn({
     *   select: { workshopId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkshopObjectiveCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkshopObjectiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopObjectivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkshopObjective.
     * @param {WorkshopObjectiveDeleteArgs} args - Arguments to delete one WorkshopObjective.
     * @example
     * // Delete one WorkshopObjective
     * const WorkshopObjective = await prisma.workshopObjective.delete({
     *   where: {
     *     // ... filter to delete one WorkshopObjective
     *   }
     * })
     * 
     */
    delete<T extends WorkshopObjectiveDeleteArgs>(args: SelectSubset<T, WorkshopObjectiveDeleteArgs<ExtArgs>>): Prisma__WorkshopObjectiveClient<$Result.GetResult<Prisma.$WorkshopObjectivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkshopObjective.
     * @param {WorkshopObjectiveUpdateArgs} args - Arguments to update one WorkshopObjective.
     * @example
     * // Update one WorkshopObjective
     * const workshopObjective = await prisma.workshopObjective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkshopObjectiveUpdateArgs>(args: SelectSubset<T, WorkshopObjectiveUpdateArgs<ExtArgs>>): Prisma__WorkshopObjectiveClient<$Result.GetResult<Prisma.$WorkshopObjectivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkshopObjectives.
     * @param {WorkshopObjectiveDeleteManyArgs} args - Arguments to filter WorkshopObjectives to delete.
     * @example
     * // Delete a few WorkshopObjectives
     * const { count } = await prisma.workshopObjective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkshopObjectiveDeleteManyArgs>(args?: SelectSubset<T, WorkshopObjectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkshopObjectives
     * const workshopObjective = await prisma.workshopObjective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkshopObjectiveUpdateManyArgs>(args: SelectSubset<T, WorkshopObjectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopObjectives and returns the data updated in the database.
     * @param {WorkshopObjectiveUpdateManyAndReturnArgs} args - Arguments to update many WorkshopObjectives.
     * @example
     * // Update many WorkshopObjectives
     * const workshopObjective = await prisma.workshopObjective.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkshopObjectives and only return the `workshopId`
     * const workshopObjectiveWithWorkshopIdOnly = await prisma.workshopObjective.updateManyAndReturn({
     *   select: { workshopId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkshopObjectiveUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkshopObjectiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopObjectivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkshopObjective.
     * @param {WorkshopObjectiveUpsertArgs} args - Arguments to update or create a WorkshopObjective.
     * @example
     * // Update or create a WorkshopObjective
     * const workshopObjective = await prisma.workshopObjective.upsert({
     *   create: {
     *     // ... data to create a WorkshopObjective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkshopObjective we want to update
     *   }
     * })
     */
    upsert<T extends WorkshopObjectiveUpsertArgs>(args: SelectSubset<T, WorkshopObjectiveUpsertArgs<ExtArgs>>): Prisma__WorkshopObjectiveClient<$Result.GetResult<Prisma.$WorkshopObjectivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkshopObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopObjectiveCountArgs} args - Arguments to filter WorkshopObjectives to count.
     * @example
     * // Count the number of WorkshopObjectives
     * const count = await prisma.workshopObjective.count({
     *   where: {
     *     // ... the filter for the WorkshopObjectives we want to count
     *   }
     * })
    **/
    count<T extends WorkshopObjectiveCountArgs>(
      args?: Subset<T, WorkshopObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkshopObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkshopObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkshopObjectiveAggregateArgs>(args: Subset<T, WorkshopObjectiveAggregateArgs>): Prisma.PrismaPromise<GetWorkshopObjectiveAggregateType<T>>

    /**
     * Group by WorkshopObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkshopObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkshopObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: WorkshopObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkshopObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkshopObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkshopObjective model
   */
  readonly fields: WorkshopObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkshopObjective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkshopObjectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workshop<T extends WorkshopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkshopDefaultArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    objective<T extends ObjectiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectiveDefaultArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkshopObjective model
   */
  interface WorkshopObjectiveFieldRefs {
    readonly workshopId: FieldRef<"WorkshopObjective", 'String'>
    readonly objectiveId: FieldRef<"WorkshopObjective", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkshopObjective findUnique
   */
  export type WorkshopObjectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopObjective to fetch.
     */
    where: WorkshopObjectiveWhereUniqueInput
  }

  /**
   * WorkshopObjective findUniqueOrThrow
   */
  export type WorkshopObjectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopObjective to fetch.
     */
    where: WorkshopObjectiveWhereUniqueInput
  }

  /**
   * WorkshopObjective findFirst
   */
  export type WorkshopObjectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopObjective to fetch.
     */
    where?: WorkshopObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopObjectives to fetch.
     */
    orderBy?: WorkshopObjectiveOrderByWithRelationInput | WorkshopObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopObjectives.
     */
    cursor?: WorkshopObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopObjectives.
     */
    distinct?: WorkshopObjectiveScalarFieldEnum | WorkshopObjectiveScalarFieldEnum[]
  }

  /**
   * WorkshopObjective findFirstOrThrow
   */
  export type WorkshopObjectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopObjective to fetch.
     */
    where?: WorkshopObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopObjectives to fetch.
     */
    orderBy?: WorkshopObjectiveOrderByWithRelationInput | WorkshopObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopObjectives.
     */
    cursor?: WorkshopObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopObjectives.
     */
    distinct?: WorkshopObjectiveScalarFieldEnum | WorkshopObjectiveScalarFieldEnum[]
  }

  /**
   * WorkshopObjective findMany
   */
  export type WorkshopObjectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopObjectives to fetch.
     */
    where?: WorkshopObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopObjectives to fetch.
     */
    orderBy?: WorkshopObjectiveOrderByWithRelationInput | WorkshopObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkshopObjectives.
     */
    cursor?: WorkshopObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopObjectives.
     */
    skip?: number
    distinct?: WorkshopObjectiveScalarFieldEnum | WorkshopObjectiveScalarFieldEnum[]
  }

  /**
   * WorkshopObjective create
   */
  export type WorkshopObjectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkshopObjective.
     */
    data: XOR<WorkshopObjectiveCreateInput, WorkshopObjectiveUncheckedCreateInput>
  }

  /**
   * WorkshopObjective createMany
   */
  export type WorkshopObjectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkshopObjectives.
     */
    data: WorkshopObjectiveCreateManyInput | WorkshopObjectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkshopObjective createManyAndReturn
   */
  export type WorkshopObjectiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * The data used to create many WorkshopObjectives.
     */
    data: WorkshopObjectiveCreateManyInput | WorkshopObjectiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopObjective update
   */
  export type WorkshopObjectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkshopObjective.
     */
    data: XOR<WorkshopObjectiveUpdateInput, WorkshopObjectiveUncheckedUpdateInput>
    /**
     * Choose, which WorkshopObjective to update.
     */
    where: WorkshopObjectiveWhereUniqueInput
  }

  /**
   * WorkshopObjective updateMany
   */
  export type WorkshopObjectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkshopObjectives.
     */
    data: XOR<WorkshopObjectiveUpdateManyMutationInput, WorkshopObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopObjectives to update
     */
    where?: WorkshopObjectiveWhereInput
    /**
     * Limit how many WorkshopObjectives to update.
     */
    limit?: number
  }

  /**
   * WorkshopObjective updateManyAndReturn
   */
  export type WorkshopObjectiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * The data used to update WorkshopObjectives.
     */
    data: XOR<WorkshopObjectiveUpdateManyMutationInput, WorkshopObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopObjectives to update
     */
    where?: WorkshopObjectiveWhereInput
    /**
     * Limit how many WorkshopObjectives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopObjective upsert
   */
  export type WorkshopObjectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkshopObjective to update in case it exists.
     */
    where: WorkshopObjectiveWhereUniqueInput
    /**
     * In case the WorkshopObjective found by the `where` argument doesn't exist, create a new WorkshopObjective with this data.
     */
    create: XOR<WorkshopObjectiveCreateInput, WorkshopObjectiveUncheckedCreateInput>
    /**
     * In case the WorkshopObjective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkshopObjectiveUpdateInput, WorkshopObjectiveUncheckedUpdateInput>
  }

  /**
   * WorkshopObjective delete
   */
  export type WorkshopObjectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveInclude<ExtArgs> | null
    /**
     * Filter which WorkshopObjective to delete.
     */
    where: WorkshopObjectiveWhereUniqueInput
  }

  /**
   * WorkshopObjective deleteMany
   */
  export type WorkshopObjectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopObjectives to delete
     */
    where?: WorkshopObjectiveWhereInput
    /**
     * Limit how many WorkshopObjectives to delete.
     */
    limit?: number
  }

  /**
   * WorkshopObjective without action
   */
  export type WorkshopObjectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopObjective
     */
    select?: WorkshopObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopObjective
     */
    omit?: WorkshopObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopObjectiveInclude<ExtArgs> | null
  }


  /**
   * Model WorkshopPrerequisite
   */

  export type AggregateWorkshopPrerequisite = {
    _count: WorkshopPrerequisiteCountAggregateOutputType | null
    _min: WorkshopPrerequisiteMinAggregateOutputType | null
    _max: WorkshopPrerequisiteMaxAggregateOutputType | null
  }

  export type WorkshopPrerequisiteMinAggregateOutputType = {
    workshopId: string | null
    prerequisiteId: string | null
  }

  export type WorkshopPrerequisiteMaxAggregateOutputType = {
    workshopId: string | null
    prerequisiteId: string | null
  }

  export type WorkshopPrerequisiteCountAggregateOutputType = {
    workshopId: number
    prerequisiteId: number
    _all: number
  }


  export type WorkshopPrerequisiteMinAggregateInputType = {
    workshopId?: true
    prerequisiteId?: true
  }

  export type WorkshopPrerequisiteMaxAggregateInputType = {
    workshopId?: true
    prerequisiteId?: true
  }

  export type WorkshopPrerequisiteCountAggregateInputType = {
    workshopId?: true
    prerequisiteId?: true
    _all?: true
  }

  export type WorkshopPrerequisiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopPrerequisite to aggregate.
     */
    where?: WorkshopPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopPrerequisites to fetch.
     */
    orderBy?: WorkshopPrerequisiteOrderByWithRelationInput | WorkshopPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkshopPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkshopPrerequisites
    **/
    _count?: true | WorkshopPrerequisiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkshopPrerequisiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkshopPrerequisiteMaxAggregateInputType
  }

  export type GetWorkshopPrerequisiteAggregateType<T extends WorkshopPrerequisiteAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkshopPrerequisite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkshopPrerequisite[P]>
      : GetScalarType<T[P], AggregateWorkshopPrerequisite[P]>
  }




  export type WorkshopPrerequisiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopPrerequisiteWhereInput
    orderBy?: WorkshopPrerequisiteOrderByWithAggregationInput | WorkshopPrerequisiteOrderByWithAggregationInput[]
    by: WorkshopPrerequisiteScalarFieldEnum[] | WorkshopPrerequisiteScalarFieldEnum
    having?: WorkshopPrerequisiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkshopPrerequisiteCountAggregateInputType | true
    _min?: WorkshopPrerequisiteMinAggregateInputType
    _max?: WorkshopPrerequisiteMaxAggregateInputType
  }

  export type WorkshopPrerequisiteGroupByOutputType = {
    workshopId: string
    prerequisiteId: string
    _count: WorkshopPrerequisiteCountAggregateOutputType | null
    _min: WorkshopPrerequisiteMinAggregateOutputType | null
    _max: WorkshopPrerequisiteMaxAggregateOutputType | null
  }

  type GetWorkshopPrerequisiteGroupByPayload<T extends WorkshopPrerequisiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkshopPrerequisiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkshopPrerequisiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkshopPrerequisiteGroupByOutputType[P]>
            : GetScalarType<T[P], WorkshopPrerequisiteGroupByOutputType[P]>
        }
      >
    >


  export type WorkshopPrerequisiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workshopId?: boolean
    prerequisiteId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopPrerequisite"]>

  export type WorkshopPrerequisiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workshopId?: boolean
    prerequisiteId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopPrerequisite"]>

  export type WorkshopPrerequisiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workshopId?: boolean
    prerequisiteId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopPrerequisite"]>

  export type WorkshopPrerequisiteSelectScalar = {
    workshopId?: boolean
    prerequisiteId?: boolean
  }

  export type WorkshopPrerequisiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workshopId" | "prerequisiteId", ExtArgs["result"]["workshopPrerequisite"]>
  export type WorkshopPrerequisiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }
  export type WorkshopPrerequisiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }
  export type WorkshopPrerequisiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }

  export type $WorkshopPrerequisitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkshopPrerequisite"
    objects: {
      workshop: Prisma.$WorkshopPayload<ExtArgs>
      prerequisite: Prisma.$PrerequisitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workshopId: string
      prerequisiteId: string
    }, ExtArgs["result"]["workshopPrerequisite"]>
    composites: {}
  }

  type WorkshopPrerequisiteGetPayload<S extends boolean | null | undefined | WorkshopPrerequisiteDefaultArgs> = $Result.GetResult<Prisma.$WorkshopPrerequisitePayload, S>

  type WorkshopPrerequisiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkshopPrerequisiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkshopPrerequisiteCountAggregateInputType | true
    }

  export interface WorkshopPrerequisiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkshopPrerequisite'], meta: { name: 'WorkshopPrerequisite' } }
    /**
     * Find zero or one WorkshopPrerequisite that matches the filter.
     * @param {WorkshopPrerequisiteFindUniqueArgs} args - Arguments to find a WorkshopPrerequisite
     * @example
     * // Get one WorkshopPrerequisite
     * const workshopPrerequisite = await prisma.workshopPrerequisite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkshopPrerequisiteFindUniqueArgs>(args: SelectSubset<T, WorkshopPrerequisiteFindUniqueArgs<ExtArgs>>): Prisma__WorkshopPrerequisiteClient<$Result.GetResult<Prisma.$WorkshopPrerequisitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkshopPrerequisite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkshopPrerequisiteFindUniqueOrThrowArgs} args - Arguments to find a WorkshopPrerequisite
     * @example
     * // Get one WorkshopPrerequisite
     * const workshopPrerequisite = await prisma.workshopPrerequisite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkshopPrerequisiteFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkshopPrerequisiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkshopPrerequisiteClient<$Result.GetResult<Prisma.$WorkshopPrerequisitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopPrerequisite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopPrerequisiteFindFirstArgs} args - Arguments to find a WorkshopPrerequisite
     * @example
     * // Get one WorkshopPrerequisite
     * const workshopPrerequisite = await prisma.workshopPrerequisite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkshopPrerequisiteFindFirstArgs>(args?: SelectSubset<T, WorkshopPrerequisiteFindFirstArgs<ExtArgs>>): Prisma__WorkshopPrerequisiteClient<$Result.GetResult<Prisma.$WorkshopPrerequisitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopPrerequisite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopPrerequisiteFindFirstOrThrowArgs} args - Arguments to find a WorkshopPrerequisite
     * @example
     * // Get one WorkshopPrerequisite
     * const workshopPrerequisite = await prisma.workshopPrerequisite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkshopPrerequisiteFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkshopPrerequisiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkshopPrerequisiteClient<$Result.GetResult<Prisma.$WorkshopPrerequisitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkshopPrerequisites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopPrerequisiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkshopPrerequisites
     * const workshopPrerequisites = await prisma.workshopPrerequisite.findMany()
     * 
     * // Get first 10 WorkshopPrerequisites
     * const workshopPrerequisites = await prisma.workshopPrerequisite.findMany({ take: 10 })
     * 
     * // Only select the `workshopId`
     * const workshopPrerequisiteWithWorkshopIdOnly = await prisma.workshopPrerequisite.findMany({ select: { workshopId: true } })
     * 
     */
    findMany<T extends WorkshopPrerequisiteFindManyArgs>(args?: SelectSubset<T, WorkshopPrerequisiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkshopPrerequisite.
     * @param {WorkshopPrerequisiteCreateArgs} args - Arguments to create a WorkshopPrerequisite.
     * @example
     * // Create one WorkshopPrerequisite
     * const WorkshopPrerequisite = await prisma.workshopPrerequisite.create({
     *   data: {
     *     // ... data to create a WorkshopPrerequisite
     *   }
     * })
     * 
     */
    create<T extends WorkshopPrerequisiteCreateArgs>(args: SelectSubset<T, WorkshopPrerequisiteCreateArgs<ExtArgs>>): Prisma__WorkshopPrerequisiteClient<$Result.GetResult<Prisma.$WorkshopPrerequisitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkshopPrerequisites.
     * @param {WorkshopPrerequisiteCreateManyArgs} args - Arguments to create many WorkshopPrerequisites.
     * @example
     * // Create many WorkshopPrerequisites
     * const workshopPrerequisite = await prisma.workshopPrerequisite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkshopPrerequisiteCreateManyArgs>(args?: SelectSubset<T, WorkshopPrerequisiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkshopPrerequisites and returns the data saved in the database.
     * @param {WorkshopPrerequisiteCreateManyAndReturnArgs} args - Arguments to create many WorkshopPrerequisites.
     * @example
     * // Create many WorkshopPrerequisites
     * const workshopPrerequisite = await prisma.workshopPrerequisite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkshopPrerequisites and only return the `workshopId`
     * const workshopPrerequisiteWithWorkshopIdOnly = await prisma.workshopPrerequisite.createManyAndReturn({
     *   select: { workshopId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkshopPrerequisiteCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkshopPrerequisiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPrerequisitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkshopPrerequisite.
     * @param {WorkshopPrerequisiteDeleteArgs} args - Arguments to delete one WorkshopPrerequisite.
     * @example
     * // Delete one WorkshopPrerequisite
     * const WorkshopPrerequisite = await prisma.workshopPrerequisite.delete({
     *   where: {
     *     // ... filter to delete one WorkshopPrerequisite
     *   }
     * })
     * 
     */
    delete<T extends WorkshopPrerequisiteDeleteArgs>(args: SelectSubset<T, WorkshopPrerequisiteDeleteArgs<ExtArgs>>): Prisma__WorkshopPrerequisiteClient<$Result.GetResult<Prisma.$WorkshopPrerequisitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkshopPrerequisite.
     * @param {WorkshopPrerequisiteUpdateArgs} args - Arguments to update one WorkshopPrerequisite.
     * @example
     * // Update one WorkshopPrerequisite
     * const workshopPrerequisite = await prisma.workshopPrerequisite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkshopPrerequisiteUpdateArgs>(args: SelectSubset<T, WorkshopPrerequisiteUpdateArgs<ExtArgs>>): Prisma__WorkshopPrerequisiteClient<$Result.GetResult<Prisma.$WorkshopPrerequisitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkshopPrerequisites.
     * @param {WorkshopPrerequisiteDeleteManyArgs} args - Arguments to filter WorkshopPrerequisites to delete.
     * @example
     * // Delete a few WorkshopPrerequisites
     * const { count } = await prisma.workshopPrerequisite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkshopPrerequisiteDeleteManyArgs>(args?: SelectSubset<T, WorkshopPrerequisiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopPrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopPrerequisiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkshopPrerequisites
     * const workshopPrerequisite = await prisma.workshopPrerequisite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkshopPrerequisiteUpdateManyArgs>(args: SelectSubset<T, WorkshopPrerequisiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopPrerequisites and returns the data updated in the database.
     * @param {WorkshopPrerequisiteUpdateManyAndReturnArgs} args - Arguments to update many WorkshopPrerequisites.
     * @example
     * // Update many WorkshopPrerequisites
     * const workshopPrerequisite = await prisma.workshopPrerequisite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkshopPrerequisites and only return the `workshopId`
     * const workshopPrerequisiteWithWorkshopIdOnly = await prisma.workshopPrerequisite.updateManyAndReturn({
     *   select: { workshopId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkshopPrerequisiteUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkshopPrerequisiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPrerequisitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkshopPrerequisite.
     * @param {WorkshopPrerequisiteUpsertArgs} args - Arguments to update or create a WorkshopPrerequisite.
     * @example
     * // Update or create a WorkshopPrerequisite
     * const workshopPrerequisite = await prisma.workshopPrerequisite.upsert({
     *   create: {
     *     // ... data to create a WorkshopPrerequisite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkshopPrerequisite we want to update
     *   }
     * })
     */
    upsert<T extends WorkshopPrerequisiteUpsertArgs>(args: SelectSubset<T, WorkshopPrerequisiteUpsertArgs<ExtArgs>>): Prisma__WorkshopPrerequisiteClient<$Result.GetResult<Prisma.$WorkshopPrerequisitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkshopPrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopPrerequisiteCountArgs} args - Arguments to filter WorkshopPrerequisites to count.
     * @example
     * // Count the number of WorkshopPrerequisites
     * const count = await prisma.workshopPrerequisite.count({
     *   where: {
     *     // ... the filter for the WorkshopPrerequisites we want to count
     *   }
     * })
    **/
    count<T extends WorkshopPrerequisiteCountArgs>(
      args?: Subset<T, WorkshopPrerequisiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkshopPrerequisiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkshopPrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopPrerequisiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkshopPrerequisiteAggregateArgs>(args: Subset<T, WorkshopPrerequisiteAggregateArgs>): Prisma.PrismaPromise<GetWorkshopPrerequisiteAggregateType<T>>

    /**
     * Group by WorkshopPrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopPrerequisiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkshopPrerequisiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkshopPrerequisiteGroupByArgs['orderBy'] }
        : { orderBy?: WorkshopPrerequisiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkshopPrerequisiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkshopPrerequisiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkshopPrerequisite model
   */
  readonly fields: WorkshopPrerequisiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkshopPrerequisite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkshopPrerequisiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workshop<T extends WorkshopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkshopDefaultArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prerequisite<T extends PrerequisiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrerequisiteDefaultArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkshopPrerequisite model
   */
  interface WorkshopPrerequisiteFieldRefs {
    readonly workshopId: FieldRef<"WorkshopPrerequisite", 'String'>
    readonly prerequisiteId: FieldRef<"WorkshopPrerequisite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkshopPrerequisite findUnique
   */
  export type WorkshopPrerequisiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopPrerequisite to fetch.
     */
    where: WorkshopPrerequisiteWhereUniqueInput
  }

  /**
   * WorkshopPrerequisite findUniqueOrThrow
   */
  export type WorkshopPrerequisiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopPrerequisite to fetch.
     */
    where: WorkshopPrerequisiteWhereUniqueInput
  }

  /**
   * WorkshopPrerequisite findFirst
   */
  export type WorkshopPrerequisiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopPrerequisite to fetch.
     */
    where?: WorkshopPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopPrerequisites to fetch.
     */
    orderBy?: WorkshopPrerequisiteOrderByWithRelationInput | WorkshopPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopPrerequisites.
     */
    cursor?: WorkshopPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopPrerequisites.
     */
    distinct?: WorkshopPrerequisiteScalarFieldEnum | WorkshopPrerequisiteScalarFieldEnum[]
  }

  /**
   * WorkshopPrerequisite findFirstOrThrow
   */
  export type WorkshopPrerequisiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopPrerequisite to fetch.
     */
    where?: WorkshopPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopPrerequisites to fetch.
     */
    orderBy?: WorkshopPrerequisiteOrderByWithRelationInput | WorkshopPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopPrerequisites.
     */
    cursor?: WorkshopPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopPrerequisites.
     */
    distinct?: WorkshopPrerequisiteScalarFieldEnum | WorkshopPrerequisiteScalarFieldEnum[]
  }

  /**
   * WorkshopPrerequisite findMany
   */
  export type WorkshopPrerequisiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopPrerequisites to fetch.
     */
    where?: WorkshopPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopPrerequisites to fetch.
     */
    orderBy?: WorkshopPrerequisiteOrderByWithRelationInput | WorkshopPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkshopPrerequisites.
     */
    cursor?: WorkshopPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopPrerequisites.
     */
    skip?: number
    distinct?: WorkshopPrerequisiteScalarFieldEnum | WorkshopPrerequisiteScalarFieldEnum[]
  }

  /**
   * WorkshopPrerequisite create
   */
  export type WorkshopPrerequisiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkshopPrerequisite.
     */
    data: XOR<WorkshopPrerequisiteCreateInput, WorkshopPrerequisiteUncheckedCreateInput>
  }

  /**
   * WorkshopPrerequisite createMany
   */
  export type WorkshopPrerequisiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkshopPrerequisites.
     */
    data: WorkshopPrerequisiteCreateManyInput | WorkshopPrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkshopPrerequisite createManyAndReturn
   */
  export type WorkshopPrerequisiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to create many WorkshopPrerequisites.
     */
    data: WorkshopPrerequisiteCreateManyInput | WorkshopPrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopPrerequisite update
   */
  export type WorkshopPrerequisiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkshopPrerequisite.
     */
    data: XOR<WorkshopPrerequisiteUpdateInput, WorkshopPrerequisiteUncheckedUpdateInput>
    /**
     * Choose, which WorkshopPrerequisite to update.
     */
    where: WorkshopPrerequisiteWhereUniqueInput
  }

  /**
   * WorkshopPrerequisite updateMany
   */
  export type WorkshopPrerequisiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkshopPrerequisites.
     */
    data: XOR<WorkshopPrerequisiteUpdateManyMutationInput, WorkshopPrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopPrerequisites to update
     */
    where?: WorkshopPrerequisiteWhereInput
    /**
     * Limit how many WorkshopPrerequisites to update.
     */
    limit?: number
  }

  /**
   * WorkshopPrerequisite updateManyAndReturn
   */
  export type WorkshopPrerequisiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to update WorkshopPrerequisites.
     */
    data: XOR<WorkshopPrerequisiteUpdateManyMutationInput, WorkshopPrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopPrerequisites to update
     */
    where?: WorkshopPrerequisiteWhereInput
    /**
     * Limit how many WorkshopPrerequisites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopPrerequisite upsert
   */
  export type WorkshopPrerequisiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkshopPrerequisite to update in case it exists.
     */
    where: WorkshopPrerequisiteWhereUniqueInput
    /**
     * In case the WorkshopPrerequisite found by the `where` argument doesn't exist, create a new WorkshopPrerequisite with this data.
     */
    create: XOR<WorkshopPrerequisiteCreateInput, WorkshopPrerequisiteUncheckedCreateInput>
    /**
     * In case the WorkshopPrerequisite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkshopPrerequisiteUpdateInput, WorkshopPrerequisiteUncheckedUpdateInput>
  }

  /**
   * WorkshopPrerequisite delete
   */
  export type WorkshopPrerequisiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter which WorkshopPrerequisite to delete.
     */
    where: WorkshopPrerequisiteWhereUniqueInput
  }

  /**
   * WorkshopPrerequisite deleteMany
   */
  export type WorkshopPrerequisiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopPrerequisites to delete
     */
    where?: WorkshopPrerequisiteWhereInput
    /**
     * Limit how many WorkshopPrerequisites to delete.
     */
    limit?: number
  }

  /**
   * WorkshopPrerequisite without action
   */
  export type WorkshopPrerequisiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopPrerequisite
     */
    select?: WorkshopPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopPrerequisite
     */
    omit?: WorkshopPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopPrerequisiteInclude<ExtArgs> | null
  }


  /**
   * Model LearningPathObjective
   */

  export type AggregateLearningPathObjective = {
    _count: LearningPathObjectiveCountAggregateOutputType | null
    _min: LearningPathObjectiveMinAggregateOutputType | null
    _max: LearningPathObjectiveMaxAggregateOutputType | null
  }

  export type LearningPathObjectiveMinAggregateOutputType = {
    learningPathId: string | null
    objectiveId: string | null
  }

  export type LearningPathObjectiveMaxAggregateOutputType = {
    learningPathId: string | null
    objectiveId: string | null
  }

  export type LearningPathObjectiveCountAggregateOutputType = {
    learningPathId: number
    objectiveId: number
    _all: number
  }


  export type LearningPathObjectiveMinAggregateInputType = {
    learningPathId?: true
    objectiveId?: true
  }

  export type LearningPathObjectiveMaxAggregateInputType = {
    learningPathId?: true
    objectiveId?: true
  }

  export type LearningPathObjectiveCountAggregateInputType = {
    learningPathId?: true
    objectiveId?: true
    _all?: true
  }

  export type LearningPathObjectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPathObjective to aggregate.
     */
    where?: LearningPathObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathObjectives to fetch.
     */
    orderBy?: LearningPathObjectiveOrderByWithRelationInput | LearningPathObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningPathObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningPathObjectives
    **/
    _count?: true | LearningPathObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningPathObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningPathObjectiveMaxAggregateInputType
  }

  export type GetLearningPathObjectiveAggregateType<T extends LearningPathObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningPathObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningPathObjective[P]>
      : GetScalarType<T[P], AggregateLearningPathObjective[P]>
  }




  export type LearningPathObjectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathObjectiveWhereInput
    orderBy?: LearningPathObjectiveOrderByWithAggregationInput | LearningPathObjectiveOrderByWithAggregationInput[]
    by: LearningPathObjectiveScalarFieldEnum[] | LearningPathObjectiveScalarFieldEnum
    having?: LearningPathObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningPathObjectiveCountAggregateInputType | true
    _min?: LearningPathObjectiveMinAggregateInputType
    _max?: LearningPathObjectiveMaxAggregateInputType
  }

  export type LearningPathObjectiveGroupByOutputType = {
    learningPathId: string
    objectiveId: string
    _count: LearningPathObjectiveCountAggregateOutputType | null
    _min: LearningPathObjectiveMinAggregateOutputType | null
    _max: LearningPathObjectiveMaxAggregateOutputType | null
  }

  type GetLearningPathObjectiveGroupByPayload<T extends LearningPathObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningPathObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningPathObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningPathObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], LearningPathObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type LearningPathObjectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learningPathId?: boolean
    objectiveId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathObjective"]>

  export type LearningPathObjectiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learningPathId?: boolean
    objectiveId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathObjective"]>

  export type LearningPathObjectiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learningPathId?: boolean
    objectiveId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathObjective"]>

  export type LearningPathObjectiveSelectScalar = {
    learningPathId?: boolean
    objectiveId?: boolean
  }

  export type LearningPathObjectiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"learningPathId" | "objectiveId", ExtArgs["result"]["learningPathObjective"]>
  export type LearningPathObjectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }
  export type LearningPathObjectiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }
  export type LearningPathObjectiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    objective?: boolean | ObjectiveDefaultArgs<ExtArgs>
  }

  export type $LearningPathObjectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningPathObjective"
    objects: {
      learningPath: Prisma.$LearningPathPayload<ExtArgs>
      objective: Prisma.$ObjectivePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      learningPathId: string
      objectiveId: string
    }, ExtArgs["result"]["learningPathObjective"]>
    composites: {}
  }

  type LearningPathObjectiveGetPayload<S extends boolean | null | undefined | LearningPathObjectiveDefaultArgs> = $Result.GetResult<Prisma.$LearningPathObjectivePayload, S>

  type LearningPathObjectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningPathObjectiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningPathObjectiveCountAggregateInputType | true
    }

  export interface LearningPathObjectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningPathObjective'], meta: { name: 'LearningPathObjective' } }
    /**
     * Find zero or one LearningPathObjective that matches the filter.
     * @param {LearningPathObjectiveFindUniqueArgs} args - Arguments to find a LearningPathObjective
     * @example
     * // Get one LearningPathObjective
     * const learningPathObjective = await prisma.learningPathObjective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningPathObjectiveFindUniqueArgs>(args: SelectSubset<T, LearningPathObjectiveFindUniqueArgs<ExtArgs>>): Prisma__LearningPathObjectiveClient<$Result.GetResult<Prisma.$LearningPathObjectivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LearningPathObjective that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningPathObjectiveFindUniqueOrThrowArgs} args - Arguments to find a LearningPathObjective
     * @example
     * // Get one LearningPathObjective
     * const learningPathObjective = await prisma.learningPathObjective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningPathObjectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningPathObjectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningPathObjectiveClient<$Result.GetResult<Prisma.$LearningPathObjectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningPathObjective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathObjectiveFindFirstArgs} args - Arguments to find a LearningPathObjective
     * @example
     * // Get one LearningPathObjective
     * const learningPathObjective = await prisma.learningPathObjective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningPathObjectiveFindFirstArgs>(args?: SelectSubset<T, LearningPathObjectiveFindFirstArgs<ExtArgs>>): Prisma__LearningPathObjectiveClient<$Result.GetResult<Prisma.$LearningPathObjectivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningPathObjective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathObjectiveFindFirstOrThrowArgs} args - Arguments to find a LearningPathObjective
     * @example
     * // Get one LearningPathObjective
     * const learningPathObjective = await prisma.learningPathObjective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningPathObjectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningPathObjectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningPathObjectiveClient<$Result.GetResult<Prisma.$LearningPathObjectivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LearningPathObjectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningPathObjectives
     * const learningPathObjectives = await prisma.learningPathObjective.findMany()
     * 
     * // Get first 10 LearningPathObjectives
     * const learningPathObjectives = await prisma.learningPathObjective.findMany({ take: 10 })
     * 
     * // Only select the `learningPathId`
     * const learningPathObjectiveWithLearningPathIdOnly = await prisma.learningPathObjective.findMany({ select: { learningPathId: true } })
     * 
     */
    findMany<T extends LearningPathObjectiveFindManyArgs>(args?: SelectSubset<T, LearningPathObjectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LearningPathObjective.
     * @param {LearningPathObjectiveCreateArgs} args - Arguments to create a LearningPathObjective.
     * @example
     * // Create one LearningPathObjective
     * const LearningPathObjective = await prisma.learningPathObjective.create({
     *   data: {
     *     // ... data to create a LearningPathObjective
     *   }
     * })
     * 
     */
    create<T extends LearningPathObjectiveCreateArgs>(args: SelectSubset<T, LearningPathObjectiveCreateArgs<ExtArgs>>): Prisma__LearningPathObjectiveClient<$Result.GetResult<Prisma.$LearningPathObjectivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LearningPathObjectives.
     * @param {LearningPathObjectiveCreateManyArgs} args - Arguments to create many LearningPathObjectives.
     * @example
     * // Create many LearningPathObjectives
     * const learningPathObjective = await prisma.learningPathObjective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningPathObjectiveCreateManyArgs>(args?: SelectSubset<T, LearningPathObjectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningPathObjectives and returns the data saved in the database.
     * @param {LearningPathObjectiveCreateManyAndReturnArgs} args - Arguments to create many LearningPathObjectives.
     * @example
     * // Create many LearningPathObjectives
     * const learningPathObjective = await prisma.learningPathObjective.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningPathObjectives and only return the `learningPathId`
     * const learningPathObjectiveWithLearningPathIdOnly = await prisma.learningPathObjective.createManyAndReturn({
     *   select: { learningPathId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningPathObjectiveCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningPathObjectiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathObjectivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LearningPathObjective.
     * @param {LearningPathObjectiveDeleteArgs} args - Arguments to delete one LearningPathObjective.
     * @example
     * // Delete one LearningPathObjective
     * const LearningPathObjective = await prisma.learningPathObjective.delete({
     *   where: {
     *     // ... filter to delete one LearningPathObjective
     *   }
     * })
     * 
     */
    delete<T extends LearningPathObjectiveDeleteArgs>(args: SelectSubset<T, LearningPathObjectiveDeleteArgs<ExtArgs>>): Prisma__LearningPathObjectiveClient<$Result.GetResult<Prisma.$LearningPathObjectivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LearningPathObjective.
     * @param {LearningPathObjectiveUpdateArgs} args - Arguments to update one LearningPathObjective.
     * @example
     * // Update one LearningPathObjective
     * const learningPathObjective = await prisma.learningPathObjective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningPathObjectiveUpdateArgs>(args: SelectSubset<T, LearningPathObjectiveUpdateArgs<ExtArgs>>): Prisma__LearningPathObjectiveClient<$Result.GetResult<Prisma.$LearningPathObjectivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LearningPathObjectives.
     * @param {LearningPathObjectiveDeleteManyArgs} args - Arguments to filter LearningPathObjectives to delete.
     * @example
     * // Delete a few LearningPathObjectives
     * const { count } = await prisma.learningPathObjective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningPathObjectiveDeleteManyArgs>(args?: SelectSubset<T, LearningPathObjectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPathObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningPathObjectives
     * const learningPathObjective = await prisma.learningPathObjective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningPathObjectiveUpdateManyArgs>(args: SelectSubset<T, LearningPathObjectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPathObjectives and returns the data updated in the database.
     * @param {LearningPathObjectiveUpdateManyAndReturnArgs} args - Arguments to update many LearningPathObjectives.
     * @example
     * // Update many LearningPathObjectives
     * const learningPathObjective = await prisma.learningPathObjective.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningPathObjectives and only return the `learningPathId`
     * const learningPathObjectiveWithLearningPathIdOnly = await prisma.learningPathObjective.updateManyAndReturn({
     *   select: { learningPathId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningPathObjectiveUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningPathObjectiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathObjectivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LearningPathObjective.
     * @param {LearningPathObjectiveUpsertArgs} args - Arguments to update or create a LearningPathObjective.
     * @example
     * // Update or create a LearningPathObjective
     * const learningPathObjective = await prisma.learningPathObjective.upsert({
     *   create: {
     *     // ... data to create a LearningPathObjective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningPathObjective we want to update
     *   }
     * })
     */
    upsert<T extends LearningPathObjectiveUpsertArgs>(args: SelectSubset<T, LearningPathObjectiveUpsertArgs<ExtArgs>>): Prisma__LearningPathObjectiveClient<$Result.GetResult<Prisma.$LearningPathObjectivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LearningPathObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathObjectiveCountArgs} args - Arguments to filter LearningPathObjectives to count.
     * @example
     * // Count the number of LearningPathObjectives
     * const count = await prisma.learningPathObjective.count({
     *   where: {
     *     // ... the filter for the LearningPathObjectives we want to count
     *   }
     * })
    **/
    count<T extends LearningPathObjectiveCountArgs>(
      args?: Subset<T, LearningPathObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningPathObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningPathObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningPathObjectiveAggregateArgs>(args: Subset<T, LearningPathObjectiveAggregateArgs>): Prisma.PrismaPromise<GetLearningPathObjectiveAggregateType<T>>

    /**
     * Group by LearningPathObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningPathObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningPathObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: LearningPathObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningPathObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningPathObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningPathObjective model
   */
  readonly fields: LearningPathObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningPathObjective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningPathObjectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learningPath<T extends LearningPathDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathDefaultArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    objective<T extends ObjectiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectiveDefaultArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningPathObjective model
   */
  interface LearningPathObjectiveFieldRefs {
    readonly learningPathId: FieldRef<"LearningPathObjective", 'String'>
    readonly objectiveId: FieldRef<"LearningPathObjective", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LearningPathObjective findUnique
   */
  export type LearningPathObjectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathObjective to fetch.
     */
    where: LearningPathObjectiveWhereUniqueInput
  }

  /**
   * LearningPathObjective findUniqueOrThrow
   */
  export type LearningPathObjectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathObjective to fetch.
     */
    where: LearningPathObjectiveWhereUniqueInput
  }

  /**
   * LearningPathObjective findFirst
   */
  export type LearningPathObjectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathObjective to fetch.
     */
    where?: LearningPathObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathObjectives to fetch.
     */
    orderBy?: LearningPathObjectiveOrderByWithRelationInput | LearningPathObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPathObjectives.
     */
    cursor?: LearningPathObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPathObjectives.
     */
    distinct?: LearningPathObjectiveScalarFieldEnum | LearningPathObjectiveScalarFieldEnum[]
  }

  /**
   * LearningPathObjective findFirstOrThrow
   */
  export type LearningPathObjectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathObjective to fetch.
     */
    where?: LearningPathObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathObjectives to fetch.
     */
    orderBy?: LearningPathObjectiveOrderByWithRelationInput | LearningPathObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPathObjectives.
     */
    cursor?: LearningPathObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPathObjectives.
     */
    distinct?: LearningPathObjectiveScalarFieldEnum | LearningPathObjectiveScalarFieldEnum[]
  }

  /**
   * LearningPathObjective findMany
   */
  export type LearningPathObjectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathObjectives to fetch.
     */
    where?: LearningPathObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathObjectives to fetch.
     */
    orderBy?: LearningPathObjectiveOrderByWithRelationInput | LearningPathObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningPathObjectives.
     */
    cursor?: LearningPathObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathObjectives.
     */
    skip?: number
    distinct?: LearningPathObjectiveScalarFieldEnum | LearningPathObjectiveScalarFieldEnum[]
  }

  /**
   * LearningPathObjective create
   */
  export type LearningPathObjectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningPathObjective.
     */
    data: XOR<LearningPathObjectiveCreateInput, LearningPathObjectiveUncheckedCreateInput>
  }

  /**
   * LearningPathObjective createMany
   */
  export type LearningPathObjectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningPathObjectives.
     */
    data: LearningPathObjectiveCreateManyInput | LearningPathObjectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningPathObjective createManyAndReturn
   */
  export type LearningPathObjectiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * The data used to create many LearningPathObjectives.
     */
    data: LearningPathObjectiveCreateManyInput | LearningPathObjectiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPathObjective update
   */
  export type LearningPathObjectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningPathObjective.
     */
    data: XOR<LearningPathObjectiveUpdateInput, LearningPathObjectiveUncheckedUpdateInput>
    /**
     * Choose, which LearningPathObjective to update.
     */
    where: LearningPathObjectiveWhereUniqueInput
  }

  /**
   * LearningPathObjective updateMany
   */
  export type LearningPathObjectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningPathObjectives.
     */
    data: XOR<LearningPathObjectiveUpdateManyMutationInput, LearningPathObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which LearningPathObjectives to update
     */
    where?: LearningPathObjectiveWhereInput
    /**
     * Limit how many LearningPathObjectives to update.
     */
    limit?: number
  }

  /**
   * LearningPathObjective updateManyAndReturn
   */
  export type LearningPathObjectiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * The data used to update LearningPathObjectives.
     */
    data: XOR<LearningPathObjectiveUpdateManyMutationInput, LearningPathObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which LearningPathObjectives to update
     */
    where?: LearningPathObjectiveWhereInput
    /**
     * Limit how many LearningPathObjectives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPathObjective upsert
   */
  export type LearningPathObjectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningPathObjective to update in case it exists.
     */
    where: LearningPathObjectiveWhereUniqueInput
    /**
     * In case the LearningPathObjective found by the `where` argument doesn't exist, create a new LearningPathObjective with this data.
     */
    create: XOR<LearningPathObjectiveCreateInput, LearningPathObjectiveUncheckedCreateInput>
    /**
     * In case the LearningPathObjective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningPathObjectiveUpdateInput, LearningPathObjectiveUncheckedUpdateInput>
  }

  /**
   * LearningPathObjective delete
   */
  export type LearningPathObjectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveInclude<ExtArgs> | null
    /**
     * Filter which LearningPathObjective to delete.
     */
    where: LearningPathObjectiveWhereUniqueInput
  }

  /**
   * LearningPathObjective deleteMany
   */
  export type LearningPathObjectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPathObjectives to delete
     */
    where?: LearningPathObjectiveWhereInput
    /**
     * Limit how many LearningPathObjectives to delete.
     */
    limit?: number
  }

  /**
   * LearningPathObjective without action
   */
  export type LearningPathObjectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathObjective
     */
    select?: LearningPathObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathObjective
     */
    omit?: LearningPathObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathObjectiveInclude<ExtArgs> | null
  }


  /**
   * Model LearningPathPrerequisite
   */

  export type AggregateLearningPathPrerequisite = {
    _count: LearningPathPrerequisiteCountAggregateOutputType | null
    _min: LearningPathPrerequisiteMinAggregateOutputType | null
    _max: LearningPathPrerequisiteMaxAggregateOutputType | null
  }

  export type LearningPathPrerequisiteMinAggregateOutputType = {
    learningPathId: string | null
    prerequisiteId: string | null
  }

  export type LearningPathPrerequisiteMaxAggregateOutputType = {
    learningPathId: string | null
    prerequisiteId: string | null
  }

  export type LearningPathPrerequisiteCountAggregateOutputType = {
    learningPathId: number
    prerequisiteId: number
    _all: number
  }


  export type LearningPathPrerequisiteMinAggregateInputType = {
    learningPathId?: true
    prerequisiteId?: true
  }

  export type LearningPathPrerequisiteMaxAggregateInputType = {
    learningPathId?: true
    prerequisiteId?: true
  }

  export type LearningPathPrerequisiteCountAggregateInputType = {
    learningPathId?: true
    prerequisiteId?: true
    _all?: true
  }

  export type LearningPathPrerequisiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPathPrerequisite to aggregate.
     */
    where?: LearningPathPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathPrerequisites to fetch.
     */
    orderBy?: LearningPathPrerequisiteOrderByWithRelationInput | LearningPathPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningPathPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningPathPrerequisites
    **/
    _count?: true | LearningPathPrerequisiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningPathPrerequisiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningPathPrerequisiteMaxAggregateInputType
  }

  export type GetLearningPathPrerequisiteAggregateType<T extends LearningPathPrerequisiteAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningPathPrerequisite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningPathPrerequisite[P]>
      : GetScalarType<T[P], AggregateLearningPathPrerequisite[P]>
  }




  export type LearningPathPrerequisiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathPrerequisiteWhereInput
    orderBy?: LearningPathPrerequisiteOrderByWithAggregationInput | LearningPathPrerequisiteOrderByWithAggregationInput[]
    by: LearningPathPrerequisiteScalarFieldEnum[] | LearningPathPrerequisiteScalarFieldEnum
    having?: LearningPathPrerequisiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningPathPrerequisiteCountAggregateInputType | true
    _min?: LearningPathPrerequisiteMinAggregateInputType
    _max?: LearningPathPrerequisiteMaxAggregateInputType
  }

  export type LearningPathPrerequisiteGroupByOutputType = {
    learningPathId: string
    prerequisiteId: string
    _count: LearningPathPrerequisiteCountAggregateOutputType | null
    _min: LearningPathPrerequisiteMinAggregateOutputType | null
    _max: LearningPathPrerequisiteMaxAggregateOutputType | null
  }

  type GetLearningPathPrerequisiteGroupByPayload<T extends LearningPathPrerequisiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningPathPrerequisiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningPathPrerequisiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningPathPrerequisiteGroupByOutputType[P]>
            : GetScalarType<T[P], LearningPathPrerequisiteGroupByOutputType[P]>
        }
      >
    >


  export type LearningPathPrerequisiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learningPathId?: boolean
    prerequisiteId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathPrerequisite"]>

  export type LearningPathPrerequisiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learningPathId?: boolean
    prerequisiteId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathPrerequisite"]>

  export type LearningPathPrerequisiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learningPathId?: boolean
    prerequisiteId?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathPrerequisite"]>

  export type LearningPathPrerequisiteSelectScalar = {
    learningPathId?: boolean
    prerequisiteId?: boolean
  }

  export type LearningPathPrerequisiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"learningPathId" | "prerequisiteId", ExtArgs["result"]["learningPathPrerequisite"]>
  export type LearningPathPrerequisiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }
  export type LearningPathPrerequisiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }
  export type LearningPathPrerequisiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    prerequisite?: boolean | PrerequisiteDefaultArgs<ExtArgs>
  }

  export type $LearningPathPrerequisitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningPathPrerequisite"
    objects: {
      learningPath: Prisma.$LearningPathPayload<ExtArgs>
      prerequisite: Prisma.$PrerequisitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      learningPathId: string
      prerequisiteId: string
    }, ExtArgs["result"]["learningPathPrerequisite"]>
    composites: {}
  }

  type LearningPathPrerequisiteGetPayload<S extends boolean | null | undefined | LearningPathPrerequisiteDefaultArgs> = $Result.GetResult<Prisma.$LearningPathPrerequisitePayload, S>

  type LearningPathPrerequisiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningPathPrerequisiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningPathPrerequisiteCountAggregateInputType | true
    }

  export interface LearningPathPrerequisiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningPathPrerequisite'], meta: { name: 'LearningPathPrerequisite' } }
    /**
     * Find zero or one LearningPathPrerequisite that matches the filter.
     * @param {LearningPathPrerequisiteFindUniqueArgs} args - Arguments to find a LearningPathPrerequisite
     * @example
     * // Get one LearningPathPrerequisite
     * const learningPathPrerequisite = await prisma.learningPathPrerequisite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningPathPrerequisiteFindUniqueArgs>(args: SelectSubset<T, LearningPathPrerequisiteFindUniqueArgs<ExtArgs>>): Prisma__LearningPathPrerequisiteClient<$Result.GetResult<Prisma.$LearningPathPrerequisitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LearningPathPrerequisite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningPathPrerequisiteFindUniqueOrThrowArgs} args - Arguments to find a LearningPathPrerequisite
     * @example
     * // Get one LearningPathPrerequisite
     * const learningPathPrerequisite = await prisma.learningPathPrerequisite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningPathPrerequisiteFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningPathPrerequisiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningPathPrerequisiteClient<$Result.GetResult<Prisma.$LearningPathPrerequisitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningPathPrerequisite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathPrerequisiteFindFirstArgs} args - Arguments to find a LearningPathPrerequisite
     * @example
     * // Get one LearningPathPrerequisite
     * const learningPathPrerequisite = await prisma.learningPathPrerequisite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningPathPrerequisiteFindFirstArgs>(args?: SelectSubset<T, LearningPathPrerequisiteFindFirstArgs<ExtArgs>>): Prisma__LearningPathPrerequisiteClient<$Result.GetResult<Prisma.$LearningPathPrerequisitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningPathPrerequisite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathPrerequisiteFindFirstOrThrowArgs} args - Arguments to find a LearningPathPrerequisite
     * @example
     * // Get one LearningPathPrerequisite
     * const learningPathPrerequisite = await prisma.learningPathPrerequisite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningPathPrerequisiteFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningPathPrerequisiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningPathPrerequisiteClient<$Result.GetResult<Prisma.$LearningPathPrerequisitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LearningPathPrerequisites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathPrerequisiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningPathPrerequisites
     * const learningPathPrerequisites = await prisma.learningPathPrerequisite.findMany()
     * 
     * // Get first 10 LearningPathPrerequisites
     * const learningPathPrerequisites = await prisma.learningPathPrerequisite.findMany({ take: 10 })
     * 
     * // Only select the `learningPathId`
     * const learningPathPrerequisiteWithLearningPathIdOnly = await prisma.learningPathPrerequisite.findMany({ select: { learningPathId: true } })
     * 
     */
    findMany<T extends LearningPathPrerequisiteFindManyArgs>(args?: SelectSubset<T, LearningPathPrerequisiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LearningPathPrerequisite.
     * @param {LearningPathPrerequisiteCreateArgs} args - Arguments to create a LearningPathPrerequisite.
     * @example
     * // Create one LearningPathPrerequisite
     * const LearningPathPrerequisite = await prisma.learningPathPrerequisite.create({
     *   data: {
     *     // ... data to create a LearningPathPrerequisite
     *   }
     * })
     * 
     */
    create<T extends LearningPathPrerequisiteCreateArgs>(args: SelectSubset<T, LearningPathPrerequisiteCreateArgs<ExtArgs>>): Prisma__LearningPathPrerequisiteClient<$Result.GetResult<Prisma.$LearningPathPrerequisitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LearningPathPrerequisites.
     * @param {LearningPathPrerequisiteCreateManyArgs} args - Arguments to create many LearningPathPrerequisites.
     * @example
     * // Create many LearningPathPrerequisites
     * const learningPathPrerequisite = await prisma.learningPathPrerequisite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningPathPrerequisiteCreateManyArgs>(args?: SelectSubset<T, LearningPathPrerequisiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningPathPrerequisites and returns the data saved in the database.
     * @param {LearningPathPrerequisiteCreateManyAndReturnArgs} args - Arguments to create many LearningPathPrerequisites.
     * @example
     * // Create many LearningPathPrerequisites
     * const learningPathPrerequisite = await prisma.learningPathPrerequisite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningPathPrerequisites and only return the `learningPathId`
     * const learningPathPrerequisiteWithLearningPathIdOnly = await prisma.learningPathPrerequisite.createManyAndReturn({
     *   select: { learningPathId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningPathPrerequisiteCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningPathPrerequisiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPrerequisitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LearningPathPrerequisite.
     * @param {LearningPathPrerequisiteDeleteArgs} args - Arguments to delete one LearningPathPrerequisite.
     * @example
     * // Delete one LearningPathPrerequisite
     * const LearningPathPrerequisite = await prisma.learningPathPrerequisite.delete({
     *   where: {
     *     // ... filter to delete one LearningPathPrerequisite
     *   }
     * })
     * 
     */
    delete<T extends LearningPathPrerequisiteDeleteArgs>(args: SelectSubset<T, LearningPathPrerequisiteDeleteArgs<ExtArgs>>): Prisma__LearningPathPrerequisiteClient<$Result.GetResult<Prisma.$LearningPathPrerequisitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LearningPathPrerequisite.
     * @param {LearningPathPrerequisiteUpdateArgs} args - Arguments to update one LearningPathPrerequisite.
     * @example
     * // Update one LearningPathPrerequisite
     * const learningPathPrerequisite = await prisma.learningPathPrerequisite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningPathPrerequisiteUpdateArgs>(args: SelectSubset<T, LearningPathPrerequisiteUpdateArgs<ExtArgs>>): Prisma__LearningPathPrerequisiteClient<$Result.GetResult<Prisma.$LearningPathPrerequisitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LearningPathPrerequisites.
     * @param {LearningPathPrerequisiteDeleteManyArgs} args - Arguments to filter LearningPathPrerequisites to delete.
     * @example
     * // Delete a few LearningPathPrerequisites
     * const { count } = await prisma.learningPathPrerequisite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningPathPrerequisiteDeleteManyArgs>(args?: SelectSubset<T, LearningPathPrerequisiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPathPrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathPrerequisiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningPathPrerequisites
     * const learningPathPrerequisite = await prisma.learningPathPrerequisite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningPathPrerequisiteUpdateManyArgs>(args: SelectSubset<T, LearningPathPrerequisiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPathPrerequisites and returns the data updated in the database.
     * @param {LearningPathPrerequisiteUpdateManyAndReturnArgs} args - Arguments to update many LearningPathPrerequisites.
     * @example
     * // Update many LearningPathPrerequisites
     * const learningPathPrerequisite = await prisma.learningPathPrerequisite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningPathPrerequisites and only return the `learningPathId`
     * const learningPathPrerequisiteWithLearningPathIdOnly = await prisma.learningPathPrerequisite.updateManyAndReturn({
     *   select: { learningPathId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningPathPrerequisiteUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningPathPrerequisiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPrerequisitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LearningPathPrerequisite.
     * @param {LearningPathPrerequisiteUpsertArgs} args - Arguments to update or create a LearningPathPrerequisite.
     * @example
     * // Update or create a LearningPathPrerequisite
     * const learningPathPrerequisite = await prisma.learningPathPrerequisite.upsert({
     *   create: {
     *     // ... data to create a LearningPathPrerequisite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningPathPrerequisite we want to update
     *   }
     * })
     */
    upsert<T extends LearningPathPrerequisiteUpsertArgs>(args: SelectSubset<T, LearningPathPrerequisiteUpsertArgs<ExtArgs>>): Prisma__LearningPathPrerequisiteClient<$Result.GetResult<Prisma.$LearningPathPrerequisitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LearningPathPrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathPrerequisiteCountArgs} args - Arguments to filter LearningPathPrerequisites to count.
     * @example
     * // Count the number of LearningPathPrerequisites
     * const count = await prisma.learningPathPrerequisite.count({
     *   where: {
     *     // ... the filter for the LearningPathPrerequisites we want to count
     *   }
     * })
    **/
    count<T extends LearningPathPrerequisiteCountArgs>(
      args?: Subset<T, LearningPathPrerequisiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningPathPrerequisiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningPathPrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathPrerequisiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningPathPrerequisiteAggregateArgs>(args: Subset<T, LearningPathPrerequisiteAggregateArgs>): Prisma.PrismaPromise<GetLearningPathPrerequisiteAggregateType<T>>

    /**
     * Group by LearningPathPrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathPrerequisiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningPathPrerequisiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningPathPrerequisiteGroupByArgs['orderBy'] }
        : { orderBy?: LearningPathPrerequisiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningPathPrerequisiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningPathPrerequisiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningPathPrerequisite model
   */
  readonly fields: LearningPathPrerequisiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningPathPrerequisite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningPathPrerequisiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learningPath<T extends LearningPathDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathDefaultArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prerequisite<T extends PrerequisiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrerequisiteDefaultArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningPathPrerequisite model
   */
  interface LearningPathPrerequisiteFieldRefs {
    readonly learningPathId: FieldRef<"LearningPathPrerequisite", 'String'>
    readonly prerequisiteId: FieldRef<"LearningPathPrerequisite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LearningPathPrerequisite findUnique
   */
  export type LearningPathPrerequisiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathPrerequisite to fetch.
     */
    where: LearningPathPrerequisiteWhereUniqueInput
  }

  /**
   * LearningPathPrerequisite findUniqueOrThrow
   */
  export type LearningPathPrerequisiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathPrerequisite to fetch.
     */
    where: LearningPathPrerequisiteWhereUniqueInput
  }

  /**
   * LearningPathPrerequisite findFirst
   */
  export type LearningPathPrerequisiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathPrerequisite to fetch.
     */
    where?: LearningPathPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathPrerequisites to fetch.
     */
    orderBy?: LearningPathPrerequisiteOrderByWithRelationInput | LearningPathPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPathPrerequisites.
     */
    cursor?: LearningPathPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPathPrerequisites.
     */
    distinct?: LearningPathPrerequisiteScalarFieldEnum | LearningPathPrerequisiteScalarFieldEnum[]
  }

  /**
   * LearningPathPrerequisite findFirstOrThrow
   */
  export type LearningPathPrerequisiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathPrerequisite to fetch.
     */
    where?: LearningPathPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathPrerequisites to fetch.
     */
    orderBy?: LearningPathPrerequisiteOrderByWithRelationInput | LearningPathPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPathPrerequisites.
     */
    cursor?: LearningPathPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPathPrerequisites.
     */
    distinct?: LearningPathPrerequisiteScalarFieldEnum | LearningPathPrerequisiteScalarFieldEnum[]
  }

  /**
   * LearningPathPrerequisite findMany
   */
  export type LearningPathPrerequisiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathPrerequisites to fetch.
     */
    where?: LearningPathPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathPrerequisites to fetch.
     */
    orderBy?: LearningPathPrerequisiteOrderByWithRelationInput | LearningPathPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningPathPrerequisites.
     */
    cursor?: LearningPathPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathPrerequisites.
     */
    skip?: number
    distinct?: LearningPathPrerequisiteScalarFieldEnum | LearningPathPrerequisiteScalarFieldEnum[]
  }

  /**
   * LearningPathPrerequisite create
   */
  export type LearningPathPrerequisiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningPathPrerequisite.
     */
    data: XOR<LearningPathPrerequisiteCreateInput, LearningPathPrerequisiteUncheckedCreateInput>
  }

  /**
   * LearningPathPrerequisite createMany
   */
  export type LearningPathPrerequisiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningPathPrerequisites.
     */
    data: LearningPathPrerequisiteCreateManyInput | LearningPathPrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningPathPrerequisite createManyAndReturn
   */
  export type LearningPathPrerequisiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to create many LearningPathPrerequisites.
     */
    data: LearningPathPrerequisiteCreateManyInput | LearningPathPrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPathPrerequisite update
   */
  export type LearningPathPrerequisiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningPathPrerequisite.
     */
    data: XOR<LearningPathPrerequisiteUpdateInput, LearningPathPrerequisiteUncheckedUpdateInput>
    /**
     * Choose, which LearningPathPrerequisite to update.
     */
    where: LearningPathPrerequisiteWhereUniqueInput
  }

  /**
   * LearningPathPrerequisite updateMany
   */
  export type LearningPathPrerequisiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningPathPrerequisites.
     */
    data: XOR<LearningPathPrerequisiteUpdateManyMutationInput, LearningPathPrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which LearningPathPrerequisites to update
     */
    where?: LearningPathPrerequisiteWhereInput
    /**
     * Limit how many LearningPathPrerequisites to update.
     */
    limit?: number
  }

  /**
   * LearningPathPrerequisite updateManyAndReturn
   */
  export type LearningPathPrerequisiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to update LearningPathPrerequisites.
     */
    data: XOR<LearningPathPrerequisiteUpdateManyMutationInput, LearningPathPrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which LearningPathPrerequisites to update
     */
    where?: LearningPathPrerequisiteWhereInput
    /**
     * Limit how many LearningPathPrerequisites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPathPrerequisite upsert
   */
  export type LearningPathPrerequisiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningPathPrerequisite to update in case it exists.
     */
    where: LearningPathPrerequisiteWhereUniqueInput
    /**
     * In case the LearningPathPrerequisite found by the `where` argument doesn't exist, create a new LearningPathPrerequisite with this data.
     */
    create: XOR<LearningPathPrerequisiteCreateInput, LearningPathPrerequisiteUncheckedCreateInput>
    /**
     * In case the LearningPathPrerequisite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningPathPrerequisiteUpdateInput, LearningPathPrerequisiteUncheckedUpdateInput>
  }

  /**
   * LearningPathPrerequisite delete
   */
  export type LearningPathPrerequisiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter which LearningPathPrerequisite to delete.
     */
    where: LearningPathPrerequisiteWhereUniqueInput
  }

  /**
   * LearningPathPrerequisite deleteMany
   */
  export type LearningPathPrerequisiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPathPrerequisites to delete
     */
    where?: LearningPathPrerequisiteWhereInput
    /**
     * Limit how many LearningPathPrerequisites to delete.
     */
    limit?: number
  }

  /**
   * LearningPathPrerequisite without action
   */
  export type LearningPathPrerequisiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathPrerequisite
     */
    select?: LearningPathPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathPrerequisite
     */
    omit?: LearningPathPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathPrerequisiteInclude<ExtArgs> | null
  }


  /**
   * Model Feature
   */

  export type AggregateFeature = {
    _count: FeatureCountAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  export type FeatureMinAggregateOutputType = {
    id: string | null
    title: string | null
    desc: string | null
    color: string | null
    iconName: string | null
    iconLib: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureMaxAggregateOutputType = {
    id: string | null
    title: string | null
    desc: string | null
    color: string | null
    iconName: string | null
    iconLib: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureCountAggregateOutputType = {
    id: number
    title: number
    desc: number
    color: number
    iconName: number
    iconLib: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeatureMinAggregateInputType = {
    id?: true
    title?: true
    desc?: true
    color?: true
    iconName?: true
    iconLib?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureMaxAggregateInputType = {
    id?: true
    title?: true
    desc?: true
    color?: true
    iconName?: true
    iconLib?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureCountAggregateInputType = {
    id?: true
    title?: true
    desc?: true
    color?: true
    iconName?: true
    iconLib?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feature to aggregate.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Features
    **/
    _count?: true | FeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureMaxAggregateInputType
  }

  export type GetFeatureAggregateType<T extends FeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeature[P]>
      : GetScalarType<T[P], AggregateFeature[P]>
  }




  export type FeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureWhereInput
    orderBy?: FeatureOrderByWithAggregationInput | FeatureOrderByWithAggregationInput[]
    by: FeatureScalarFieldEnum[] | FeatureScalarFieldEnum
    having?: FeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureCountAggregateInputType | true
    _min?: FeatureMinAggregateInputType
    _max?: FeatureMaxAggregateInputType
  }

  export type FeatureGroupByOutputType = {
    id: string
    title: string
    desc: string
    color: string | null
    iconName: string | null
    iconLib: string | null
    createdAt: Date
    updatedAt: Date
    _count: FeatureCountAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  type GetFeatureGroupByPayload<T extends FeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureGroupByOutputType[P]>
        }
      >
    >


  export type FeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    desc?: boolean
    color?: boolean
    iconName?: boolean
    iconLib?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    desc?: boolean
    color?: boolean
    iconName?: boolean
    iconLib?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    desc?: boolean
    color?: boolean
    iconName?: boolean
    iconLib?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectScalar = {
    id?: boolean
    title?: boolean
    desc?: boolean
    color?: boolean
    iconName?: boolean
    iconLib?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "desc" | "color" | "iconName" | "iconLib" | "createdAt" | "updatedAt", ExtArgs["result"]["feature"]>

  export type $FeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feature"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      desc: string
      color: string | null
      iconName: string | null
      iconLib: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feature"]>
    composites: {}
  }

  type FeatureGetPayload<S extends boolean | null | undefined | FeatureDefaultArgs> = $Result.GetResult<Prisma.$FeaturePayload, S>

  type FeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatureCountAggregateInputType | true
    }

  export interface FeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feature'], meta: { name: 'Feature' } }
    /**
     * Find zero or one Feature that matches the filter.
     * @param {FeatureFindUniqueArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureFindUniqueArgs>(args: SelectSubset<T, FeatureFindUniqueArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureFindUniqueOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureFindFirstArgs>(args?: SelectSubset<T, FeatureFindFirstArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Features
     * const features = await prisma.feature.findMany()
     * 
     * // Get first 10 Features
     * const features = await prisma.feature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureWithIdOnly = await prisma.feature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureFindManyArgs>(args?: SelectSubset<T, FeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feature.
     * @param {FeatureCreateArgs} args - Arguments to create a Feature.
     * @example
     * // Create one Feature
     * const Feature = await prisma.feature.create({
     *   data: {
     *     // ... data to create a Feature
     *   }
     * })
     * 
     */
    create<T extends FeatureCreateArgs>(args: SelectSubset<T, FeatureCreateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Features.
     * @param {FeatureCreateManyArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const feature = await prisma.feature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureCreateManyArgs>(args?: SelectSubset<T, FeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Features and returns the data saved in the database.
     * @param {FeatureCreateManyAndReturnArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const feature = await prisma.feature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Features and only return the `id`
     * const featureWithIdOnly = await prisma.feature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feature.
     * @param {FeatureDeleteArgs} args - Arguments to delete one Feature.
     * @example
     * // Delete one Feature
     * const Feature = await prisma.feature.delete({
     *   where: {
     *     // ... filter to delete one Feature
     *   }
     * })
     * 
     */
    delete<T extends FeatureDeleteArgs>(args: SelectSubset<T, FeatureDeleteArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feature.
     * @param {FeatureUpdateArgs} args - Arguments to update one Feature.
     * @example
     * // Update one Feature
     * const feature = await prisma.feature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureUpdateArgs>(args: SelectSubset<T, FeatureUpdateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Features.
     * @param {FeatureDeleteManyArgs} args - Arguments to filter Features to delete.
     * @example
     * // Delete a few Features
     * const { count } = await prisma.feature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureDeleteManyArgs>(args?: SelectSubset<T, FeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureUpdateManyArgs>(args: SelectSubset<T, FeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features and returns the data updated in the database.
     * @param {FeatureUpdateManyAndReturnArgs} args - Arguments to update many Features.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Features and only return the `id`
     * const featureWithIdOnly = await prisma.feature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feature.
     * @param {FeatureUpsertArgs} args - Arguments to update or create a Feature.
     * @example
     * // Update or create a Feature
     * const feature = await prisma.feature.upsert({
     *   create: {
     *     // ... data to create a Feature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feature we want to update
     *   }
     * })
     */
    upsert<T extends FeatureUpsertArgs>(args: SelectSubset<T, FeatureUpsertArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureCountArgs} args - Arguments to filter Features to count.
     * @example
     * // Count the number of Features
     * const count = await prisma.feature.count({
     *   where: {
     *     // ... the filter for the Features we want to count
     *   }
     * })
    **/
    count<T extends FeatureCountArgs>(
      args?: Subset<T, FeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureAggregateArgs>(args: Subset<T, FeatureAggregateArgs>): Prisma.PrismaPromise<GetFeatureAggregateType<T>>

    /**
     * Group by Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureGroupByArgs['orderBy'] }
        : { orderBy?: FeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feature model
   */
  readonly fields: FeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feature model
   */
  interface FeatureFieldRefs {
    readonly id: FieldRef<"Feature", 'String'>
    readonly title: FieldRef<"Feature", 'String'>
    readonly desc: FieldRef<"Feature", 'String'>
    readonly color: FieldRef<"Feature", 'String'>
    readonly iconName: FieldRef<"Feature", 'String'>
    readonly iconLib: FieldRef<"Feature", 'String'>
    readonly createdAt: FieldRef<"Feature", 'DateTime'>
    readonly updatedAt: FieldRef<"Feature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feature findUnique
   */
  export type FeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature findUniqueOrThrow
   */
  export type FeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature findFirst
   */
  export type FeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature findFirstOrThrow
   */
  export type FeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature findMany
   */
  export type FeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Filter, which Features to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature create
   */
  export type FeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data needed to create a Feature.
     */
    data: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
  }

  /**
   * Feature createMany
   */
  export type FeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Features.
     */
    data: FeatureCreateManyInput | FeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feature createManyAndReturn
   */
  export type FeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data used to create many Features.
     */
    data: FeatureCreateManyInput | FeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feature update
   */
  export type FeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data needed to update a Feature.
     */
    data: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
    /**
     * Choose, which Feature to update.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature updateMany
   */
  export type FeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Features.
     */
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to update.
     */
    limit?: number
  }

  /**
   * Feature updateManyAndReturn
   */
  export type FeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data used to update Features.
     */
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to update.
     */
    limit?: number
  }

  /**
   * Feature upsert
   */
  export type FeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The filter to search for the Feature to update in case it exists.
     */
    where: FeatureWhereUniqueInput
    /**
     * In case the Feature found by the `where` argument doesn't exist, create a new Feature with this data.
     */
    create: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
    /**
     * In case the Feature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
  }

  /**
   * Feature delete
   */
  export type FeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Filter which Feature to delete.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature deleteMany
   */
  export type FeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Features to delete
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to delete.
     */
    limit?: number
  }

  /**
   * Feature without action
   */
  export type FeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    postalCode: string | null
    city: string | null
    country: string | null
    email: string | null
    phone: string | null
    siret: string | null
    vatNumber: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    postalCode: string | null
    city: string | null
    country: string | null
    email: string | null
    phone: string | null
    siret: string | null
    vatNumber: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    address: number
    postalCode: number
    city: number
    country: number
    email: number
    phone: number
    siret: number
    vatNumber: number
    logoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    postalCode?: true
    city?: true
    country?: true
    email?: true
    phone?: true
    siret?: true
    vatNumber?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    postalCode?: true
    city?: true
    country?: true
    email?: true
    phone?: true
    siret?: true
    vatNumber?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    postalCode?: true
    city?: true
    country?: true
    email?: true
    phone?: true
    siret?: true
    vatNumber?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    address: string
    postalCode: string
    city: string
    country: string
    email: string
    phone: string | null
    siret: string | null
    vatNumber: string | null
    logoUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    postalCode?: boolean
    city?: boolean
    country?: boolean
    email?: boolean
    phone?: boolean
    siret?: boolean
    vatNumber?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companySocialLink?: boolean | Company$companySocialLinkArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    postalCode?: boolean
    city?: boolean
    country?: boolean
    email?: boolean
    phone?: boolean
    siret?: boolean
    vatNumber?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    postalCode?: boolean
    city?: boolean
    country?: boolean
    email?: boolean
    phone?: boolean
    siret?: boolean
    vatNumber?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    postalCode?: boolean
    city?: boolean
    country?: boolean
    email?: boolean
    phone?: boolean
    siret?: boolean
    vatNumber?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "postalCode" | "city" | "country" | "email" | "phone" | "siret" | "vatNumber" | "logoUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companySocialLink?: boolean | Company$companySocialLinkArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      companySocialLink: Prisma.$CompanySocialLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      postalCode: string
      city: string
      country: string
      email: string
      phone: string | null
      siret: string | null
      vatNumber: string | null
      logoUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companySocialLink<T extends Company$companySocialLinkArgs<ExtArgs> = {}>(args?: Subset<T, Company$companySocialLinkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySocialLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly postalCode: FieldRef<"Company", 'String'>
    readonly city: FieldRef<"Company", 'String'>
    readonly country: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly siret: FieldRef<"Company", 'String'>
    readonly vatNumber: FieldRef<"Company", 'String'>
    readonly logoUrl: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.companySocialLink
   */
  export type Company$companySocialLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkInclude<ExtArgs> | null
    where?: CompanySocialLinkWhereInput
    orderBy?: CompanySocialLinkOrderByWithRelationInput | CompanySocialLinkOrderByWithRelationInput[]
    cursor?: CompanySocialLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanySocialLinkScalarFieldEnum | CompanySocialLinkScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model SocialLink
   */

  export type AggregateSocialLink = {
    _count: SocialLinkCountAggregateOutputType | null
    _min: SocialLinkMinAggregateOutputType | null
    _max: SocialLinkMaxAggregateOutputType | null
  }

  export type SocialLinkMinAggregateOutputType = {
    id: string | null
    name: string | null
    iconLib: string | null
    iconName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialLinkMaxAggregateOutputType = {
    id: string | null
    name: string | null
    iconLib: string | null
    iconName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialLinkCountAggregateOutputType = {
    id: number
    name: number
    iconLib: number
    iconName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialLinkMinAggregateInputType = {
    id?: true
    name?: true
    iconLib?: true
    iconName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialLinkMaxAggregateInputType = {
    id?: true
    name?: true
    iconLib?: true
    iconName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialLinkCountAggregateInputType = {
    id?: true
    name?: true
    iconLib?: true
    iconName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLink to aggregate.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialLinks
    **/
    _count?: true | SocialLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialLinkMaxAggregateInputType
  }

  export type GetSocialLinkAggregateType<T extends SocialLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialLink[P]>
      : GetScalarType<T[P], AggregateSocialLink[P]>
  }




  export type SocialLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialLinkWhereInput
    orderBy?: SocialLinkOrderByWithAggregationInput | SocialLinkOrderByWithAggregationInput[]
    by: SocialLinkScalarFieldEnum[] | SocialLinkScalarFieldEnum
    having?: SocialLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialLinkCountAggregateInputType | true
    _min?: SocialLinkMinAggregateInputType
    _max?: SocialLinkMaxAggregateInputType
  }

  export type SocialLinkGroupByOutputType = {
    id: string
    name: string
    iconLib: string
    iconName: string
    createdAt: Date
    updatedAt: Date
    _count: SocialLinkCountAggregateOutputType | null
    _min: SocialLinkMinAggregateOutputType | null
    _max: SocialLinkMaxAggregateOutputType | null
  }

  type GetSocialLinkGroupByPayload<T extends SocialLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialLinkGroupByOutputType[P]>
            : GetScalarType<T[P], SocialLinkGroupByOutputType[P]>
        }
      >
    >


  export type SocialLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iconLib?: boolean
    iconName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companySocialLink?: boolean | SocialLink$companySocialLinkArgs<ExtArgs>
    _count?: boolean | SocialLinkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialLink"]>

  export type SocialLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iconLib?: boolean
    iconName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialLink"]>

  export type SocialLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iconLib?: boolean
    iconName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialLink"]>

  export type SocialLinkSelectScalar = {
    id?: boolean
    name?: boolean
    iconLib?: boolean
    iconName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "iconLib" | "iconName" | "createdAt" | "updatedAt", ExtArgs["result"]["socialLink"]>
  export type SocialLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companySocialLink?: boolean | SocialLink$companySocialLinkArgs<ExtArgs>
    _count?: boolean | SocialLinkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SocialLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SocialLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SocialLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialLink"
    objects: {
      companySocialLink: Prisma.$CompanySocialLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      iconLib: string
      iconName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["socialLink"]>
    composites: {}
  }

  type SocialLinkGetPayload<S extends boolean | null | undefined | SocialLinkDefaultArgs> = $Result.GetResult<Prisma.$SocialLinkPayload, S>

  type SocialLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialLinkCountAggregateInputType | true
    }

  export interface SocialLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialLink'], meta: { name: 'SocialLink' } }
    /**
     * Find zero or one SocialLink that matches the filter.
     * @param {SocialLinkFindUniqueArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialLinkFindUniqueArgs>(args: SelectSubset<T, SocialLinkFindUniqueArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialLinkFindUniqueOrThrowArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkFindFirstArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialLinkFindFirstArgs>(args?: SelectSubset<T, SocialLinkFindFirstArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkFindFirstOrThrowArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialLinks
     * const socialLinks = await prisma.socialLink.findMany()
     * 
     * // Get first 10 SocialLinks
     * const socialLinks = await prisma.socialLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialLinkWithIdOnly = await prisma.socialLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialLinkFindManyArgs>(args?: SelectSubset<T, SocialLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialLink.
     * @param {SocialLinkCreateArgs} args - Arguments to create a SocialLink.
     * @example
     * // Create one SocialLink
     * const SocialLink = await prisma.socialLink.create({
     *   data: {
     *     // ... data to create a SocialLink
     *   }
     * })
     * 
     */
    create<T extends SocialLinkCreateArgs>(args: SelectSubset<T, SocialLinkCreateArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialLinks.
     * @param {SocialLinkCreateManyArgs} args - Arguments to create many SocialLinks.
     * @example
     * // Create many SocialLinks
     * const socialLink = await prisma.socialLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialLinkCreateManyArgs>(args?: SelectSubset<T, SocialLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialLinks and returns the data saved in the database.
     * @param {SocialLinkCreateManyAndReturnArgs} args - Arguments to create many SocialLinks.
     * @example
     * // Create many SocialLinks
     * const socialLink = await prisma.socialLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialLinks and only return the `id`
     * const socialLinkWithIdOnly = await prisma.socialLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SocialLink.
     * @param {SocialLinkDeleteArgs} args - Arguments to delete one SocialLink.
     * @example
     * // Delete one SocialLink
     * const SocialLink = await prisma.socialLink.delete({
     *   where: {
     *     // ... filter to delete one SocialLink
     *   }
     * })
     * 
     */
    delete<T extends SocialLinkDeleteArgs>(args: SelectSubset<T, SocialLinkDeleteArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialLink.
     * @param {SocialLinkUpdateArgs} args - Arguments to update one SocialLink.
     * @example
     * // Update one SocialLink
     * const socialLink = await prisma.socialLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialLinkUpdateArgs>(args: SelectSubset<T, SocialLinkUpdateArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialLinks.
     * @param {SocialLinkDeleteManyArgs} args - Arguments to filter SocialLinks to delete.
     * @example
     * // Delete a few SocialLinks
     * const { count } = await prisma.socialLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialLinkDeleteManyArgs>(args?: SelectSubset<T, SocialLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialLinks
     * const socialLink = await prisma.socialLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialLinkUpdateManyArgs>(args: SelectSubset<T, SocialLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialLinks and returns the data updated in the database.
     * @param {SocialLinkUpdateManyAndReturnArgs} args - Arguments to update many SocialLinks.
     * @example
     * // Update many SocialLinks
     * const socialLink = await prisma.socialLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SocialLinks and only return the `id`
     * const socialLinkWithIdOnly = await prisma.socialLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SocialLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, SocialLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SocialLink.
     * @param {SocialLinkUpsertArgs} args - Arguments to update or create a SocialLink.
     * @example
     * // Update or create a SocialLink
     * const socialLink = await prisma.socialLink.upsert({
     *   create: {
     *     // ... data to create a SocialLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialLink we want to update
     *   }
     * })
     */
    upsert<T extends SocialLinkUpsertArgs>(args: SelectSubset<T, SocialLinkUpsertArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkCountArgs} args - Arguments to filter SocialLinks to count.
     * @example
     * // Count the number of SocialLinks
     * const count = await prisma.socialLink.count({
     *   where: {
     *     // ... the filter for the SocialLinks we want to count
     *   }
     * })
    **/
    count<T extends SocialLinkCountArgs>(
      args?: Subset<T, SocialLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialLinkAggregateArgs>(args: Subset<T, SocialLinkAggregateArgs>): Prisma.PrismaPromise<GetSocialLinkAggregateType<T>>

    /**
     * Group by SocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialLinkGroupByArgs['orderBy'] }
        : { orderBy?: SocialLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialLink model
   */
  readonly fields: SocialLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companySocialLink<T extends SocialLink$companySocialLinkArgs<ExtArgs> = {}>(args?: Subset<T, SocialLink$companySocialLinkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySocialLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialLink model
   */
  interface SocialLinkFieldRefs {
    readonly id: FieldRef<"SocialLink", 'String'>
    readonly name: FieldRef<"SocialLink", 'String'>
    readonly iconLib: FieldRef<"SocialLink", 'String'>
    readonly iconName: FieldRef<"SocialLink", 'String'>
    readonly createdAt: FieldRef<"SocialLink", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialLink findUnique
   */
  export type SocialLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where: SocialLinkWhereUniqueInput
  }

  /**
   * SocialLink findUniqueOrThrow
   */
  export type SocialLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where: SocialLinkWhereUniqueInput
  }

  /**
   * SocialLink findFirst
   */
  export type SocialLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLinks.
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLinks.
     */
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * SocialLink findFirstOrThrow
   */
  export type SocialLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLinks.
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLinks.
     */
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * SocialLink findMany
   */
  export type SocialLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialLinks.
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * SocialLink create
   */
  export type SocialLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialLink.
     */
    data: XOR<SocialLinkCreateInput, SocialLinkUncheckedCreateInput>
  }

  /**
   * SocialLink createMany
   */
  export type SocialLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialLinks.
     */
    data: SocialLinkCreateManyInput | SocialLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialLink createManyAndReturn
   */
  export type SocialLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * The data used to create many SocialLinks.
     */
    data: SocialLinkCreateManyInput | SocialLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialLink update
   */
  export type SocialLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialLink.
     */
    data: XOR<SocialLinkUpdateInput, SocialLinkUncheckedUpdateInput>
    /**
     * Choose, which SocialLink to update.
     */
    where: SocialLinkWhereUniqueInput
  }

  /**
   * SocialLink updateMany
   */
  export type SocialLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialLinks.
     */
    data: XOR<SocialLinkUpdateManyMutationInput, SocialLinkUncheckedUpdateManyInput>
    /**
     * Filter which SocialLinks to update
     */
    where?: SocialLinkWhereInput
    /**
     * Limit how many SocialLinks to update.
     */
    limit?: number
  }

  /**
   * SocialLink updateManyAndReturn
   */
  export type SocialLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * The data used to update SocialLinks.
     */
    data: XOR<SocialLinkUpdateManyMutationInput, SocialLinkUncheckedUpdateManyInput>
    /**
     * Filter which SocialLinks to update
     */
    where?: SocialLinkWhereInput
    /**
     * Limit how many SocialLinks to update.
     */
    limit?: number
  }

  /**
   * SocialLink upsert
   */
  export type SocialLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialLink to update in case it exists.
     */
    where: SocialLinkWhereUniqueInput
    /**
     * In case the SocialLink found by the `where` argument doesn't exist, create a new SocialLink with this data.
     */
    create: XOR<SocialLinkCreateInput, SocialLinkUncheckedCreateInput>
    /**
     * In case the SocialLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialLinkUpdateInput, SocialLinkUncheckedUpdateInput>
  }

  /**
   * SocialLink delete
   */
  export type SocialLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter which SocialLink to delete.
     */
    where: SocialLinkWhereUniqueInput
  }

  /**
   * SocialLink deleteMany
   */
  export type SocialLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLinks to delete
     */
    where?: SocialLinkWhereInput
    /**
     * Limit how many SocialLinks to delete.
     */
    limit?: number
  }

  /**
   * SocialLink.companySocialLink
   */
  export type SocialLink$companySocialLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkInclude<ExtArgs> | null
    where?: CompanySocialLinkWhereInput
    orderBy?: CompanySocialLinkOrderByWithRelationInput | CompanySocialLinkOrderByWithRelationInput[]
    cursor?: CompanySocialLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanySocialLinkScalarFieldEnum | CompanySocialLinkScalarFieldEnum[]
  }

  /**
   * SocialLink without action
   */
  export type SocialLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
  }


  /**
   * Model CompanySocialLink
   */

  export type AggregateCompanySocialLink = {
    _count: CompanySocialLinkCountAggregateOutputType | null
    _min: CompanySocialLinkMinAggregateOutputType | null
    _max: CompanySocialLinkMaxAggregateOutputType | null
  }

  export type CompanySocialLinkMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    socialLinkId: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanySocialLinkMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    socialLinkId: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanySocialLinkCountAggregateOutputType = {
    id: number
    companyId: number
    socialLinkId: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanySocialLinkMinAggregateInputType = {
    id?: true
    companyId?: true
    socialLinkId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanySocialLinkMaxAggregateInputType = {
    id?: true
    companyId?: true
    socialLinkId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanySocialLinkCountAggregateInputType = {
    id?: true
    companyId?: true
    socialLinkId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanySocialLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanySocialLink to aggregate.
     */
    where?: CompanySocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySocialLinks to fetch.
     */
    orderBy?: CompanySocialLinkOrderByWithRelationInput | CompanySocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanySocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanySocialLinks
    **/
    _count?: true | CompanySocialLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanySocialLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanySocialLinkMaxAggregateInputType
  }

  export type GetCompanySocialLinkAggregateType<T extends CompanySocialLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanySocialLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanySocialLink[P]>
      : GetScalarType<T[P], AggregateCompanySocialLink[P]>
  }




  export type CompanySocialLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanySocialLinkWhereInput
    orderBy?: CompanySocialLinkOrderByWithAggregationInput | CompanySocialLinkOrderByWithAggregationInput[]
    by: CompanySocialLinkScalarFieldEnum[] | CompanySocialLinkScalarFieldEnum
    having?: CompanySocialLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanySocialLinkCountAggregateInputType | true
    _min?: CompanySocialLinkMinAggregateInputType
    _max?: CompanySocialLinkMaxAggregateInputType
  }

  export type CompanySocialLinkGroupByOutputType = {
    id: string
    companyId: string
    socialLinkId: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: CompanySocialLinkCountAggregateOutputType | null
    _min: CompanySocialLinkMinAggregateOutputType | null
    _max: CompanySocialLinkMaxAggregateOutputType | null
  }

  type GetCompanySocialLinkGroupByPayload<T extends CompanySocialLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanySocialLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanySocialLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanySocialLinkGroupByOutputType[P]>
            : GetScalarType<T[P], CompanySocialLinkGroupByOutputType[P]>
        }
      >
    >


  export type CompanySocialLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    socialLinkId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    socialLink?: boolean | SocialLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companySocialLink"]>

  export type CompanySocialLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    socialLinkId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    socialLink?: boolean | SocialLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companySocialLink"]>

  export type CompanySocialLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    socialLinkId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    socialLink?: boolean | SocialLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companySocialLink"]>

  export type CompanySocialLinkSelectScalar = {
    id?: boolean
    companyId?: boolean
    socialLinkId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanySocialLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "socialLinkId" | "url" | "createdAt" | "updatedAt", ExtArgs["result"]["companySocialLink"]>
  export type CompanySocialLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    socialLink?: boolean | SocialLinkDefaultArgs<ExtArgs>
  }
  export type CompanySocialLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    socialLink?: boolean | SocialLinkDefaultArgs<ExtArgs>
  }
  export type CompanySocialLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    socialLink?: boolean | SocialLinkDefaultArgs<ExtArgs>
  }

  export type $CompanySocialLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanySocialLink"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      socialLink: Prisma.$SocialLinkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      socialLinkId: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companySocialLink"]>
    composites: {}
  }

  type CompanySocialLinkGetPayload<S extends boolean | null | undefined | CompanySocialLinkDefaultArgs> = $Result.GetResult<Prisma.$CompanySocialLinkPayload, S>

  type CompanySocialLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanySocialLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanySocialLinkCountAggregateInputType | true
    }

  export interface CompanySocialLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanySocialLink'], meta: { name: 'CompanySocialLink' } }
    /**
     * Find zero or one CompanySocialLink that matches the filter.
     * @param {CompanySocialLinkFindUniqueArgs} args - Arguments to find a CompanySocialLink
     * @example
     * // Get one CompanySocialLink
     * const companySocialLink = await prisma.companySocialLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanySocialLinkFindUniqueArgs>(args: SelectSubset<T, CompanySocialLinkFindUniqueArgs<ExtArgs>>): Prisma__CompanySocialLinkClient<$Result.GetResult<Prisma.$CompanySocialLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanySocialLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanySocialLinkFindUniqueOrThrowArgs} args - Arguments to find a CompanySocialLink
     * @example
     * // Get one CompanySocialLink
     * const companySocialLink = await prisma.companySocialLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanySocialLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanySocialLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanySocialLinkClient<$Result.GetResult<Prisma.$CompanySocialLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanySocialLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySocialLinkFindFirstArgs} args - Arguments to find a CompanySocialLink
     * @example
     * // Get one CompanySocialLink
     * const companySocialLink = await prisma.companySocialLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanySocialLinkFindFirstArgs>(args?: SelectSubset<T, CompanySocialLinkFindFirstArgs<ExtArgs>>): Prisma__CompanySocialLinkClient<$Result.GetResult<Prisma.$CompanySocialLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanySocialLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySocialLinkFindFirstOrThrowArgs} args - Arguments to find a CompanySocialLink
     * @example
     * // Get one CompanySocialLink
     * const companySocialLink = await prisma.companySocialLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanySocialLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanySocialLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanySocialLinkClient<$Result.GetResult<Prisma.$CompanySocialLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanySocialLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySocialLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanySocialLinks
     * const companySocialLinks = await prisma.companySocialLink.findMany()
     * 
     * // Get first 10 CompanySocialLinks
     * const companySocialLinks = await prisma.companySocialLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companySocialLinkWithIdOnly = await prisma.companySocialLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanySocialLinkFindManyArgs>(args?: SelectSubset<T, CompanySocialLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySocialLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanySocialLink.
     * @param {CompanySocialLinkCreateArgs} args - Arguments to create a CompanySocialLink.
     * @example
     * // Create one CompanySocialLink
     * const CompanySocialLink = await prisma.companySocialLink.create({
     *   data: {
     *     // ... data to create a CompanySocialLink
     *   }
     * })
     * 
     */
    create<T extends CompanySocialLinkCreateArgs>(args: SelectSubset<T, CompanySocialLinkCreateArgs<ExtArgs>>): Prisma__CompanySocialLinkClient<$Result.GetResult<Prisma.$CompanySocialLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanySocialLinks.
     * @param {CompanySocialLinkCreateManyArgs} args - Arguments to create many CompanySocialLinks.
     * @example
     * // Create many CompanySocialLinks
     * const companySocialLink = await prisma.companySocialLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanySocialLinkCreateManyArgs>(args?: SelectSubset<T, CompanySocialLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanySocialLinks and returns the data saved in the database.
     * @param {CompanySocialLinkCreateManyAndReturnArgs} args - Arguments to create many CompanySocialLinks.
     * @example
     * // Create many CompanySocialLinks
     * const companySocialLink = await prisma.companySocialLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanySocialLinks and only return the `id`
     * const companySocialLinkWithIdOnly = await prisma.companySocialLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanySocialLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanySocialLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySocialLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanySocialLink.
     * @param {CompanySocialLinkDeleteArgs} args - Arguments to delete one CompanySocialLink.
     * @example
     * // Delete one CompanySocialLink
     * const CompanySocialLink = await prisma.companySocialLink.delete({
     *   where: {
     *     // ... filter to delete one CompanySocialLink
     *   }
     * })
     * 
     */
    delete<T extends CompanySocialLinkDeleteArgs>(args: SelectSubset<T, CompanySocialLinkDeleteArgs<ExtArgs>>): Prisma__CompanySocialLinkClient<$Result.GetResult<Prisma.$CompanySocialLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanySocialLink.
     * @param {CompanySocialLinkUpdateArgs} args - Arguments to update one CompanySocialLink.
     * @example
     * // Update one CompanySocialLink
     * const companySocialLink = await prisma.companySocialLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanySocialLinkUpdateArgs>(args: SelectSubset<T, CompanySocialLinkUpdateArgs<ExtArgs>>): Prisma__CompanySocialLinkClient<$Result.GetResult<Prisma.$CompanySocialLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanySocialLinks.
     * @param {CompanySocialLinkDeleteManyArgs} args - Arguments to filter CompanySocialLinks to delete.
     * @example
     * // Delete a few CompanySocialLinks
     * const { count } = await prisma.companySocialLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanySocialLinkDeleteManyArgs>(args?: SelectSubset<T, CompanySocialLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanySocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySocialLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanySocialLinks
     * const companySocialLink = await prisma.companySocialLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanySocialLinkUpdateManyArgs>(args: SelectSubset<T, CompanySocialLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanySocialLinks and returns the data updated in the database.
     * @param {CompanySocialLinkUpdateManyAndReturnArgs} args - Arguments to update many CompanySocialLinks.
     * @example
     * // Update many CompanySocialLinks
     * const companySocialLink = await prisma.companySocialLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanySocialLinks and only return the `id`
     * const companySocialLinkWithIdOnly = await prisma.companySocialLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanySocialLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanySocialLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySocialLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanySocialLink.
     * @param {CompanySocialLinkUpsertArgs} args - Arguments to update or create a CompanySocialLink.
     * @example
     * // Update or create a CompanySocialLink
     * const companySocialLink = await prisma.companySocialLink.upsert({
     *   create: {
     *     // ... data to create a CompanySocialLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanySocialLink we want to update
     *   }
     * })
     */
    upsert<T extends CompanySocialLinkUpsertArgs>(args: SelectSubset<T, CompanySocialLinkUpsertArgs<ExtArgs>>): Prisma__CompanySocialLinkClient<$Result.GetResult<Prisma.$CompanySocialLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanySocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySocialLinkCountArgs} args - Arguments to filter CompanySocialLinks to count.
     * @example
     * // Count the number of CompanySocialLinks
     * const count = await prisma.companySocialLink.count({
     *   where: {
     *     // ... the filter for the CompanySocialLinks we want to count
     *   }
     * })
    **/
    count<T extends CompanySocialLinkCountArgs>(
      args?: Subset<T, CompanySocialLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanySocialLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanySocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySocialLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanySocialLinkAggregateArgs>(args: Subset<T, CompanySocialLinkAggregateArgs>): Prisma.PrismaPromise<GetCompanySocialLinkAggregateType<T>>

    /**
     * Group by CompanySocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySocialLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanySocialLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanySocialLinkGroupByArgs['orderBy'] }
        : { orderBy?: CompanySocialLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanySocialLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanySocialLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanySocialLink model
   */
  readonly fields: CompanySocialLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanySocialLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanySocialLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    socialLink<T extends SocialLinkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocialLinkDefaultArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanySocialLink model
   */
  interface CompanySocialLinkFieldRefs {
    readonly id: FieldRef<"CompanySocialLink", 'String'>
    readonly companyId: FieldRef<"CompanySocialLink", 'String'>
    readonly socialLinkId: FieldRef<"CompanySocialLink", 'String'>
    readonly url: FieldRef<"CompanySocialLink", 'String'>
    readonly createdAt: FieldRef<"CompanySocialLink", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanySocialLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanySocialLink findUnique
   */
  export type CompanySocialLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which CompanySocialLink to fetch.
     */
    where: CompanySocialLinkWhereUniqueInput
  }

  /**
   * CompanySocialLink findUniqueOrThrow
   */
  export type CompanySocialLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which CompanySocialLink to fetch.
     */
    where: CompanySocialLinkWhereUniqueInput
  }

  /**
   * CompanySocialLink findFirst
   */
  export type CompanySocialLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which CompanySocialLink to fetch.
     */
    where?: CompanySocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySocialLinks to fetch.
     */
    orderBy?: CompanySocialLinkOrderByWithRelationInput | CompanySocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanySocialLinks.
     */
    cursor?: CompanySocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanySocialLinks.
     */
    distinct?: CompanySocialLinkScalarFieldEnum | CompanySocialLinkScalarFieldEnum[]
  }

  /**
   * CompanySocialLink findFirstOrThrow
   */
  export type CompanySocialLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which CompanySocialLink to fetch.
     */
    where?: CompanySocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySocialLinks to fetch.
     */
    orderBy?: CompanySocialLinkOrderByWithRelationInput | CompanySocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanySocialLinks.
     */
    cursor?: CompanySocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanySocialLinks.
     */
    distinct?: CompanySocialLinkScalarFieldEnum | CompanySocialLinkScalarFieldEnum[]
  }

  /**
   * CompanySocialLink findMany
   */
  export type CompanySocialLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which CompanySocialLinks to fetch.
     */
    where?: CompanySocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySocialLinks to fetch.
     */
    orderBy?: CompanySocialLinkOrderByWithRelationInput | CompanySocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanySocialLinks.
     */
    cursor?: CompanySocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySocialLinks.
     */
    skip?: number
    distinct?: CompanySocialLinkScalarFieldEnum | CompanySocialLinkScalarFieldEnum[]
  }

  /**
   * CompanySocialLink create
   */
  export type CompanySocialLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanySocialLink.
     */
    data: XOR<CompanySocialLinkCreateInput, CompanySocialLinkUncheckedCreateInput>
  }

  /**
   * CompanySocialLink createMany
   */
  export type CompanySocialLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanySocialLinks.
     */
    data: CompanySocialLinkCreateManyInput | CompanySocialLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanySocialLink createManyAndReturn
   */
  export type CompanySocialLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * The data used to create many CompanySocialLinks.
     */
    data: CompanySocialLinkCreateManyInput | CompanySocialLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanySocialLink update
   */
  export type CompanySocialLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanySocialLink.
     */
    data: XOR<CompanySocialLinkUpdateInput, CompanySocialLinkUncheckedUpdateInput>
    /**
     * Choose, which CompanySocialLink to update.
     */
    where: CompanySocialLinkWhereUniqueInput
  }

  /**
   * CompanySocialLink updateMany
   */
  export type CompanySocialLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanySocialLinks.
     */
    data: XOR<CompanySocialLinkUpdateManyMutationInput, CompanySocialLinkUncheckedUpdateManyInput>
    /**
     * Filter which CompanySocialLinks to update
     */
    where?: CompanySocialLinkWhereInput
    /**
     * Limit how many CompanySocialLinks to update.
     */
    limit?: number
  }

  /**
   * CompanySocialLink updateManyAndReturn
   */
  export type CompanySocialLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * The data used to update CompanySocialLinks.
     */
    data: XOR<CompanySocialLinkUpdateManyMutationInput, CompanySocialLinkUncheckedUpdateManyInput>
    /**
     * Filter which CompanySocialLinks to update
     */
    where?: CompanySocialLinkWhereInput
    /**
     * Limit how many CompanySocialLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanySocialLink upsert
   */
  export type CompanySocialLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanySocialLink to update in case it exists.
     */
    where: CompanySocialLinkWhereUniqueInput
    /**
     * In case the CompanySocialLink found by the `where` argument doesn't exist, create a new CompanySocialLink with this data.
     */
    create: XOR<CompanySocialLinkCreateInput, CompanySocialLinkUncheckedCreateInput>
    /**
     * In case the CompanySocialLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanySocialLinkUpdateInput, CompanySocialLinkUncheckedUpdateInput>
  }

  /**
   * CompanySocialLink delete
   */
  export type CompanySocialLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkInclude<ExtArgs> | null
    /**
     * Filter which CompanySocialLink to delete.
     */
    where: CompanySocialLinkWhereUniqueInput
  }

  /**
   * CompanySocialLink deleteMany
   */
  export type CompanySocialLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanySocialLinks to delete
     */
    where?: CompanySocialLinkWhereInput
    /**
     * Limit how many CompanySocialLinks to delete.
     */
    limit?: number
  }

  /**
   * CompanySocialLink without action
   */
  export type CompanySocialLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySocialLink
     */
    select?: CompanySocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySocialLink
     */
    omit?: CompanySocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySocialLinkInclude<ExtArgs> | null
  }


  /**
   * Model Page
   */

  export type AggregatePage = {
    _count: PageCountAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  export type PageMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    content: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PageMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Page to aggregate.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pages
    **/
    _count?: true | PageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageMaxAggregateInputType
  }

  export type GetPageAggregateType<T extends PageAggregateArgs> = {
        [P in keyof T & keyof AggregatePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePage[P]>
      : GetScalarType<T[P], AggregatePage[P]>
  }




  export type PageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
    orderBy?: PageOrderByWithAggregationInput | PageOrderByWithAggregationInput[]
    by: PageScalarFieldEnum[] | PageScalarFieldEnum
    having?: PageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageCountAggregateInputType | true
    _min?: PageMinAggregateInputType
    _max?: PageMaxAggregateInputType
  }

  export type PageGroupByOutputType = {
    id: string
    title: string
    slug: string
    content: string
    type: string
    createdAt: Date
    updatedAt: Date
    _count: PageCountAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  type GetPageGroupByPayload<T extends PageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageGroupByOutputType[P]>
            : GetScalarType<T[P], PageGroupByOutputType[P]>
        }
      >
    >


  export type PageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["page"]>

  export type PageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["page"]>

  export type PageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["page"]>

  export type PageSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "content" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["page"]>

  export type $PagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Page"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      content: string
      type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["page"]>
    composites: {}
  }

  type PageGetPayload<S extends boolean | null | undefined | PageDefaultArgs> = $Result.GetResult<Prisma.$PagePayload, S>

  type PageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageCountAggregateInputType | true
    }

  export interface PageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Page'], meta: { name: 'Page' } }
    /**
     * Find zero or one Page that matches the filter.
     * @param {PageFindUniqueArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageFindUniqueArgs>(args: SelectSubset<T, PageFindUniqueArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Page that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageFindUniqueOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageFindUniqueOrThrowArgs>(args: SelectSubset<T, PageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Page that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageFindFirstArgs>(args?: SelectSubset<T, PageFindFirstArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Page that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageFindFirstOrThrowArgs>(args?: SelectSubset<T, PageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.page.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.page.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageWithIdOnly = await prisma.page.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageFindManyArgs>(args?: SelectSubset<T, PageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Page.
     * @param {PageCreateArgs} args - Arguments to create a Page.
     * @example
     * // Create one Page
     * const Page = await prisma.page.create({
     *   data: {
     *     // ... data to create a Page
     *   }
     * })
     * 
     */
    create<T extends PageCreateArgs>(args: SelectSubset<T, PageCreateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pages.
     * @param {PageCreateManyArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageCreateManyArgs>(args?: SelectSubset<T, PageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pages and returns the data saved in the database.
     * @param {PageCreateManyAndReturnArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageCreateManyAndReturnArgs>(args?: SelectSubset<T, PageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Page.
     * @param {PageDeleteArgs} args - Arguments to delete one Page.
     * @example
     * // Delete one Page
     * const Page = await prisma.page.delete({
     *   where: {
     *     // ... filter to delete one Page
     *   }
     * })
     * 
     */
    delete<T extends PageDeleteArgs>(args: SelectSubset<T, PageDeleteArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Page.
     * @param {PageUpdateArgs} args - Arguments to update one Page.
     * @example
     * // Update one Page
     * const page = await prisma.page.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageUpdateArgs>(args: SelectSubset<T, PageUpdateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pages.
     * @param {PageDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.page.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageDeleteManyArgs>(args?: SelectSubset<T, PageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageUpdateManyArgs>(args: SelectSubset<T, PageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages and returns the data updated in the database.
     * @param {PageUpdateManyAndReturnArgs} args - Arguments to update many Pages.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageUpdateManyAndReturnArgs>(args: SelectSubset<T, PageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Page.
     * @param {PageUpsertArgs} args - Arguments to update or create a Page.
     * @example
     * // Update or create a Page
     * const page = await prisma.page.upsert({
     *   create: {
     *     // ... data to create a Page
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Page we want to update
     *   }
     * })
     */
    upsert<T extends PageUpsertArgs>(args: SelectSubset<T, PageUpsertArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.page.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends PageCountArgs>(
      args?: Subset<T, PageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageAggregateArgs>(args: Subset<T, PageAggregateArgs>): Prisma.PrismaPromise<GetPageAggregateType<T>>

    /**
     * Group by Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageGroupByArgs['orderBy'] }
        : { orderBy?: PageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Page model
   */
  readonly fields: PageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Page.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Page model
   */
  interface PageFieldRefs {
    readonly id: FieldRef<"Page", 'String'>
    readonly title: FieldRef<"Page", 'String'>
    readonly slug: FieldRef<"Page", 'String'>
    readonly content: FieldRef<"Page", 'String'>
    readonly type: FieldRef<"Page", 'String'>
    readonly createdAt: FieldRef<"Page", 'DateTime'>
    readonly updatedAt: FieldRef<"Page", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Page findUnique
   */
  export type PageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findUniqueOrThrow
   */
  export type PageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findFirst
   */
  export type PageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findFirstOrThrow
   */
  export type PageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findMany
   */
  export type PageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Filter, which Pages to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page create
   */
  export type PageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data needed to create a Page.
     */
    data: XOR<PageCreateInput, PageUncheckedCreateInput>
  }

  /**
   * Page createMany
   */
  export type PageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Page createManyAndReturn
   */
  export type PageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Page update
   */
  export type PageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data needed to update a Page.
     */
    data: XOR<PageUpdateInput, PageUncheckedUpdateInput>
    /**
     * Choose, which Page to update.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page updateMany
   */
  export type PageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
  }

  /**
   * Page updateManyAndReturn
   */
  export type PageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
  }

  /**
   * Page upsert
   */
  export type PageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The filter to search for the Page to update in case it exists.
     */
    where: PageWhereUniqueInput
    /**
     * In case the Page found by the `where` argument doesn't exist, create a new Page with this data.
     */
    create: XOR<PageCreateInput, PageUncheckedCreateInput>
    /**
     * In case the Page was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageUpdateInput, PageUncheckedUpdateInput>
  }

  /**
   * Page delete
   */
  export type PageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Filter which Page to delete.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page deleteMany
   */
  export type PageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pages to delete
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to delete.
     */
    limit?: number
  }

  /**
   * Page without action
   */
  export type PageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
  }


  /**
   * Model Quiz
   */

  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    type: string | null
    chapterId: string | null
    courseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type QuizMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    type: string | null
    chapterId: string | null
    courseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    type: number
    chapterId: number
    courseId: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type QuizMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    type?: true
    chapterId?: true
    courseId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    type?: true
    chapterId?: true
    courseId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    type?: true
    chapterId?: true
    courseId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type QuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quiz to aggregate.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithAggregationInput | QuizOrderByWithAggregationInput[]
    by: QuizScalarFieldEnum[] | QuizScalarFieldEnum
    having?: QuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }

  export type QuizGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string | null
    type: string | null
    chapterId: string | null
    courseId: string | null
    createdAt: Date
    updatedAt: Date
    userId: string | null
    _count: QuizCountAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type QuizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    chapterId?: boolean
    courseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    user?: boolean | Quiz$userArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    chapterId?: boolean
    courseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | Quiz$userArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    chapterId?: boolean
    courseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | Quiz$userArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    chapterId?: boolean
    courseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type QuizOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "description" | "type" | "chapterId" | "courseId" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["quiz"]>
  export type QuizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    user?: boolean | Quiz$userArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Quiz$userArgs<ExtArgs>
  }
  export type QuizIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Quiz$userArgs<ExtArgs>
  }

  export type $QuizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quiz"
    objects: {
      questions: Prisma.$QuizQuestionPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      description: string | null
      type: string | null
      chapterId: string | null
      courseId: string | null
      createdAt: Date
      updatedAt: Date
      userId: string | null
    }, ExtArgs["result"]["quiz"]>
    composites: {}
  }

  type QuizGetPayload<S extends boolean | null | undefined | QuizDefaultArgs> = $Result.GetResult<Prisma.$QuizPayload, S>

  type QuizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface QuizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quiz'], meta: { name: 'Quiz' } }
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {QuizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizFindUniqueArgs>(args: SelectSubset<T, QuizFindUniqueArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quiz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizFindFirstArgs>(args?: SelectSubset<T, QuizFindFirstArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizFindManyArgs>(args?: SelectSubset<T, QuizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quiz.
     * @param {QuizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
     */
    create<T extends QuizCreateArgs>(args: SelectSubset<T, QuizCreateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quizzes.
     * @param {QuizCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizCreateManyArgs>(args?: SelectSubset<T, QuizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quizzes and returns the data saved in the database.
     * @param {QuizCreateManyAndReturnArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quiz.
     * @param {QuizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
     */
    delete<T extends QuizDeleteArgs>(args: SelectSubset<T, QuizDeleteArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quiz.
     * @param {QuizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizUpdateArgs>(args: SelectSubset<T, QuizUpdateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizDeleteManyArgs>(args?: SelectSubset<T, QuizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizUpdateManyArgs>(args: SelectSubset<T, QuizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes and returns the data updated in the database.
     * @param {QuizUpdateManyAndReturnArgs} args - Arguments to update many Quizzes.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quiz.
     * @param {QuizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
     */
    upsert<T extends QuizUpsertArgs>(args: SelectSubset<T, QuizUpsertArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizCountArgs>(
      args?: Subset<T, QuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quiz model
   */
  readonly fields: QuizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends Quiz$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Quiz$userArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quiz model
   */
  interface QuizFieldRefs {
    readonly id: FieldRef<"Quiz", 'String'>
    readonly title: FieldRef<"Quiz", 'String'>
    readonly slug: FieldRef<"Quiz", 'String'>
    readonly description: FieldRef<"Quiz", 'String'>
    readonly type: FieldRef<"Quiz", 'String'>
    readonly chapterId: FieldRef<"Quiz", 'String'>
    readonly courseId: FieldRef<"Quiz", 'String'>
    readonly createdAt: FieldRef<"Quiz", 'DateTime'>
    readonly updatedAt: FieldRef<"Quiz", 'DateTime'>
    readonly userId: FieldRef<"Quiz", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Quiz findUnique
   */
  export type QuizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findUniqueOrThrow
   */
  export type QuizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findFirst
   */
  export type QuizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findFirstOrThrow
   */
  export type QuizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findMany
   */
  export type QuizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz create
   */
  export type QuizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to create a Quiz.
     */
    data: XOR<QuizCreateInput, QuizUncheckedCreateInput>
  }

  /**
   * Quiz createMany
   */
  export type QuizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quiz createManyAndReturn
   */
  export type QuizCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz update
   */
  export type QuizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to update a Quiz.
     */
    data: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
    /**
     * Choose, which Quiz to update.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz updateMany
   */
  export type QuizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
  }

  /**
   * Quiz updateManyAndReturn
   */
  export type QuizUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz upsert
   */
  export type QuizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The filter to search for the Quiz to update in case it exists.
     */
    where: QuizWhereUniqueInput
    /**
     * In case the Quiz found by the `where` argument doesn't exist, create a new Quiz with this data.
     */
    create: XOR<QuizCreateInput, QuizUncheckedCreateInput>
    /**
     * In case the Quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
  }

  /**
   * Quiz delete
   */
  export type QuizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter which Quiz to delete.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz deleteMany
   */
  export type QuizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to delete.
     */
    limit?: number
  }

  /**
   * Quiz.questions
   */
  export type Quiz$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    cursor?: QuizQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * Quiz.user
   */
  export type Quiz$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Quiz without action
   */
  export type QuizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestion
   */

  export type AggregateQuizQuestion = {
    _count: QuizQuestionCountAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  export type QuizQuestionMinAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    quizId: string | null
  }

  export type QuizQuestionMaxAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    quizId: string | null
  }

  export type QuizQuestionCountAggregateOutputType = {
    id: number
    question: number
    type: number
    quizId: number
    _all: number
  }


  export type QuizQuestionMinAggregateInputType = {
    id?: true
    question?: true
    type?: true
    quizId?: true
  }

  export type QuizQuestionMaxAggregateInputType = {
    id?: true
    question?: true
    type?: true
    quizId?: true
  }

  export type QuizQuestionCountAggregateInputType = {
    id?: true
    question?: true
    type?: true
    quizId?: true
    _all?: true
  }

  export type QuizQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestion to aggregate.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestions
    **/
    _count?: true | QuizQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type GetQuizQuestionAggregateType<T extends QuizQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestion[P]>
      : GetScalarType<T[P], AggregateQuizQuestion[P]>
  }




  export type QuizQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithAggregationInput | QuizQuestionOrderByWithAggregationInput[]
    by: QuizQuestionScalarFieldEnum[] | QuizQuestionScalarFieldEnum
    having?: QuizQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionCountAggregateInputType | true
    _min?: QuizQuestionMinAggregateInputType
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type QuizQuestionGroupByOutputType = {
    id: string
    question: string
    type: string | null
    quizId: string
    _count: QuizQuestionCountAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupByPayload<T extends QuizQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    type?: boolean
    quizId?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    options?: boolean | QuizQuestion$optionsArgs<ExtArgs>
    _count?: boolean | QuizQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    type?: boolean
    quizId?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    type?: boolean
    quizId?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectScalar = {
    id?: boolean
    question?: boolean
    type?: boolean
    quizId?: boolean
  }

  export type QuizQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "type" | "quizId", ExtArgs["result"]["quizQuestion"]>
  export type QuizQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    options?: boolean | QuizQuestion$optionsArgs<ExtArgs>
    _count?: boolean | QuizQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }

  export type $QuizQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestion"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
      options: Prisma.$QuizOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      type: string | null
      quizId: string
    }, ExtArgs["result"]["quizQuestion"]>
    composites: {}
  }

  type QuizQuestionGetPayload<S extends boolean | null | undefined | QuizQuestionDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionPayload, S>

  type QuizQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionCountAggregateInputType | true
    }

  export interface QuizQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestion'], meta: { name: 'QuizQuestion' } }
    /**
     * Find zero or one QuizQuestion that matches the filter.
     * @param {QuizQuestionFindUniqueArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionFindUniqueArgs>(args: SelectSubset<T, QuizQuestionFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionFindFirstArgs>(args?: SelectSubset<T, QuizQuestionFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany()
     * 
     * // Get first 10 QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionFindManyArgs>(args?: SelectSubset<T, QuizQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizQuestion.
     * @param {QuizQuestionCreateArgs} args - Arguments to create a QuizQuestion.
     * @example
     * // Create one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.create({
     *   data: {
     *     // ... data to create a QuizQuestion
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionCreateArgs>(args: SelectSubset<T, QuizQuestionCreateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizQuestions.
     * @param {QuizQuestionCreateManyArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionCreateManyArgs>(args?: SelectSubset<T, QuizQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestions and returns the data saved in the database.
     * @param {QuizQuestionCreateManyAndReturnArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizQuestion.
     * @param {QuizQuestionDeleteArgs} args - Arguments to delete one QuizQuestion.
     * @example
     * // Delete one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestion
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionDeleteArgs>(args: SelectSubset<T, QuizQuestionDeleteArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizQuestion.
     * @param {QuizQuestionUpdateArgs} args - Arguments to update one QuizQuestion.
     * @example
     * // Update one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionUpdateArgs>(args: SelectSubset<T, QuizQuestionUpdateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizQuestions.
     * @param {QuizQuestionDeleteManyArgs} args - Arguments to filter QuizQuestions to delete.
     * @example
     * // Delete a few QuizQuestions
     * const { count } = await prisma.quizQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionUpdateManyArgs>(args: SelectSubset<T, QuizQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions and returns the data updated in the database.
     * @param {QuizQuestionUpdateManyAndReturnArgs} args - Arguments to update many QuizQuestions.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizQuestion.
     * @param {QuizQuestionUpsertArgs} args - Arguments to update or create a QuizQuestion.
     * @example
     * // Update or create a QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestion we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionUpsertArgs>(args: SelectSubset<T, QuizQuestionUpsertArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionCountArgs} args - Arguments to filter QuizQuestions to count.
     * @example
     * // Count the number of QuizQuestions
     * const count = await prisma.quizQuestion.count({
     *   where: {
     *     // ... the filter for the QuizQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionCountArgs>(
      args?: Subset<T, QuizQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionAggregateArgs>(args: Subset<T, QuizQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionAggregateType<T>>

    /**
     * Group by QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestion model
   */
  readonly fields: QuizQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    options<T extends QuizQuestion$optionsArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestion$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestion model
   */
  interface QuizQuestionFieldRefs {
    readonly id: FieldRef<"QuizQuestion", 'String'>
    readonly question: FieldRef<"QuizQuestion", 'String'>
    readonly type: FieldRef<"QuizQuestion", 'String'>
    readonly quizId: FieldRef<"QuizQuestion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestion findUnique
   */
  export type QuizQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findUniqueOrThrow
   */
  export type QuizQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findFirst
   */
  export type QuizQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findFirstOrThrow
   */
  export type QuizQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findMany
   */
  export type QuizQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestions to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion create
   */
  export type QuizQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestion.
     */
    data: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
  }

  /**
   * QuizQuestion createMany
   */
  export type QuizQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestion createManyAndReturn
   */
  export type QuizQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion update
   */
  export type QuizQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestion.
     */
    data: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestion to update.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion updateMany
   */
  export type QuizQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
  }

  /**
   * QuizQuestion updateManyAndReturn
   */
  export type QuizQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion upsert
   */
  export type QuizQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestion to update in case it exists.
     */
    where: QuizQuestionWhereUniqueInput
    /**
     * In case the QuizQuestion found by the `where` argument doesn't exist, create a new QuizQuestion with this data.
     */
    create: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
    /**
     * In case the QuizQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
  }

  /**
   * QuizQuestion delete
   */
  export type QuizQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter which QuizQuestion to delete.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion deleteMany
   */
  export type QuizQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestions to delete
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to delete.
     */
    limit?: number
  }

  /**
   * QuizQuestion.options
   */
  export type QuizQuestion$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    where?: QuizOptionWhereInput
    orderBy?: QuizOptionOrderByWithRelationInput | QuizOptionOrderByWithRelationInput[]
    cursor?: QuizOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizOptionScalarFieldEnum | QuizOptionScalarFieldEnum[]
  }

  /**
   * QuizQuestion without action
   */
  export type QuizQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
  }


  /**
   * Model QuizOption
   */

  export type AggregateQuizOption = {
    _count: QuizOptionCountAggregateOutputType | null
    _min: QuizOptionMinAggregateOutputType | null
    _max: QuizOptionMaxAggregateOutputType | null
  }

  export type QuizOptionMinAggregateOutputType = {
    id: string | null
    content: string | null
    isCorrect: boolean | null
    questionId: string | null
  }

  export type QuizOptionMaxAggregateOutputType = {
    id: string | null
    content: string | null
    isCorrect: boolean | null
    questionId: string | null
  }

  export type QuizOptionCountAggregateOutputType = {
    id: number
    content: number
    isCorrect: number
    questionId: number
    _all: number
  }


  export type QuizOptionMinAggregateInputType = {
    id?: true
    content?: true
    isCorrect?: true
    questionId?: true
  }

  export type QuizOptionMaxAggregateInputType = {
    id?: true
    content?: true
    isCorrect?: true
    questionId?: true
  }

  export type QuizOptionCountAggregateInputType = {
    id?: true
    content?: true
    isCorrect?: true
    questionId?: true
    _all?: true
  }

  export type QuizOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizOption to aggregate.
     */
    where?: QuizOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizOptions to fetch.
     */
    orderBy?: QuizOptionOrderByWithRelationInput | QuizOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizOptions
    **/
    _count?: true | QuizOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizOptionMaxAggregateInputType
  }

  export type GetQuizOptionAggregateType<T extends QuizOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizOption[P]>
      : GetScalarType<T[P], AggregateQuizOption[P]>
  }




  export type QuizOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizOptionWhereInput
    orderBy?: QuizOptionOrderByWithAggregationInput | QuizOptionOrderByWithAggregationInput[]
    by: QuizOptionScalarFieldEnum[] | QuizOptionScalarFieldEnum
    having?: QuizOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizOptionCountAggregateInputType | true
    _min?: QuizOptionMinAggregateInputType
    _max?: QuizOptionMaxAggregateInputType
  }

  export type QuizOptionGroupByOutputType = {
    id: string
    content: string
    isCorrect: boolean
    questionId: string
    _count: QuizOptionCountAggregateOutputType | null
    _min: QuizOptionMinAggregateOutputType | null
    _max: QuizOptionMaxAggregateOutputType | null
  }

  type GetQuizOptionGroupByPayload<T extends QuizOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizOptionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizOptionGroupByOutputType[P]>
        }
      >
    >


  export type QuizOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isCorrect?: boolean
    questionId?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizOption"]>

  export type QuizOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isCorrect?: boolean
    questionId?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizOption"]>

  export type QuizOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isCorrect?: boolean
    questionId?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizOption"]>

  export type QuizOptionSelectScalar = {
    id?: boolean
    content?: boolean
    isCorrect?: boolean
    questionId?: boolean
  }

  export type QuizOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "isCorrect" | "questionId", ExtArgs["result"]["quizOption"]>
  export type QuizOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }
  export type QuizOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }
  export type QuizOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }

  export type $QuizOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizOption"
    objects: {
      question: Prisma.$QuizQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      isCorrect: boolean
      questionId: string
    }, ExtArgs["result"]["quizOption"]>
    composites: {}
  }

  type QuizOptionGetPayload<S extends boolean | null | undefined | QuizOptionDefaultArgs> = $Result.GetResult<Prisma.$QuizOptionPayload, S>

  type QuizOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizOptionCountAggregateInputType | true
    }

  export interface QuizOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizOption'], meta: { name: 'QuizOption' } }
    /**
     * Find zero or one QuizOption that matches the filter.
     * @param {QuizOptionFindUniqueArgs} args - Arguments to find a QuizOption
     * @example
     * // Get one QuizOption
     * const quizOption = await prisma.quizOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizOptionFindUniqueArgs>(args: SelectSubset<T, QuizOptionFindUniqueArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizOptionFindUniqueOrThrowArgs} args - Arguments to find a QuizOption
     * @example
     * // Get one QuizOption
     * const quizOption = await prisma.quizOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionFindFirstArgs} args - Arguments to find a QuizOption
     * @example
     * // Get one QuizOption
     * const quizOption = await prisma.quizOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizOptionFindFirstArgs>(args?: SelectSubset<T, QuizOptionFindFirstArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionFindFirstOrThrowArgs} args - Arguments to find a QuizOption
     * @example
     * // Get one QuizOption
     * const quizOption = await prisma.quizOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizOptions
     * const quizOptions = await prisma.quizOption.findMany()
     * 
     * // Get first 10 QuizOptions
     * const quizOptions = await prisma.quizOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizOptionWithIdOnly = await prisma.quizOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizOptionFindManyArgs>(args?: SelectSubset<T, QuizOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizOption.
     * @param {QuizOptionCreateArgs} args - Arguments to create a QuizOption.
     * @example
     * // Create one QuizOption
     * const QuizOption = await prisma.quizOption.create({
     *   data: {
     *     // ... data to create a QuizOption
     *   }
     * })
     * 
     */
    create<T extends QuizOptionCreateArgs>(args: SelectSubset<T, QuizOptionCreateArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizOptions.
     * @param {QuizOptionCreateManyArgs} args - Arguments to create many QuizOptions.
     * @example
     * // Create many QuizOptions
     * const quizOption = await prisma.quizOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizOptionCreateManyArgs>(args?: SelectSubset<T, QuizOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizOptions and returns the data saved in the database.
     * @param {QuizOptionCreateManyAndReturnArgs} args - Arguments to create many QuizOptions.
     * @example
     * // Create many QuizOptions
     * const quizOption = await prisma.quizOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizOptions and only return the `id`
     * const quizOptionWithIdOnly = await prisma.quizOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizOption.
     * @param {QuizOptionDeleteArgs} args - Arguments to delete one QuizOption.
     * @example
     * // Delete one QuizOption
     * const QuizOption = await prisma.quizOption.delete({
     *   where: {
     *     // ... filter to delete one QuizOption
     *   }
     * })
     * 
     */
    delete<T extends QuizOptionDeleteArgs>(args: SelectSubset<T, QuizOptionDeleteArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizOption.
     * @param {QuizOptionUpdateArgs} args - Arguments to update one QuizOption.
     * @example
     * // Update one QuizOption
     * const quizOption = await prisma.quizOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizOptionUpdateArgs>(args: SelectSubset<T, QuizOptionUpdateArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizOptions.
     * @param {QuizOptionDeleteManyArgs} args - Arguments to filter QuizOptions to delete.
     * @example
     * // Delete a few QuizOptions
     * const { count } = await prisma.quizOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizOptionDeleteManyArgs>(args?: SelectSubset<T, QuizOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizOptions
     * const quizOption = await prisma.quizOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizOptionUpdateManyArgs>(args: SelectSubset<T, QuizOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizOptions and returns the data updated in the database.
     * @param {QuizOptionUpdateManyAndReturnArgs} args - Arguments to update many QuizOptions.
     * @example
     * // Update many QuizOptions
     * const quizOption = await prisma.quizOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizOptions and only return the `id`
     * const quizOptionWithIdOnly = await prisma.quizOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizOption.
     * @param {QuizOptionUpsertArgs} args - Arguments to update or create a QuizOption.
     * @example
     * // Update or create a QuizOption
     * const quizOption = await prisma.quizOption.upsert({
     *   create: {
     *     // ... data to create a QuizOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizOption we want to update
     *   }
     * })
     */
    upsert<T extends QuizOptionUpsertArgs>(args: SelectSubset<T, QuizOptionUpsertArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionCountArgs} args - Arguments to filter QuizOptions to count.
     * @example
     * // Count the number of QuizOptions
     * const count = await prisma.quizOption.count({
     *   where: {
     *     // ... the filter for the QuizOptions we want to count
     *   }
     * })
    **/
    count<T extends QuizOptionCountArgs>(
      args?: Subset<T, QuizOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizOptionAggregateArgs>(args: Subset<T, QuizOptionAggregateArgs>): Prisma.PrismaPromise<GetQuizOptionAggregateType<T>>

    /**
     * Group by QuizOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizOptionGroupByArgs['orderBy'] }
        : { orderBy?: QuizOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizOption model
   */
  readonly fields: QuizOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuizQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestionDefaultArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizOption model
   */
  interface QuizOptionFieldRefs {
    readonly id: FieldRef<"QuizOption", 'String'>
    readonly content: FieldRef<"QuizOption", 'String'>
    readonly isCorrect: FieldRef<"QuizOption", 'Boolean'>
    readonly questionId: FieldRef<"QuizOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuizOption findUnique
   */
  export type QuizOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizOption to fetch.
     */
    where: QuizOptionWhereUniqueInput
  }

  /**
   * QuizOption findUniqueOrThrow
   */
  export type QuizOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizOption to fetch.
     */
    where: QuizOptionWhereUniqueInput
  }

  /**
   * QuizOption findFirst
   */
  export type QuizOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizOption to fetch.
     */
    where?: QuizOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizOptions to fetch.
     */
    orderBy?: QuizOptionOrderByWithRelationInput | QuizOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizOptions.
     */
    cursor?: QuizOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizOptions.
     */
    distinct?: QuizOptionScalarFieldEnum | QuizOptionScalarFieldEnum[]
  }

  /**
   * QuizOption findFirstOrThrow
   */
  export type QuizOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizOption to fetch.
     */
    where?: QuizOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizOptions to fetch.
     */
    orderBy?: QuizOptionOrderByWithRelationInput | QuizOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizOptions.
     */
    cursor?: QuizOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizOptions.
     */
    distinct?: QuizOptionScalarFieldEnum | QuizOptionScalarFieldEnum[]
  }

  /**
   * QuizOption findMany
   */
  export type QuizOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizOptions to fetch.
     */
    where?: QuizOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizOptions to fetch.
     */
    orderBy?: QuizOptionOrderByWithRelationInput | QuizOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizOptions.
     */
    cursor?: QuizOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizOptions.
     */
    skip?: number
    distinct?: QuizOptionScalarFieldEnum | QuizOptionScalarFieldEnum[]
  }

  /**
   * QuizOption create
   */
  export type QuizOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizOption.
     */
    data: XOR<QuizOptionCreateInput, QuizOptionUncheckedCreateInput>
  }

  /**
   * QuizOption createMany
   */
  export type QuizOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizOptions.
     */
    data: QuizOptionCreateManyInput | QuizOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizOption createManyAndReturn
   */
  export type QuizOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizOptions.
     */
    data: QuizOptionCreateManyInput | QuizOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizOption update
   */
  export type QuizOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizOption.
     */
    data: XOR<QuizOptionUpdateInput, QuizOptionUncheckedUpdateInput>
    /**
     * Choose, which QuizOption to update.
     */
    where: QuizOptionWhereUniqueInput
  }

  /**
   * QuizOption updateMany
   */
  export type QuizOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizOptions.
     */
    data: XOR<QuizOptionUpdateManyMutationInput, QuizOptionUncheckedUpdateManyInput>
    /**
     * Filter which QuizOptions to update
     */
    where?: QuizOptionWhereInput
    /**
     * Limit how many QuizOptions to update.
     */
    limit?: number
  }

  /**
   * QuizOption updateManyAndReturn
   */
  export type QuizOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * The data used to update QuizOptions.
     */
    data: XOR<QuizOptionUpdateManyMutationInput, QuizOptionUncheckedUpdateManyInput>
    /**
     * Filter which QuizOptions to update
     */
    where?: QuizOptionWhereInput
    /**
     * Limit how many QuizOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizOption upsert
   */
  export type QuizOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizOption to update in case it exists.
     */
    where: QuizOptionWhereUniqueInput
    /**
     * In case the QuizOption found by the `where` argument doesn't exist, create a new QuizOption with this data.
     */
    create: XOR<QuizOptionCreateInput, QuizOptionUncheckedCreateInput>
    /**
     * In case the QuizOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizOptionUpdateInput, QuizOptionUncheckedUpdateInput>
  }

  /**
   * QuizOption delete
   */
  export type QuizOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * Filter which QuizOption to delete.
     */
    where: QuizOptionWhereUniqueInput
  }

  /**
   * QuizOption deleteMany
   */
  export type QuizOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizOptions to delete
     */
    where?: QuizOptionWhereInput
    /**
     * Limit how many QuizOptions to delete.
     */
    limit?: number
  }

  /**
   * QuizOption without action
   */
  export type QuizOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
  }


  /**
   * Model QuizResult
   */

  export type AggregateQuizResult = {
    _count: QuizResultCountAggregateOutputType | null
    _avg: QuizResultAvgAggregateOutputType | null
    _sum: QuizResultSumAggregateOutputType | null
    _min: QuizResultMinAggregateOutputType | null
    _max: QuizResultMaxAggregateOutputType | null
  }

  export type QuizResultAvgAggregateOutputType = {
    score: number | null
  }

  export type QuizResultSumAggregateOutputType = {
    score: number | null
  }

  export type QuizResultMinAggregateOutputType = {
    id: string | null
    userId: string | null
    quizId: string | null
    score: number | null
    passed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizResultMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    quizId: string | null
    score: number | null
    passed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizResultCountAggregateOutputType = {
    id: number
    userId: number
    quizId: number
    score: number
    passed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizResultAvgAggregateInputType = {
    score?: true
  }

  export type QuizResultSumAggregateInputType = {
    score?: true
  }

  export type QuizResultMinAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    score?: true
    passed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizResultMaxAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    score?: true
    passed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizResultCountAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    score?: true
    passed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizResult to aggregate.
     */
    where?: QuizResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResults to fetch.
     */
    orderBy?: QuizResultOrderByWithRelationInput | QuizResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizResults
    **/
    _count?: true | QuizResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizResultMaxAggregateInputType
  }

  export type GetQuizResultAggregateType<T extends QuizResultAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizResult[P]>
      : GetScalarType<T[P], AggregateQuizResult[P]>
  }




  export type QuizResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizResultWhereInput
    orderBy?: QuizResultOrderByWithAggregationInput | QuizResultOrderByWithAggregationInput[]
    by: QuizResultScalarFieldEnum[] | QuizResultScalarFieldEnum
    having?: QuizResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizResultCountAggregateInputType | true
    _avg?: QuizResultAvgAggregateInputType
    _sum?: QuizResultSumAggregateInputType
    _min?: QuizResultMinAggregateInputType
    _max?: QuizResultMaxAggregateInputType
  }

  export type QuizResultGroupByOutputType = {
    id: string
    userId: string
    quizId: string
    score: number
    passed: boolean
    createdAt: Date
    updatedAt: Date
    _count: QuizResultCountAggregateOutputType | null
    _avg: QuizResultAvgAggregateOutputType | null
    _sum: QuizResultSumAggregateOutputType | null
    _min: QuizResultMinAggregateOutputType | null
    _max: QuizResultMaxAggregateOutputType | null
  }

  type GetQuizResultGroupByPayload<T extends QuizResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizResultGroupByOutputType[P]>
            : GetScalarType<T[P], QuizResultGroupByOutputType[P]>
        }
      >
    >


  export type QuizResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    quizId?: boolean
    score?: boolean
    passed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["quizResult"]>

  export type QuizResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    quizId?: boolean
    score?: boolean
    passed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["quizResult"]>

  export type QuizResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    quizId?: boolean
    score?: boolean
    passed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["quizResult"]>

  export type QuizResultSelectScalar = {
    id?: boolean
    userId?: boolean
    quizId?: boolean
    score?: boolean
    passed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuizResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "quizId" | "score" | "passed" | "createdAt" | "updatedAt", ExtArgs["result"]["quizResult"]>

  export type $QuizResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizResult"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      quizId: string
      score: number
      passed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quizResult"]>
    composites: {}
  }

  type QuizResultGetPayload<S extends boolean | null | undefined | QuizResultDefaultArgs> = $Result.GetResult<Prisma.$QuizResultPayload, S>

  type QuizResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizResultCountAggregateInputType | true
    }

  export interface QuizResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizResult'], meta: { name: 'QuizResult' } }
    /**
     * Find zero or one QuizResult that matches the filter.
     * @param {QuizResultFindUniqueArgs} args - Arguments to find a QuizResult
     * @example
     * // Get one QuizResult
     * const quizResult = await prisma.quizResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizResultFindUniqueArgs>(args: SelectSubset<T, QuizResultFindUniqueArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizResultFindUniqueOrThrowArgs} args - Arguments to find a QuizResult
     * @example
     * // Get one QuizResult
     * const quizResult = await prisma.quizResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizResultFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultFindFirstArgs} args - Arguments to find a QuizResult
     * @example
     * // Get one QuizResult
     * const quizResult = await prisma.quizResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizResultFindFirstArgs>(args?: SelectSubset<T, QuizResultFindFirstArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultFindFirstOrThrowArgs} args - Arguments to find a QuizResult
     * @example
     * // Get one QuizResult
     * const quizResult = await prisma.quizResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizResultFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizResults
     * const quizResults = await prisma.quizResult.findMany()
     * 
     * // Get first 10 QuizResults
     * const quizResults = await prisma.quizResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizResultWithIdOnly = await prisma.quizResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizResultFindManyArgs>(args?: SelectSubset<T, QuizResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizResult.
     * @param {QuizResultCreateArgs} args - Arguments to create a QuizResult.
     * @example
     * // Create one QuizResult
     * const QuizResult = await prisma.quizResult.create({
     *   data: {
     *     // ... data to create a QuizResult
     *   }
     * })
     * 
     */
    create<T extends QuizResultCreateArgs>(args: SelectSubset<T, QuizResultCreateArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizResults.
     * @param {QuizResultCreateManyArgs} args - Arguments to create many QuizResults.
     * @example
     * // Create many QuizResults
     * const quizResult = await prisma.quizResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizResultCreateManyArgs>(args?: SelectSubset<T, QuizResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizResults and returns the data saved in the database.
     * @param {QuizResultCreateManyAndReturnArgs} args - Arguments to create many QuizResults.
     * @example
     * // Create many QuizResults
     * const quizResult = await prisma.quizResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizResults and only return the `id`
     * const quizResultWithIdOnly = await prisma.quizResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizResultCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizResult.
     * @param {QuizResultDeleteArgs} args - Arguments to delete one QuizResult.
     * @example
     * // Delete one QuizResult
     * const QuizResult = await prisma.quizResult.delete({
     *   where: {
     *     // ... filter to delete one QuizResult
     *   }
     * })
     * 
     */
    delete<T extends QuizResultDeleteArgs>(args: SelectSubset<T, QuizResultDeleteArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizResult.
     * @param {QuizResultUpdateArgs} args - Arguments to update one QuizResult.
     * @example
     * // Update one QuizResult
     * const quizResult = await prisma.quizResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizResultUpdateArgs>(args: SelectSubset<T, QuizResultUpdateArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizResults.
     * @param {QuizResultDeleteManyArgs} args - Arguments to filter QuizResults to delete.
     * @example
     * // Delete a few QuizResults
     * const { count } = await prisma.quizResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizResultDeleteManyArgs>(args?: SelectSubset<T, QuizResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizResults
     * const quizResult = await prisma.quizResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizResultUpdateManyArgs>(args: SelectSubset<T, QuizResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizResults and returns the data updated in the database.
     * @param {QuizResultUpdateManyAndReturnArgs} args - Arguments to update many QuizResults.
     * @example
     * // Update many QuizResults
     * const quizResult = await prisma.quizResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizResults and only return the `id`
     * const quizResultWithIdOnly = await prisma.quizResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizResultUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizResult.
     * @param {QuizResultUpsertArgs} args - Arguments to update or create a QuizResult.
     * @example
     * // Update or create a QuizResult
     * const quizResult = await prisma.quizResult.upsert({
     *   create: {
     *     // ... data to create a QuizResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizResult we want to update
     *   }
     * })
     */
    upsert<T extends QuizResultUpsertArgs>(args: SelectSubset<T, QuizResultUpsertArgs<ExtArgs>>): Prisma__QuizResultClient<$Result.GetResult<Prisma.$QuizResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultCountArgs} args - Arguments to filter QuizResults to count.
     * @example
     * // Count the number of QuizResults
     * const count = await prisma.quizResult.count({
     *   where: {
     *     // ... the filter for the QuizResults we want to count
     *   }
     * })
    **/
    count<T extends QuizResultCountArgs>(
      args?: Subset<T, QuizResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizResultAggregateArgs>(args: Subset<T, QuizResultAggregateArgs>): Prisma.PrismaPromise<GetQuizResultAggregateType<T>>

    /**
     * Group by QuizResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizResultGroupByArgs['orderBy'] }
        : { orderBy?: QuizResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizResult model
   */
  readonly fields: QuizResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizResult model
   */
  interface QuizResultFieldRefs {
    readonly id: FieldRef<"QuizResult", 'String'>
    readonly userId: FieldRef<"QuizResult", 'String'>
    readonly quizId: FieldRef<"QuizResult", 'String'>
    readonly score: FieldRef<"QuizResult", 'Float'>
    readonly passed: FieldRef<"QuizResult", 'Boolean'>
    readonly createdAt: FieldRef<"QuizResult", 'DateTime'>
    readonly updatedAt: FieldRef<"QuizResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizResult findUnique
   */
  export type QuizResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Filter, which QuizResult to fetch.
     */
    where: QuizResultWhereUniqueInput
  }

  /**
   * QuizResult findUniqueOrThrow
   */
  export type QuizResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Filter, which QuizResult to fetch.
     */
    where: QuizResultWhereUniqueInput
  }

  /**
   * QuizResult findFirst
   */
  export type QuizResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Filter, which QuizResult to fetch.
     */
    where?: QuizResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResults to fetch.
     */
    orderBy?: QuizResultOrderByWithRelationInput | QuizResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizResults.
     */
    cursor?: QuizResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizResults.
     */
    distinct?: QuizResultScalarFieldEnum | QuizResultScalarFieldEnum[]
  }

  /**
   * QuizResult findFirstOrThrow
   */
  export type QuizResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Filter, which QuizResult to fetch.
     */
    where?: QuizResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResults to fetch.
     */
    orderBy?: QuizResultOrderByWithRelationInput | QuizResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizResults.
     */
    cursor?: QuizResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizResults.
     */
    distinct?: QuizResultScalarFieldEnum | QuizResultScalarFieldEnum[]
  }

  /**
   * QuizResult findMany
   */
  export type QuizResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Filter, which QuizResults to fetch.
     */
    where?: QuizResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResults to fetch.
     */
    orderBy?: QuizResultOrderByWithRelationInput | QuizResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizResults.
     */
    cursor?: QuizResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResults.
     */
    skip?: number
    distinct?: QuizResultScalarFieldEnum | QuizResultScalarFieldEnum[]
  }

  /**
   * QuizResult create
   */
  export type QuizResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * The data needed to create a QuizResult.
     */
    data: XOR<QuizResultCreateInput, QuizResultUncheckedCreateInput>
  }

  /**
   * QuizResult createMany
   */
  export type QuizResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizResults.
     */
    data: QuizResultCreateManyInput | QuizResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizResult createManyAndReturn
   */
  export type QuizResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * The data used to create many QuizResults.
     */
    data: QuizResultCreateManyInput | QuizResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizResult update
   */
  export type QuizResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * The data needed to update a QuizResult.
     */
    data: XOR<QuizResultUpdateInput, QuizResultUncheckedUpdateInput>
    /**
     * Choose, which QuizResult to update.
     */
    where: QuizResultWhereUniqueInput
  }

  /**
   * QuizResult updateMany
   */
  export type QuizResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizResults.
     */
    data: XOR<QuizResultUpdateManyMutationInput, QuizResultUncheckedUpdateManyInput>
    /**
     * Filter which QuizResults to update
     */
    where?: QuizResultWhereInput
    /**
     * Limit how many QuizResults to update.
     */
    limit?: number
  }

  /**
   * QuizResult updateManyAndReturn
   */
  export type QuizResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * The data used to update QuizResults.
     */
    data: XOR<QuizResultUpdateManyMutationInput, QuizResultUncheckedUpdateManyInput>
    /**
     * Filter which QuizResults to update
     */
    where?: QuizResultWhereInput
    /**
     * Limit how many QuizResults to update.
     */
    limit?: number
  }

  /**
   * QuizResult upsert
   */
  export type QuizResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * The filter to search for the QuizResult to update in case it exists.
     */
    where: QuizResultWhereUniqueInput
    /**
     * In case the QuizResult found by the `where` argument doesn't exist, create a new QuizResult with this data.
     */
    create: XOR<QuizResultCreateInput, QuizResultUncheckedCreateInput>
    /**
     * In case the QuizResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizResultUpdateInput, QuizResultUncheckedUpdateInput>
  }

  /**
   * QuizResult delete
   */
  export type QuizResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
    /**
     * Filter which QuizResult to delete.
     */
    where: QuizResultWhereUniqueInput
  }

  /**
   * QuizResult deleteMany
   */
  export type QuizResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizResults to delete
     */
    where?: QuizResultWhereInput
    /**
     * Limit how many QuizResults to delete.
     */
    limit?: number
  }

  /**
   * QuizResult without action
   */
  export type QuizResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResult
     */
    select?: QuizResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResult
     */
    omit?: QuizResultOmit<ExtArgs> | null
  }


  /**
   * Model Testimonial
   */

  export type AggregateTestimonial = {
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  export type TestimonialAvgAggregateOutputType = {
    rating: number | null
  }

  export type TestimonialSumAggregateOutputType = {
    rating: number | null
  }

  export type TestimonialMinAggregateOutputType = {
    id: string | null
    userId: string | null
    rating: number | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestimonialMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    rating: number | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestimonialCountAggregateOutputType = {
    id: number
    userId: number
    rating: number
    text: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestimonialAvgAggregateInputType = {
    rating?: true
  }

  export type TestimonialSumAggregateInputType = {
    rating?: true
  }

  export type TestimonialMinAggregateInputType = {
    id?: true
    userId?: true
    rating?: true
    text?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestimonialMaxAggregateInputType = {
    id?: true
    userId?: true
    rating?: true
    text?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestimonialCountAggregateInputType = {
    id?: true
    userId?: true
    rating?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonial to aggregate.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Testimonials
    **/
    _count?: true | TestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestimonialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestimonialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialMaxAggregateInputType
  }

  export type GetTestimonialAggregateType<T extends TestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonial[P]>
      : GetScalarType<T[P], AggregateTestimonial[P]>
  }




  export type TestimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithAggregationInput | TestimonialOrderByWithAggregationInput[]
    by: TestimonialScalarFieldEnum[] | TestimonialScalarFieldEnum
    having?: TestimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialCountAggregateInputType | true
    _avg?: TestimonialAvgAggregateInputType
    _sum?: TestimonialSumAggregateInputType
    _min?: TestimonialMinAggregateInputType
    _max?: TestimonialMaxAggregateInputType
  }

  export type TestimonialGroupByOutputType = {
    id: string
    userId: string
    rating: number
    text: string
    createdAt: Date
    updatedAt: Date
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  type GetTestimonialGroupByPayload<T extends TestimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
        }
      >
    >


  export type TestimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    rating?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    rating?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    rating?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectScalar = {
    id?: boolean
    userId?: boolean
    rating?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestimonialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "rating" | "text" | "createdAt" | "updatedAt", ExtArgs["result"]["testimonial"]>

  export type $TestimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Testimonial"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      rating: number
      text: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testimonial"]>
    composites: {}
  }

  type TestimonialGetPayload<S extends boolean | null | undefined | TestimonialDefaultArgs> = $Result.GetResult<Prisma.$TestimonialPayload, S>

  type TestimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestimonialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestimonialCountAggregateInputType | true
    }

  export interface TestimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Testimonial'], meta: { name: 'Testimonial' } }
    /**
     * Find zero or one Testimonial that matches the filter.
     * @param {TestimonialFindUniqueArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestimonialFindUniqueArgs>(args: SelectSubset<T, TestimonialFindUniqueArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Testimonial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestimonialFindUniqueOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, TestimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestimonialFindFirstArgs>(args?: SelectSubset<T, TestimonialFindFirstArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, TestimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testimonials
     * const testimonials = await prisma.testimonial.findMany()
     * 
     * // Get first 10 Testimonials
     * const testimonials = await prisma.testimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestimonialFindManyArgs>(args?: SelectSubset<T, TestimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Testimonial.
     * @param {TestimonialCreateArgs} args - Arguments to create a Testimonial.
     * @example
     * // Create one Testimonial
     * const Testimonial = await prisma.testimonial.create({
     *   data: {
     *     // ... data to create a Testimonial
     *   }
     * })
     * 
     */
    create<T extends TestimonialCreateArgs>(args: SelectSubset<T, TestimonialCreateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Testimonials.
     * @param {TestimonialCreateManyArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestimonialCreateManyArgs>(args?: SelectSubset<T, TestimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Testimonials and returns the data saved in the database.
     * @param {TestimonialCreateManyAndReturnArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Testimonials and only return the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestimonialCreateManyAndReturnArgs>(args?: SelectSubset<T, TestimonialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Testimonial.
     * @param {TestimonialDeleteArgs} args - Arguments to delete one Testimonial.
     * @example
     * // Delete one Testimonial
     * const Testimonial = await prisma.testimonial.delete({
     *   where: {
     *     // ... filter to delete one Testimonial
     *   }
     * })
     * 
     */
    delete<T extends TestimonialDeleteArgs>(args: SelectSubset<T, TestimonialDeleteArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Testimonial.
     * @param {TestimonialUpdateArgs} args - Arguments to update one Testimonial.
     * @example
     * // Update one Testimonial
     * const testimonial = await prisma.testimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestimonialUpdateArgs>(args: SelectSubset<T, TestimonialUpdateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Testimonials.
     * @param {TestimonialDeleteManyArgs} args - Arguments to filter Testimonials to delete.
     * @example
     * // Delete a few Testimonials
     * const { count } = await prisma.testimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestimonialDeleteManyArgs>(args?: SelectSubset<T, TestimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestimonialUpdateManyArgs>(args: SelectSubset<T, TestimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials and returns the data updated in the database.
     * @param {TestimonialUpdateManyAndReturnArgs} args - Arguments to update many Testimonials.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Testimonials and only return the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestimonialUpdateManyAndReturnArgs>(args: SelectSubset<T, TestimonialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Testimonial.
     * @param {TestimonialUpsertArgs} args - Arguments to update or create a Testimonial.
     * @example
     * // Update or create a Testimonial
     * const testimonial = await prisma.testimonial.upsert({
     *   create: {
     *     // ... data to create a Testimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testimonial we want to update
     *   }
     * })
     */
    upsert<T extends TestimonialUpsertArgs>(args: SelectSubset<T, TestimonialUpsertArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialCountArgs} args - Arguments to filter Testimonials to count.
     * @example
     * // Count the number of Testimonials
     * const count = await prisma.testimonial.count({
     *   where: {
     *     // ... the filter for the Testimonials we want to count
     *   }
     * })
    **/
    count<T extends TestimonialCountArgs>(
      args?: Subset<T, TestimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialAggregateArgs>(args: Subset<T, TestimonialAggregateArgs>): Prisma.PrismaPromise<GetTestimonialAggregateType<T>>

    /**
     * Group by Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestimonialGroupByArgs['orderBy'] }
        : { orderBy?: TestimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Testimonial model
   */
  readonly fields: TestimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Testimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Testimonial model
   */
  interface TestimonialFieldRefs {
    readonly id: FieldRef<"Testimonial", 'String'>
    readonly userId: FieldRef<"Testimonial", 'String'>
    readonly rating: FieldRef<"Testimonial", 'Int'>
    readonly text: FieldRef<"Testimonial", 'String'>
    readonly createdAt: FieldRef<"Testimonial", 'DateTime'>
    readonly updatedAt: FieldRef<"Testimonial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Testimonial findUnique
   */
  export type TestimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findUniqueOrThrow
   */
  export type TestimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findFirst
   */
  export type TestimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findFirstOrThrow
   */
  export type TestimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findMany
   */
  export type TestimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonials to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial create
   */
  export type TestimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * The data needed to create a Testimonial.
     */
    data: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
  }

  /**
   * Testimonial createMany
   */
  export type TestimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Testimonial createManyAndReturn
   */
  export type TestimonialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Testimonial update
   */
  export type TestimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * The data needed to update a Testimonial.
     */
    data: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
    /**
     * Choose, which Testimonial to update.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial updateMany
   */
  export type TestimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Testimonials.
     */
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyInput>
    /**
     * Filter which Testimonials to update
     */
    where?: TestimonialWhereInput
    /**
     * Limit how many Testimonials to update.
     */
    limit?: number
  }

  /**
   * Testimonial updateManyAndReturn
   */
  export type TestimonialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * The data used to update Testimonials.
     */
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyInput>
    /**
     * Filter which Testimonials to update
     */
    where?: TestimonialWhereInput
    /**
     * Limit how many Testimonials to update.
     */
    limit?: number
  }

  /**
   * Testimonial upsert
   */
  export type TestimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * The filter to search for the Testimonial to update in case it exists.
     */
    where: TestimonialWhereUniqueInput
    /**
     * In case the Testimonial found by the `where` argument doesn't exist, create a new Testimonial with this data.
     */
    create: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
    /**
     * In case the Testimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
  }

  /**
   * Testimonial delete
   */
  export type TestimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter which Testimonial to delete.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial deleteMany
   */
  export type TestimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonials to delete
     */
    where?: TestimonialWhereInput
    /**
     * Limit how many Testimonials to delete.
     */
    limit?: number
  }

  /**
   * Testimonial without action
   */
  export type TestimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
  }


  /**
   * Model NewsletterSubscription
   */

  export type AggregateNewsletterSubscription = {
    _count: NewsletterSubscriptionCountAggregateOutputType | null
    _min: NewsletterSubscriptionMinAggregateOutputType | null
    _max: NewsletterSubscriptionMaxAggregateOutputType | null
  }

  export type NewsletterSubscriptionMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    confirmed: boolean | null
  }

  export type NewsletterSubscriptionMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    confirmed: boolean | null
  }

  export type NewsletterSubscriptionCountAggregateOutputType = {
    id: number
    email: number
    name: number
    createdAt: number
    updatedAt: number
    confirmed: number
    _all: number
  }


  export type NewsletterSubscriptionMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    confirmed?: true
  }

  export type NewsletterSubscriptionMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    confirmed?: true
  }

  export type NewsletterSubscriptionCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    confirmed?: true
    _all?: true
  }

  export type NewsletterSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsletterSubscription to aggregate.
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscriptions to fetch.
     */
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsletterSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsletterSubscriptions
    **/
    _count?: true | NewsletterSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsletterSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsletterSubscriptionMaxAggregateInputType
  }

  export type GetNewsletterSubscriptionAggregateType<T extends NewsletterSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletterSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletterSubscription[P]>
      : GetScalarType<T[P], AggregateNewsletterSubscription[P]>
  }




  export type NewsletterSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsletterSubscriptionWhereInput
    orderBy?: NewsletterSubscriptionOrderByWithAggregationInput | NewsletterSubscriptionOrderByWithAggregationInput[]
    by: NewsletterSubscriptionScalarFieldEnum[] | NewsletterSubscriptionScalarFieldEnum
    having?: NewsletterSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsletterSubscriptionCountAggregateInputType | true
    _min?: NewsletterSubscriptionMinAggregateInputType
    _max?: NewsletterSubscriptionMaxAggregateInputType
  }

  export type NewsletterSubscriptionGroupByOutputType = {
    id: string
    email: string
    name: string | null
    createdAt: Date
    updatedAt: Date
    confirmed: boolean
    _count: NewsletterSubscriptionCountAggregateOutputType | null
    _min: NewsletterSubscriptionMinAggregateOutputType | null
    _max: NewsletterSubscriptionMaxAggregateOutputType | null
  }

  type GetNewsletterSubscriptionGroupByPayload<T extends NewsletterSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsletterSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsletterSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsletterSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], NewsletterSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type NewsletterSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    confirmed?: boolean
  }, ExtArgs["result"]["newsletterSubscription"]>

  export type NewsletterSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    confirmed?: boolean
  }, ExtArgs["result"]["newsletterSubscription"]>

  export type NewsletterSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    confirmed?: boolean
  }, ExtArgs["result"]["newsletterSubscription"]>

  export type NewsletterSubscriptionSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    confirmed?: boolean
  }

  export type NewsletterSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "createdAt" | "updatedAt" | "confirmed", ExtArgs["result"]["newsletterSubscription"]>

  export type $NewsletterSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsletterSubscription"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      createdAt: Date
      updatedAt: Date
      confirmed: boolean
    }, ExtArgs["result"]["newsletterSubscription"]>
    composites: {}
  }

  type NewsletterSubscriptionGetPayload<S extends boolean | null | undefined | NewsletterSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$NewsletterSubscriptionPayload, S>

  type NewsletterSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsletterSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsletterSubscriptionCountAggregateInputType | true
    }

  export interface NewsletterSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsletterSubscription'], meta: { name: 'NewsletterSubscription' } }
    /**
     * Find zero or one NewsletterSubscription that matches the filter.
     * @param {NewsletterSubscriptionFindUniqueArgs} args - Arguments to find a NewsletterSubscription
     * @example
     * // Get one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsletterSubscriptionFindUniqueArgs>(args: SelectSubset<T, NewsletterSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NewsletterSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsletterSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a NewsletterSubscription
     * @example
     * // Get one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsletterSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsletterSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsletterSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionFindFirstArgs} args - Arguments to find a NewsletterSubscription
     * @example
     * // Get one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsletterSubscriptionFindFirstArgs>(args?: SelectSubset<T, NewsletterSubscriptionFindFirstArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewsletterSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionFindFirstOrThrowArgs} args - Arguments to find a NewsletterSubscription
     * @example
     * // Get one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsletterSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsletterSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NewsletterSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsletterSubscriptions
     * const newsletterSubscriptions = await prisma.newsletterSubscription.findMany()
     * 
     * // Get first 10 NewsletterSubscriptions
     * const newsletterSubscriptions = await prisma.newsletterSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsletterSubscriptionWithIdOnly = await prisma.newsletterSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsletterSubscriptionFindManyArgs>(args?: SelectSubset<T, NewsletterSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NewsletterSubscription.
     * @param {NewsletterSubscriptionCreateArgs} args - Arguments to create a NewsletterSubscription.
     * @example
     * // Create one NewsletterSubscription
     * const NewsletterSubscription = await prisma.newsletterSubscription.create({
     *   data: {
     *     // ... data to create a NewsletterSubscription
     *   }
     * })
     * 
     */
    create<T extends NewsletterSubscriptionCreateArgs>(args: SelectSubset<T, NewsletterSubscriptionCreateArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NewsletterSubscriptions.
     * @param {NewsletterSubscriptionCreateManyArgs} args - Arguments to create many NewsletterSubscriptions.
     * @example
     * // Create many NewsletterSubscriptions
     * const newsletterSubscription = await prisma.newsletterSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsletterSubscriptionCreateManyArgs>(args?: SelectSubset<T, NewsletterSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsletterSubscriptions and returns the data saved in the database.
     * @param {NewsletterSubscriptionCreateManyAndReturnArgs} args - Arguments to create many NewsletterSubscriptions.
     * @example
     * // Create many NewsletterSubscriptions
     * const newsletterSubscription = await prisma.newsletterSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsletterSubscriptions and only return the `id`
     * const newsletterSubscriptionWithIdOnly = await prisma.newsletterSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsletterSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsletterSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NewsletterSubscription.
     * @param {NewsletterSubscriptionDeleteArgs} args - Arguments to delete one NewsletterSubscription.
     * @example
     * // Delete one NewsletterSubscription
     * const NewsletterSubscription = await prisma.newsletterSubscription.delete({
     *   where: {
     *     // ... filter to delete one NewsletterSubscription
     *   }
     * })
     * 
     */
    delete<T extends NewsletterSubscriptionDeleteArgs>(args: SelectSubset<T, NewsletterSubscriptionDeleteArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NewsletterSubscription.
     * @param {NewsletterSubscriptionUpdateArgs} args - Arguments to update one NewsletterSubscription.
     * @example
     * // Update one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsletterSubscriptionUpdateArgs>(args: SelectSubset<T, NewsletterSubscriptionUpdateArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NewsletterSubscriptions.
     * @param {NewsletterSubscriptionDeleteManyArgs} args - Arguments to filter NewsletterSubscriptions to delete.
     * @example
     * // Delete a few NewsletterSubscriptions
     * const { count } = await prisma.newsletterSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsletterSubscriptionDeleteManyArgs>(args?: SelectSubset<T, NewsletterSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsletterSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsletterSubscriptions
     * const newsletterSubscription = await prisma.newsletterSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsletterSubscriptionUpdateManyArgs>(args: SelectSubset<T, NewsletterSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsletterSubscriptions and returns the data updated in the database.
     * @param {NewsletterSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many NewsletterSubscriptions.
     * @example
     * // Update many NewsletterSubscriptions
     * const newsletterSubscription = await prisma.newsletterSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NewsletterSubscriptions and only return the `id`
     * const newsletterSubscriptionWithIdOnly = await prisma.newsletterSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsletterSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsletterSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NewsletterSubscription.
     * @param {NewsletterSubscriptionUpsertArgs} args - Arguments to update or create a NewsletterSubscription.
     * @example
     * // Update or create a NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.upsert({
     *   create: {
     *     // ... data to create a NewsletterSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsletterSubscription we want to update
     *   }
     * })
     */
    upsert<T extends NewsletterSubscriptionUpsertArgs>(args: SelectSubset<T, NewsletterSubscriptionUpsertArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NewsletterSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionCountArgs} args - Arguments to filter NewsletterSubscriptions to count.
     * @example
     * // Count the number of NewsletterSubscriptions
     * const count = await prisma.newsletterSubscription.count({
     *   where: {
     *     // ... the filter for the NewsletterSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends NewsletterSubscriptionCountArgs>(
      args?: Subset<T, NewsletterSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsletterSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsletterSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsletterSubscriptionAggregateArgs>(args: Subset<T, NewsletterSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetNewsletterSubscriptionAggregateType<T>>

    /**
     * Group by NewsletterSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsletterSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsletterSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: NewsletterSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsletterSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletterSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsletterSubscription model
   */
  readonly fields: NewsletterSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsletterSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsletterSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsletterSubscription model
   */
  interface NewsletterSubscriptionFieldRefs {
    readonly id: FieldRef<"NewsletterSubscription", 'String'>
    readonly email: FieldRef<"NewsletterSubscription", 'String'>
    readonly name: FieldRef<"NewsletterSubscription", 'String'>
    readonly createdAt: FieldRef<"NewsletterSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"NewsletterSubscription", 'DateTime'>
    readonly confirmed: FieldRef<"NewsletterSubscription", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * NewsletterSubscription findUnique
   */
  export type NewsletterSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscription to fetch.
     */
    where: NewsletterSubscriptionWhereUniqueInput
  }

  /**
   * NewsletterSubscription findUniqueOrThrow
   */
  export type NewsletterSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscription to fetch.
     */
    where: NewsletterSubscriptionWhereUniqueInput
  }

  /**
   * NewsletterSubscription findFirst
   */
  export type NewsletterSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscription to fetch.
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscriptions to fetch.
     */
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsletterSubscriptions.
     */
    cursor?: NewsletterSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsletterSubscriptions.
     */
    distinct?: NewsletterSubscriptionScalarFieldEnum | NewsletterSubscriptionScalarFieldEnum[]
  }

  /**
   * NewsletterSubscription findFirstOrThrow
   */
  export type NewsletterSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscription to fetch.
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscriptions to fetch.
     */
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsletterSubscriptions.
     */
    cursor?: NewsletterSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsletterSubscriptions.
     */
    distinct?: NewsletterSubscriptionScalarFieldEnum | NewsletterSubscriptionScalarFieldEnum[]
  }

  /**
   * NewsletterSubscription findMany
   */
  export type NewsletterSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscriptions to fetch.
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscriptions to fetch.
     */
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsletterSubscriptions.
     */
    cursor?: NewsletterSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscriptions.
     */
    skip?: number
    distinct?: NewsletterSubscriptionScalarFieldEnum | NewsletterSubscriptionScalarFieldEnum[]
  }

  /**
   * NewsletterSubscription create
   */
  export type NewsletterSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * The data needed to create a NewsletterSubscription.
     */
    data: XOR<NewsletterSubscriptionCreateInput, NewsletterSubscriptionUncheckedCreateInput>
  }

  /**
   * NewsletterSubscription createMany
   */
  export type NewsletterSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsletterSubscriptions.
     */
    data: NewsletterSubscriptionCreateManyInput | NewsletterSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsletterSubscription createManyAndReturn
   */
  export type NewsletterSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many NewsletterSubscriptions.
     */
    data: NewsletterSubscriptionCreateManyInput | NewsletterSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsletterSubscription update
   */
  export type NewsletterSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * The data needed to update a NewsletterSubscription.
     */
    data: XOR<NewsletterSubscriptionUpdateInput, NewsletterSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which NewsletterSubscription to update.
     */
    where: NewsletterSubscriptionWhereUniqueInput
  }

  /**
   * NewsletterSubscription updateMany
   */
  export type NewsletterSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsletterSubscriptions.
     */
    data: XOR<NewsletterSubscriptionUpdateManyMutationInput, NewsletterSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which NewsletterSubscriptions to update
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * Limit how many NewsletterSubscriptions to update.
     */
    limit?: number
  }

  /**
   * NewsletterSubscription updateManyAndReturn
   */
  export type NewsletterSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update NewsletterSubscriptions.
     */
    data: XOR<NewsletterSubscriptionUpdateManyMutationInput, NewsletterSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which NewsletterSubscriptions to update
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * Limit how many NewsletterSubscriptions to update.
     */
    limit?: number
  }

  /**
   * NewsletterSubscription upsert
   */
  export type NewsletterSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * The filter to search for the NewsletterSubscription to update in case it exists.
     */
    where: NewsletterSubscriptionWhereUniqueInput
    /**
     * In case the NewsletterSubscription found by the `where` argument doesn't exist, create a new NewsletterSubscription with this data.
     */
    create: XOR<NewsletterSubscriptionCreateInput, NewsletterSubscriptionUncheckedCreateInput>
    /**
     * In case the NewsletterSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsletterSubscriptionUpdateInput, NewsletterSubscriptionUncheckedUpdateInput>
  }

  /**
   * NewsletterSubscription delete
   */
  export type NewsletterSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
    /**
     * Filter which NewsletterSubscription to delete.
     */
    where: NewsletterSubscriptionWhereUniqueInput
  }

  /**
   * NewsletterSubscription deleteMany
   */
  export type NewsletterSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsletterSubscriptions to delete
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * Limit how many NewsletterSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * NewsletterSubscription without action
   */
  export type NewsletterSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewsletterSubscription
     */
    omit?: NewsletterSubscriptionOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    stripeCustomerId: 'stripeCustomerId',
    role: 'role',
    banned: 'banned',
    banReason: 'banReason',
    banExpires: 'banExpires',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId',
    impersonatedBy: 'impersonatedBy'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const DomainScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    desc: 'desc',
    color: 'color',
    iconName: 'iconName',
    iconLib: 'iconLib',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type DomainScalarFieldEnum = (typeof DomainScalarFieldEnum)[keyof typeof DomainScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    desc: 'desc',
    color: 'color',
    iconName: 'iconName',
    iconLib: 'iconLib',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    domainId: 'domainId',
    deletedAt: 'deletedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const LearningPathScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    smallDescription: 'smallDescription',
    fileKey: 'fileKey',
    price: 'price',
    currency: 'currency',
    duration: 'duration',
    slug: 'slug',
    status: 'status',
    level: 'level',
    stripePriceId: 'stripePriceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    deletedAt: 'deletedAt'
  };

  export type LearningPathScalarFieldEnum = (typeof LearningPathScalarFieldEnum)[keyof typeof LearningPathScalarFieldEnum]


  export const LearningPathItemScalarFieldEnum: {
    id: 'id',
    type: 'type',
    position: 'position',
    learningPathId: 'learningPathId',
    courseId: 'courseId',
    workshopId: 'workshopId',
    resourceId: 'resourceId'
  };

  export type LearningPathItemScalarFieldEnum = (typeof LearningPathItemScalarFieldEnum)[keyof typeof LearningPathItemScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    smallDescription: 'smallDescription',
    description: 'description',
    fileKey: 'fileKey',
    price: 'price',
    currency: 'currency',
    duration: 'duration',
    status: 'status',
    level: 'level',
    stripePriceId: 'stripePriceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    categoryId: 'categoryId',
    deletedAt: 'deletedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const ChapterScalarFieldEnum: {
    id: 'id',
    title: 'title',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    courseId: 'courseId'
  };

  export type ChapterScalarFieldEnum = (typeof ChapterScalarFieldEnum)[keyof typeof ChapterScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    thumbnailKey: 'thumbnailKey',
    videoKey: 'videoKey',
    position: 'position',
    duration: 'duration',
    public: 'public',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    chapterId: 'chapterId'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const WorkshopScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    slug: 'slug',
    statement: 'statement',
    fileKey: 'fileKey',
    statementsStartFileKey: 'statementsStartFileKey',
    statementsStartFileUrl: 'statementsStartFileUrl',
    statementVideoKey: 'statementVideoKey',
    price: 'price',
    currency: 'currency',
    duration: 'duration',
    status: 'status',
    level: 'level',
    stripePriceId: 'stripePriceId',
    solution: 'solution',
    solutionFileKey: 'solutionFileKey',
    solutionFileUrl: 'solutionFileUrl',
    solutionVideoKey: 'solutionVideoKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    deletedAt: 'deletedAt'
  };

  export type WorkshopScalarFieldEnum = (typeof WorkshopScalarFieldEnum)[keyof typeof WorkshopScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    fileKey: 'fileKey',
    url: 'url',
    type: 'type',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const LearningPathResourceScalarFieldEnum: {
    learningPathId: 'learningPathId',
    resourceId: 'resourceId'
  };

  export type LearningPathResourceScalarFieldEnum = (typeof LearningPathResourceScalarFieldEnum)[keyof typeof LearningPathResourceScalarFieldEnum]


  export const CourseResourceScalarFieldEnum: {
    courseId: 'courseId',
    resourceId: 'resourceId'
  };

  export type CourseResourceScalarFieldEnum = (typeof CourseResourceScalarFieldEnum)[keyof typeof CourseResourceScalarFieldEnum]


  export const LessonResourceScalarFieldEnum: {
    lessonId: 'lessonId',
    resourceId: 'resourceId'
  };

  export type LessonResourceScalarFieldEnum = (typeof LessonResourceScalarFieldEnum)[keyof typeof LessonResourceScalarFieldEnum]


  export const WorkshopResourceScalarFieldEnum: {
    workshopId: 'workshopId',
    resourceId: 'resourceId'
  };

  export type WorkshopResourceScalarFieldEnum = (typeof WorkshopResourceScalarFieldEnum)[keyof typeof WorkshopResourceScalarFieldEnum]


  export const LessonProgressScalarFieldEnum: {
    id: 'id',
    completed: 'completed',
    startTime: 'startTime',
    endTime: 'endTime',
    watchedSeconds: 'watchedSeconds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    lessonId: 'lessonId'
  };

  export type LessonProgressScalarFieldEnum = (typeof LessonProgressScalarFieldEnum)[keyof typeof LessonProgressScalarFieldEnum]


  export const UserProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    itemId: 'itemId',
    completed: 'completed',
    updatedAt: 'updatedAt',
    progressPercentage: 'progressPercentage',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    timeSpent: 'timeSpent'
  };

  export type UserProgressScalarFieldEnum = (typeof UserProgressScalarFieldEnum)[keyof typeof UserProgressScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const CourseTagScalarFieldEnum: {
    courseId: 'courseId',
    tagId: 'tagId'
  };

  export type CourseTagScalarFieldEnum = (typeof CourseTagScalarFieldEnum)[keyof typeof CourseTagScalarFieldEnum]


  export const WorkshopTagScalarFieldEnum: {
    workshopId: 'workshopId',
    tagId: 'tagId'
  };

  export type WorkshopTagScalarFieldEnum = (typeof WorkshopTagScalarFieldEnum)[keyof typeof WorkshopTagScalarFieldEnum]


  export const LearningPathTagScalarFieldEnum: {
    learningPathId: 'learningPathId',
    tagId: 'tagId'
  };

  export type LearningPathTagScalarFieldEnum = (typeof LearningPathTagScalarFieldEnum)[keyof typeof LearningPathTagScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    discount: 'discount',
    type: 'type',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    active: 'active',
    itemType: 'itemType',
    courseId: 'courseId',
    workshopId: 'workshopId',
    learningPathId: 'learningPathId'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const PromoCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    discount: 'discount',
    type: 'type',
    usageLimit: 'usageLimit',
    usedCount: 'usedCount',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    active: 'active'
  };

  export type PromoCodeScalarFieldEnum = (typeof PromoCodeScalarFieldEnum)[keyof typeof PromoCodeScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    courseId: 'courseId',
    learningPathId: 'learningPathId',
    workshopId: 'workshopId',
    userId: 'userId',
    paymentId: 'paymentId',
    deletedAt: 'deletedAt'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    stripeId: 'stripeId',
    userId: 'userId',
    courseId: 'courseId',
    learningPathId: 'learningPathId',
    workshopId: 'workshopId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    method: 'method',
    receiptUrl: 'receiptUrl',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    number: 'number',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    pdfUrl: 'pdfUrl',
    date: 'date',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    title: 'title',
    type: 'type',
    referenceId: 'referenceId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    total: 'total'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const ObjectiveScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type ObjectiveScalarFieldEnum = (typeof ObjectiveScalarFieldEnum)[keyof typeof ObjectiveScalarFieldEnum]


  export const PrerequisiteScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type PrerequisiteScalarFieldEnum = (typeof PrerequisiteScalarFieldEnum)[keyof typeof PrerequisiteScalarFieldEnum]


  export const CourseObjectiveScalarFieldEnum: {
    courseId: 'courseId',
    objectiveId: 'objectiveId'
  };

  export type CourseObjectiveScalarFieldEnum = (typeof CourseObjectiveScalarFieldEnum)[keyof typeof CourseObjectiveScalarFieldEnum]


  export const CoursePrerequisiteScalarFieldEnum: {
    courseId: 'courseId',
    prerequisiteId: 'prerequisiteId'
  };

  export type CoursePrerequisiteScalarFieldEnum = (typeof CoursePrerequisiteScalarFieldEnum)[keyof typeof CoursePrerequisiteScalarFieldEnum]


  export const WorkshopObjectiveScalarFieldEnum: {
    workshopId: 'workshopId',
    objectiveId: 'objectiveId'
  };

  export type WorkshopObjectiveScalarFieldEnum = (typeof WorkshopObjectiveScalarFieldEnum)[keyof typeof WorkshopObjectiveScalarFieldEnum]


  export const WorkshopPrerequisiteScalarFieldEnum: {
    workshopId: 'workshopId',
    prerequisiteId: 'prerequisiteId'
  };

  export type WorkshopPrerequisiteScalarFieldEnum = (typeof WorkshopPrerequisiteScalarFieldEnum)[keyof typeof WorkshopPrerequisiteScalarFieldEnum]


  export const LearningPathObjectiveScalarFieldEnum: {
    learningPathId: 'learningPathId',
    objectiveId: 'objectiveId'
  };

  export type LearningPathObjectiveScalarFieldEnum = (typeof LearningPathObjectiveScalarFieldEnum)[keyof typeof LearningPathObjectiveScalarFieldEnum]


  export const LearningPathPrerequisiteScalarFieldEnum: {
    learningPathId: 'learningPathId',
    prerequisiteId: 'prerequisiteId'
  };

  export type LearningPathPrerequisiteScalarFieldEnum = (typeof LearningPathPrerequisiteScalarFieldEnum)[keyof typeof LearningPathPrerequisiteScalarFieldEnum]


  export const FeatureScalarFieldEnum: {
    id: 'id',
    title: 'title',
    desc: 'desc',
    color: 'color',
    iconName: 'iconName',
    iconLib: 'iconLib',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeatureScalarFieldEnum = (typeof FeatureScalarFieldEnum)[keyof typeof FeatureScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    postalCode: 'postalCode',
    city: 'city',
    country: 'country',
    email: 'email',
    phone: 'phone',
    siret: 'siret',
    vatNumber: 'vatNumber',
    logoUrl: 'logoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const SocialLinkScalarFieldEnum: {
    id: 'id',
    name: 'name',
    iconLib: 'iconLib',
    iconName: 'iconName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialLinkScalarFieldEnum = (typeof SocialLinkScalarFieldEnum)[keyof typeof SocialLinkScalarFieldEnum]


  export const CompanySocialLinkScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    socialLinkId: 'socialLinkId',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanySocialLinkScalarFieldEnum = (typeof CompanySocialLinkScalarFieldEnum)[keyof typeof CompanySocialLinkScalarFieldEnum]


  export const PageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    type: 'type',
    chapterId: 'chapterId',
    courseId: 'courseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const QuizQuestionScalarFieldEnum: {
    id: 'id',
    question: 'question',
    type: 'type',
    quizId: 'quizId'
  };

  export type QuizQuestionScalarFieldEnum = (typeof QuizQuestionScalarFieldEnum)[keyof typeof QuizQuestionScalarFieldEnum]


  export const QuizOptionScalarFieldEnum: {
    id: 'id',
    content: 'content',
    isCorrect: 'isCorrect',
    questionId: 'questionId'
  };

  export type QuizOptionScalarFieldEnum = (typeof QuizOptionScalarFieldEnum)[keyof typeof QuizOptionScalarFieldEnum]


  export const QuizResultScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    quizId: 'quizId',
    score: 'score',
    passed: 'passed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizResultScalarFieldEnum = (typeof QuizResultScalarFieldEnum)[keyof typeof QuizResultScalarFieldEnum]


  export const TestimonialScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    rating: 'rating',
    text: 'text',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestimonialScalarFieldEnum = (typeof TestimonialScalarFieldEnum)[keyof typeof TestimonialScalarFieldEnum]


  export const NewsletterSubscriptionScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    confirmed: 'confirmed'
  };

  export type NewsletterSubscriptionScalarFieldEnum = (typeof NewsletterSubscriptionScalarFieldEnum)[keyof typeof NewsletterSubscriptionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'enrollmentStatus'
   */
  export type EnumenrollmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enrollmentStatus'>
    


  /**
   * Reference to a field of type 'enrollmentStatus[]'
   */
  export type ListEnumenrollmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enrollmentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    role?: StringNullableFilter<"User"> | string | null
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    lessonProgress?: LessonProgressListRelationFilter
    enrollment?: EnrollmentListRelationFilter
    payments?: PaymentListRelationFilter
    invoices?: InvoiceListRelationFilter
    courses?: CourseListRelationFilter
    learningPaths?: LearningPathListRelationFilter
    workshops?: WorkshopListRelationFilter
    resources?: ResourceListRelationFilter
    quiz?: QuizListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    lessonProgress?: LessonProgressOrderByRelationAggregateInput
    enrollment?: EnrollmentOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    courses?: CourseOrderByRelationAggregateInput
    learningPaths?: LearningPathOrderByRelationAggregateInput
    workshops?: WorkshopOrderByRelationAggregateInput
    resources?: ResourceOrderByRelationAggregateInput
    quiz?: QuizOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    stripeCustomerId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: StringNullableFilter<"User"> | string | null
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    lessonProgress?: LessonProgressListRelationFilter
    enrollment?: EnrollmentListRelationFilter
    payments?: PaymentListRelationFilter
    invoices?: InvoiceListRelationFilter
    courses?: CourseListRelationFilter
    learningPaths?: LearningPathListRelationFilter
    workshops?: WorkshopListRelationFilter
    resources?: ResourceListRelationFilter
    quiz?: QuizListRelationFilter
  }, "id" | "stripeCustomerId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringNullableWithAggregatesFilter<"User"> | string | null
    banned?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    banReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    banExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
    impersonatedBy?: StringNullableWithAggregatesFilter<"Session"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
  }

  export type DomainWhereInput = {
    AND?: DomainWhereInput | DomainWhereInput[]
    OR?: DomainWhereInput[]
    NOT?: DomainWhereInput | DomainWhereInput[]
    id?: StringFilter<"Domain"> | string
    title?: StringFilter<"Domain"> | string
    slug?: StringFilter<"Domain"> | string
    desc?: StringFilter<"Domain"> | string
    color?: StringNullableFilter<"Domain"> | string | null
    iconName?: StringNullableFilter<"Domain"> | string | null
    iconLib?: StringNullableFilter<"Domain"> | string | null
    createdAt?: DateTimeFilter<"Domain"> | Date | string
    updatedAt?: DateTimeFilter<"Domain"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Domain"> | Date | string | null
    categories?: CategoryListRelationFilter
  }

  export type DomainOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    desc?: SortOrder
    color?: SortOrderInput | SortOrder
    iconName?: SortOrderInput | SortOrder
    iconLib?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    categories?: CategoryOrderByRelationAggregateInput
  }

  export type DomainWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: DomainWhereInput | DomainWhereInput[]
    OR?: DomainWhereInput[]
    NOT?: DomainWhereInput | DomainWhereInput[]
    title?: StringFilter<"Domain"> | string
    desc?: StringFilter<"Domain"> | string
    color?: StringNullableFilter<"Domain"> | string | null
    iconName?: StringNullableFilter<"Domain"> | string | null
    iconLib?: StringNullableFilter<"Domain"> | string | null
    createdAt?: DateTimeFilter<"Domain"> | Date | string
    updatedAt?: DateTimeFilter<"Domain"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Domain"> | Date | string | null
    categories?: CategoryListRelationFilter
  }, "id" | "slug">

  export type DomainOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    desc?: SortOrder
    color?: SortOrderInput | SortOrder
    iconName?: SortOrderInput | SortOrder
    iconLib?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: DomainCountOrderByAggregateInput
    _max?: DomainMaxOrderByAggregateInput
    _min?: DomainMinOrderByAggregateInput
  }

  export type DomainScalarWhereWithAggregatesInput = {
    AND?: DomainScalarWhereWithAggregatesInput | DomainScalarWhereWithAggregatesInput[]
    OR?: DomainScalarWhereWithAggregatesInput[]
    NOT?: DomainScalarWhereWithAggregatesInput | DomainScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Domain"> | string
    title?: StringWithAggregatesFilter<"Domain"> | string
    slug?: StringWithAggregatesFilter<"Domain"> | string
    desc?: StringWithAggregatesFilter<"Domain"> | string
    color?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    iconName?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    iconLib?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Domain"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Domain"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Domain"> | Date | string | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    title?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    desc?: StringFilter<"Category"> | string
    color?: StringNullableFilter<"Category"> | string | null
    iconName?: StringNullableFilter<"Category"> | string | null
    iconLib?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    domainId?: StringFilter<"Category"> | string
    deletedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    courses?: CourseListRelationFilter
    domain?: XOR<DomainScalarRelationFilter, DomainWhereInput>
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    desc?: SortOrder
    color?: SortOrderInput | SortOrder
    iconName?: SortOrderInput | SortOrder
    iconLib?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domainId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    courses?: CourseOrderByRelationAggregateInput
    domain?: DomainOrderByWithRelationInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    title?: StringFilter<"Category"> | string
    desc?: StringFilter<"Category"> | string
    color?: StringNullableFilter<"Category"> | string | null
    iconName?: StringNullableFilter<"Category"> | string | null
    iconLib?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    domainId?: StringFilter<"Category"> | string
    deletedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    courses?: CourseListRelationFilter
    domain?: XOR<DomainScalarRelationFilter, DomainWhereInput>
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    desc?: SortOrder
    color?: SortOrderInput | SortOrder
    iconName?: SortOrderInput | SortOrder
    iconLib?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domainId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    title?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    desc?: StringWithAggregatesFilter<"Category"> | string
    color?: StringNullableWithAggregatesFilter<"Category"> | string | null
    iconName?: StringNullableWithAggregatesFilter<"Category"> | string | null
    iconLib?: StringNullableWithAggregatesFilter<"Category"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    domainId?: StringWithAggregatesFilter<"Category"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
  }

  export type LearningPathWhereInput = {
    AND?: LearningPathWhereInput | LearningPathWhereInput[]
    OR?: LearningPathWhereInput[]
    NOT?: LearningPathWhereInput | LearningPathWhereInput[]
    id?: StringFilter<"LearningPath"> | string
    title?: StringFilter<"LearningPath"> | string
    description?: StringFilter<"LearningPath"> | string
    smallDescription?: StringFilter<"LearningPath"> | string
    fileKey?: StringFilter<"LearningPath"> | string
    price?: IntFilter<"LearningPath"> | number
    currency?: StringFilter<"LearningPath"> | string
    duration?: IntFilter<"LearningPath"> | number
    slug?: StringFilter<"LearningPath"> | string
    status?: StringFilter<"LearningPath"> | string
    level?: StringFilter<"LearningPath"> | string
    stripePriceId?: StringFilter<"LearningPath"> | string
    createdAt?: DateTimeFilter<"LearningPath"> | Date | string
    updatedAt?: DateTimeFilter<"LearningPath"> | Date | string
    userId?: StringFilter<"LearningPath"> | string
    deletedAt?: DateTimeNullableFilter<"LearningPath"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tags?: LearningPathTagListRelationFilter
    contents?: LearningPathItemListRelationFilter
    progress?: UserProgressListRelationFilter
    resources?: LearningPathResourceListRelationFilter
    objectives?: LearningPathObjectiveListRelationFilter
    prerequisites?: LearningPathPrerequisiteListRelationFilter
    promoCodes?: PromoCodeListRelationFilter
    promotions?: PromotionListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type LearningPathOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    smallDescription?: SortOrder
    fileKey?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    tags?: LearningPathTagOrderByRelationAggregateInput
    contents?: LearningPathItemOrderByRelationAggregateInput
    progress?: UserProgressOrderByRelationAggregateInput
    resources?: LearningPathResourceOrderByRelationAggregateInput
    objectives?: LearningPathObjectiveOrderByRelationAggregateInput
    prerequisites?: LearningPathPrerequisiteOrderByRelationAggregateInput
    promoCodes?: PromoCodeOrderByRelationAggregateInput
    promotions?: PromotionOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type LearningPathWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    stripePriceId?: string
    AND?: LearningPathWhereInput | LearningPathWhereInput[]
    OR?: LearningPathWhereInput[]
    NOT?: LearningPathWhereInput | LearningPathWhereInput[]
    title?: StringFilter<"LearningPath"> | string
    description?: StringFilter<"LearningPath"> | string
    smallDescription?: StringFilter<"LearningPath"> | string
    fileKey?: StringFilter<"LearningPath"> | string
    price?: IntFilter<"LearningPath"> | number
    currency?: StringFilter<"LearningPath"> | string
    duration?: IntFilter<"LearningPath"> | number
    status?: StringFilter<"LearningPath"> | string
    level?: StringFilter<"LearningPath"> | string
    createdAt?: DateTimeFilter<"LearningPath"> | Date | string
    updatedAt?: DateTimeFilter<"LearningPath"> | Date | string
    userId?: StringFilter<"LearningPath"> | string
    deletedAt?: DateTimeNullableFilter<"LearningPath"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tags?: LearningPathTagListRelationFilter
    contents?: LearningPathItemListRelationFilter
    progress?: UserProgressListRelationFilter
    resources?: LearningPathResourceListRelationFilter
    objectives?: LearningPathObjectiveListRelationFilter
    prerequisites?: LearningPathPrerequisiteListRelationFilter
    promoCodes?: PromoCodeListRelationFilter
    promotions?: PromotionListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "slug" | "stripePriceId">

  export type LearningPathOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    smallDescription?: SortOrder
    fileKey?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: LearningPathCountOrderByAggregateInput
    _avg?: LearningPathAvgOrderByAggregateInput
    _max?: LearningPathMaxOrderByAggregateInput
    _min?: LearningPathMinOrderByAggregateInput
    _sum?: LearningPathSumOrderByAggregateInput
  }

  export type LearningPathScalarWhereWithAggregatesInput = {
    AND?: LearningPathScalarWhereWithAggregatesInput | LearningPathScalarWhereWithAggregatesInput[]
    OR?: LearningPathScalarWhereWithAggregatesInput[]
    NOT?: LearningPathScalarWhereWithAggregatesInput | LearningPathScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningPath"> | string
    title?: StringWithAggregatesFilter<"LearningPath"> | string
    description?: StringWithAggregatesFilter<"LearningPath"> | string
    smallDescription?: StringWithAggregatesFilter<"LearningPath"> | string
    fileKey?: StringWithAggregatesFilter<"LearningPath"> | string
    price?: IntWithAggregatesFilter<"LearningPath"> | number
    currency?: StringWithAggregatesFilter<"LearningPath"> | string
    duration?: IntWithAggregatesFilter<"LearningPath"> | number
    slug?: StringWithAggregatesFilter<"LearningPath"> | string
    status?: StringWithAggregatesFilter<"LearningPath"> | string
    level?: StringWithAggregatesFilter<"LearningPath"> | string
    stripePriceId?: StringWithAggregatesFilter<"LearningPath"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LearningPath"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LearningPath"> | Date | string
    userId?: StringWithAggregatesFilter<"LearningPath"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"LearningPath"> | Date | string | null
  }

  export type LearningPathItemWhereInput = {
    AND?: LearningPathItemWhereInput | LearningPathItemWhereInput[]
    OR?: LearningPathItemWhereInput[]
    NOT?: LearningPathItemWhereInput | LearningPathItemWhereInput[]
    id?: StringFilter<"LearningPathItem"> | string
    type?: StringFilter<"LearningPathItem"> | string
    position?: IntFilter<"LearningPathItem"> | number
    learningPathId?: StringFilter<"LearningPathItem"> | string
    courseId?: StringNullableFilter<"LearningPathItem"> | string | null
    workshopId?: StringNullableFilter<"LearningPathItem"> | string | null
    resourceId?: StringNullableFilter<"LearningPathItem"> | string | null
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    workshop?: XOR<WorkshopNullableScalarRelationFilter, WorkshopWhereInput> | null
    resource?: XOR<ResourceNullableScalarRelationFilter, ResourceWhereInput> | null
  }

  export type LearningPathItemOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    position?: SortOrder
    learningPathId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    workshopId?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    learningPath?: LearningPathOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    workshop?: WorkshopOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type LearningPathItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningPathItemWhereInput | LearningPathItemWhereInput[]
    OR?: LearningPathItemWhereInput[]
    NOT?: LearningPathItemWhereInput | LearningPathItemWhereInput[]
    type?: StringFilter<"LearningPathItem"> | string
    position?: IntFilter<"LearningPathItem"> | number
    learningPathId?: StringFilter<"LearningPathItem"> | string
    courseId?: StringNullableFilter<"LearningPathItem"> | string | null
    workshopId?: StringNullableFilter<"LearningPathItem"> | string | null
    resourceId?: StringNullableFilter<"LearningPathItem"> | string | null
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    workshop?: XOR<WorkshopNullableScalarRelationFilter, WorkshopWhereInput> | null
    resource?: XOR<ResourceNullableScalarRelationFilter, ResourceWhereInput> | null
  }, "id">

  export type LearningPathItemOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    position?: SortOrder
    learningPathId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    workshopId?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    _count?: LearningPathItemCountOrderByAggregateInput
    _avg?: LearningPathItemAvgOrderByAggregateInput
    _max?: LearningPathItemMaxOrderByAggregateInput
    _min?: LearningPathItemMinOrderByAggregateInput
    _sum?: LearningPathItemSumOrderByAggregateInput
  }

  export type LearningPathItemScalarWhereWithAggregatesInput = {
    AND?: LearningPathItemScalarWhereWithAggregatesInput | LearningPathItemScalarWhereWithAggregatesInput[]
    OR?: LearningPathItemScalarWhereWithAggregatesInput[]
    NOT?: LearningPathItemScalarWhereWithAggregatesInput | LearningPathItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningPathItem"> | string
    type?: StringWithAggregatesFilter<"LearningPathItem"> | string
    position?: IntWithAggregatesFilter<"LearningPathItem"> | number
    learningPathId?: StringWithAggregatesFilter<"LearningPathItem"> | string
    courseId?: StringNullableWithAggregatesFilter<"LearningPathItem"> | string | null
    workshopId?: StringNullableWithAggregatesFilter<"LearningPathItem"> | string | null
    resourceId?: StringNullableWithAggregatesFilter<"LearningPathItem"> | string | null
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    slug?: StringFilter<"Course"> | string
    smallDescription?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    fileKey?: StringFilter<"Course"> | string
    price?: IntFilter<"Course"> | number
    currency?: StringFilter<"Course"> | string
    duration?: IntFilter<"Course"> | number
    status?: StringFilter<"Course"> | string
    level?: StringFilter<"Course"> | string
    stripePriceId?: StringFilter<"Course"> | string
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    userId?: StringFilter<"Course"> | string
    categoryId?: StringFilter<"Course"> | string
    deletedAt?: DateTimeNullableFilter<"Course"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    chapters?: ChapterListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    payments?: PaymentListRelationFilter
    promotions?: PromotionListRelationFilter
    promoCodes?: PromoCodeListRelationFilter
    tags?: CourseTagListRelationFilter
    progress?: UserProgressListRelationFilter
    resources?: CourseResourceListRelationFilter
    learningPathItems?: LearningPathItemListRelationFilter
    objectives?: CourseObjectiveListRelationFilter
    prerequisites?: CoursePrerequisiteListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    smallDescription?: SortOrder
    description?: SortOrder
    fileKey?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    chapters?: ChapterOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    promotions?: PromotionOrderByRelationAggregateInput
    promoCodes?: PromoCodeOrderByRelationAggregateInput
    tags?: CourseTagOrderByRelationAggregateInput
    progress?: UserProgressOrderByRelationAggregateInput
    resources?: CourseResourceOrderByRelationAggregateInput
    learningPathItems?: LearningPathItemOrderByRelationAggregateInput
    objectives?: CourseObjectiveOrderByRelationAggregateInput
    prerequisites?: CoursePrerequisiteOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    stripePriceId?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    smallDescription?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    fileKey?: StringFilter<"Course"> | string
    price?: IntFilter<"Course"> | number
    currency?: StringFilter<"Course"> | string
    duration?: IntFilter<"Course"> | number
    status?: StringFilter<"Course"> | string
    level?: StringFilter<"Course"> | string
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    userId?: StringFilter<"Course"> | string
    categoryId?: StringFilter<"Course"> | string
    deletedAt?: DateTimeNullableFilter<"Course"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    chapters?: ChapterListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    payments?: PaymentListRelationFilter
    promotions?: PromotionListRelationFilter
    promoCodes?: PromoCodeListRelationFilter
    tags?: CourseTagListRelationFilter
    progress?: UserProgressListRelationFilter
    resources?: CourseResourceListRelationFilter
    learningPathItems?: LearningPathItemListRelationFilter
    objectives?: CourseObjectiveListRelationFilter
    prerequisites?: CoursePrerequisiteListRelationFilter
  }, "id" | "slug" | "stripePriceId">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    smallDescription?: SortOrder
    description?: SortOrder
    fileKey?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    slug?: StringWithAggregatesFilter<"Course"> | string
    smallDescription?: StringWithAggregatesFilter<"Course"> | string
    description?: StringWithAggregatesFilter<"Course"> | string
    fileKey?: StringWithAggregatesFilter<"Course"> | string
    price?: IntWithAggregatesFilter<"Course"> | number
    currency?: StringWithAggregatesFilter<"Course"> | string
    duration?: IntWithAggregatesFilter<"Course"> | number
    status?: StringWithAggregatesFilter<"Course"> | string
    level?: StringWithAggregatesFilter<"Course"> | string
    stripePriceId?: StringWithAggregatesFilter<"Course"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    userId?: StringWithAggregatesFilter<"Course"> | string
    categoryId?: StringWithAggregatesFilter<"Course"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Course"> | Date | string | null
  }

  export type ChapterWhereInput = {
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    id?: StringFilter<"Chapter"> | string
    title?: StringFilter<"Chapter"> | string
    position?: IntFilter<"Chapter"> | number
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeFilter<"Chapter"> | Date | string
    courseId?: StringFilter<"Chapter"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    lessons?: LessonListRelationFilter
  }

  export type ChapterOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
    course?: CourseOrderByWithRelationInput
    lessons?: LessonOrderByRelationAggregateInput
  }

  export type ChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    title?: StringFilter<"Chapter"> | string
    position?: IntFilter<"Chapter"> | number
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeFilter<"Chapter"> | Date | string
    courseId?: StringFilter<"Chapter"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    lessons?: LessonListRelationFilter
  }, "id">

  export type ChapterOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
    _count?: ChapterCountOrderByAggregateInput
    _avg?: ChapterAvgOrderByAggregateInput
    _max?: ChapterMaxOrderByAggregateInput
    _min?: ChapterMinOrderByAggregateInput
    _sum?: ChapterSumOrderByAggregateInput
  }

  export type ChapterScalarWhereWithAggregatesInput = {
    AND?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    OR?: ChapterScalarWhereWithAggregatesInput[]
    NOT?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chapter"> | string
    title?: StringWithAggregatesFilter<"Chapter"> | string
    position?: IntWithAggregatesFilter<"Chapter"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
    courseId?: StringWithAggregatesFilter<"Chapter"> | string
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    description?: StringNullableFilter<"Lesson"> | string | null
    thumbnailKey?: StringNullableFilter<"Lesson"> | string | null
    videoKey?: StringNullableFilter<"Lesson"> | string | null
    position?: IntFilter<"Lesson"> | number
    duration?: IntFilter<"Lesson"> | number
    public?: BoolFilter<"Lesson"> | boolean
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    chapterId?: StringFilter<"Lesson"> | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
    lessonProgress?: LessonProgressListRelationFilter
    resources?: LessonResourceListRelationFilter
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnailKey?: SortOrderInput | SortOrder
    videoKey?: SortOrderInput | SortOrder
    position?: SortOrder
    duration?: SortOrder
    public?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chapterId?: SortOrder
    chapter?: ChapterOrderByWithRelationInput
    lessonProgress?: LessonProgressOrderByRelationAggregateInput
    resources?: LessonResourceOrderByRelationAggregateInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    title?: StringFilter<"Lesson"> | string
    description?: StringNullableFilter<"Lesson"> | string | null
    thumbnailKey?: StringNullableFilter<"Lesson"> | string | null
    videoKey?: StringNullableFilter<"Lesson"> | string | null
    position?: IntFilter<"Lesson"> | number
    duration?: IntFilter<"Lesson"> | number
    public?: BoolFilter<"Lesson"> | boolean
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    chapterId?: StringFilter<"Lesson"> | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
    lessonProgress?: LessonProgressListRelationFilter
    resources?: LessonResourceListRelationFilter
  }, "id">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnailKey?: SortOrderInput | SortOrder
    videoKey?: SortOrderInput | SortOrder
    position?: SortOrder
    duration?: SortOrder
    public?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chapterId?: SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lesson"> | string
    title?: StringWithAggregatesFilter<"Lesson"> | string
    description?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    thumbnailKey?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    videoKey?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    position?: IntWithAggregatesFilter<"Lesson"> | number
    duration?: IntWithAggregatesFilter<"Lesson"> | number
    public?: BoolWithAggregatesFilter<"Lesson"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    chapterId?: StringWithAggregatesFilter<"Lesson"> | string
  }

  export type WorkshopWhereInput = {
    AND?: WorkshopWhereInput | WorkshopWhereInput[]
    OR?: WorkshopWhereInput[]
    NOT?: WorkshopWhereInput | WorkshopWhereInput[]
    id?: StringFilter<"Workshop"> | string
    title?: StringFilter<"Workshop"> | string
    description?: StringFilter<"Workshop"> | string
    slug?: StringFilter<"Workshop"> | string
    statement?: StringFilter<"Workshop"> | string
    fileKey?: StringFilter<"Workshop"> | string
    statementsStartFileKey?: StringNullableFilter<"Workshop"> | string | null
    statementsStartFileUrl?: StringNullableFilter<"Workshop"> | string | null
    statementVideoKey?: StringNullableFilter<"Workshop"> | string | null
    price?: IntFilter<"Workshop"> | number
    currency?: StringFilter<"Workshop"> | string
    duration?: IntFilter<"Workshop"> | number
    status?: StringFilter<"Workshop"> | string
    level?: StringFilter<"Workshop"> | string
    stripePriceId?: StringNullableFilter<"Workshop"> | string | null
    solution?: StringNullableFilter<"Workshop"> | string | null
    solutionFileKey?: StringNullableFilter<"Workshop"> | string | null
    solutionFileUrl?: StringNullableFilter<"Workshop"> | string | null
    solutionVideoKey?: StringNullableFilter<"Workshop"> | string | null
    createdAt?: DateTimeFilter<"Workshop"> | Date | string
    updatedAt?: DateTimeFilter<"Workshop"> | Date | string
    userId?: StringFilter<"Workshop"> | string
    deletedAt?: DateTimeNullableFilter<"Workshop"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tags?: WorkshopTagListRelationFilter
    progress?: UserProgressListRelationFilter
    resources?: WorkshopResourceListRelationFilter
    learningPathItems?: LearningPathItemListRelationFilter
    objectives?: WorkshopObjectiveListRelationFilter
    prerequisites?: WorkshopPrerequisiteListRelationFilter
    promoCodes?: PromoCodeListRelationFilter
    promotions?: PromotionListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type WorkshopOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    statement?: SortOrder
    fileKey?: SortOrder
    statementsStartFileKey?: SortOrderInput | SortOrder
    statementsStartFileUrl?: SortOrderInput | SortOrder
    statementVideoKey?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    solution?: SortOrderInput | SortOrder
    solutionFileKey?: SortOrderInput | SortOrder
    solutionFileUrl?: SortOrderInput | SortOrder
    solutionVideoKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    tags?: WorkshopTagOrderByRelationAggregateInput
    progress?: UserProgressOrderByRelationAggregateInput
    resources?: WorkshopResourceOrderByRelationAggregateInput
    learningPathItems?: LearningPathItemOrderByRelationAggregateInput
    objectives?: WorkshopObjectiveOrderByRelationAggregateInput
    prerequisites?: WorkshopPrerequisiteOrderByRelationAggregateInput
    promoCodes?: PromoCodeOrderByRelationAggregateInput
    promotions?: PromotionOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type WorkshopWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    stripePriceId?: string
    AND?: WorkshopWhereInput | WorkshopWhereInput[]
    OR?: WorkshopWhereInput[]
    NOT?: WorkshopWhereInput | WorkshopWhereInput[]
    title?: StringFilter<"Workshop"> | string
    description?: StringFilter<"Workshop"> | string
    statement?: StringFilter<"Workshop"> | string
    fileKey?: StringFilter<"Workshop"> | string
    statementsStartFileKey?: StringNullableFilter<"Workshop"> | string | null
    statementsStartFileUrl?: StringNullableFilter<"Workshop"> | string | null
    statementVideoKey?: StringNullableFilter<"Workshop"> | string | null
    price?: IntFilter<"Workshop"> | number
    currency?: StringFilter<"Workshop"> | string
    duration?: IntFilter<"Workshop"> | number
    status?: StringFilter<"Workshop"> | string
    level?: StringFilter<"Workshop"> | string
    solution?: StringNullableFilter<"Workshop"> | string | null
    solutionFileKey?: StringNullableFilter<"Workshop"> | string | null
    solutionFileUrl?: StringNullableFilter<"Workshop"> | string | null
    solutionVideoKey?: StringNullableFilter<"Workshop"> | string | null
    createdAt?: DateTimeFilter<"Workshop"> | Date | string
    updatedAt?: DateTimeFilter<"Workshop"> | Date | string
    userId?: StringFilter<"Workshop"> | string
    deletedAt?: DateTimeNullableFilter<"Workshop"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tags?: WorkshopTagListRelationFilter
    progress?: UserProgressListRelationFilter
    resources?: WorkshopResourceListRelationFilter
    learningPathItems?: LearningPathItemListRelationFilter
    objectives?: WorkshopObjectiveListRelationFilter
    prerequisites?: WorkshopPrerequisiteListRelationFilter
    promoCodes?: PromoCodeListRelationFilter
    promotions?: PromotionListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "slug" | "stripePriceId">

  export type WorkshopOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    statement?: SortOrder
    fileKey?: SortOrder
    statementsStartFileKey?: SortOrderInput | SortOrder
    statementsStartFileUrl?: SortOrderInput | SortOrder
    statementVideoKey?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    solution?: SortOrderInput | SortOrder
    solutionFileKey?: SortOrderInput | SortOrder
    solutionFileUrl?: SortOrderInput | SortOrder
    solutionVideoKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: WorkshopCountOrderByAggregateInput
    _avg?: WorkshopAvgOrderByAggregateInput
    _max?: WorkshopMaxOrderByAggregateInput
    _min?: WorkshopMinOrderByAggregateInput
    _sum?: WorkshopSumOrderByAggregateInput
  }

  export type WorkshopScalarWhereWithAggregatesInput = {
    AND?: WorkshopScalarWhereWithAggregatesInput | WorkshopScalarWhereWithAggregatesInput[]
    OR?: WorkshopScalarWhereWithAggregatesInput[]
    NOT?: WorkshopScalarWhereWithAggregatesInput | WorkshopScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workshop"> | string
    title?: StringWithAggregatesFilter<"Workshop"> | string
    description?: StringWithAggregatesFilter<"Workshop"> | string
    slug?: StringWithAggregatesFilter<"Workshop"> | string
    statement?: StringWithAggregatesFilter<"Workshop"> | string
    fileKey?: StringWithAggregatesFilter<"Workshop"> | string
    statementsStartFileKey?: StringNullableWithAggregatesFilter<"Workshop"> | string | null
    statementsStartFileUrl?: StringNullableWithAggregatesFilter<"Workshop"> | string | null
    statementVideoKey?: StringNullableWithAggregatesFilter<"Workshop"> | string | null
    price?: IntWithAggregatesFilter<"Workshop"> | number
    currency?: StringWithAggregatesFilter<"Workshop"> | string
    duration?: IntWithAggregatesFilter<"Workshop"> | number
    status?: StringWithAggregatesFilter<"Workshop"> | string
    level?: StringWithAggregatesFilter<"Workshop"> | string
    stripePriceId?: StringNullableWithAggregatesFilter<"Workshop"> | string | null
    solution?: StringNullableWithAggregatesFilter<"Workshop"> | string | null
    solutionFileKey?: StringNullableWithAggregatesFilter<"Workshop"> | string | null
    solutionFileUrl?: StringNullableWithAggregatesFilter<"Workshop"> | string | null
    solutionVideoKey?: StringNullableWithAggregatesFilter<"Workshop"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Workshop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workshop"> | Date | string
    userId?: StringWithAggregatesFilter<"Workshop"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Workshop"> | Date | string | null
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: StringFilter<"Resource"> | string
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    fileKey?: StringNullableFilter<"Resource"> | string | null
    url?: StringFilter<"Resource"> | string
    type?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    userId?: StringFilter<"Resource"> | string
    courseResources?: CourseResourceListRelationFilter
    lessonResources?: LessonResourceListRelationFilter
    workshopResources?: WorkshopResourceListRelationFilter
    learningPathResources?: LearningPathResourceListRelationFilter
    learningPathItems?: LearningPathItemListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileKey?: SortOrderInput | SortOrder
    url?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    courseResources?: CourseResourceOrderByRelationAggregateInput
    lessonResources?: LessonResourceOrderByRelationAggregateInput
    workshopResources?: WorkshopResourceOrderByRelationAggregateInput
    learningPathResources?: LearningPathResourceOrderByRelationAggregateInput
    learningPathItems?: LearningPathItemOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    fileKey?: StringNullableFilter<"Resource"> | string | null
    url?: StringFilter<"Resource"> | string
    type?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    userId?: StringFilter<"Resource"> | string
    courseResources?: CourseResourceListRelationFilter
    lessonResources?: LessonResourceListRelationFilter
    workshopResources?: WorkshopResourceListRelationFilter
    learningPathResources?: LearningPathResourceListRelationFilter
    learningPathItems?: LearningPathItemListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileKey?: SortOrderInput | SortOrder
    url?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Resource"> | string
    title?: StringWithAggregatesFilter<"Resource"> | string
    description?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    fileKey?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    url?: StringWithAggregatesFilter<"Resource"> | string
    type?: StringWithAggregatesFilter<"Resource"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    userId?: StringWithAggregatesFilter<"Resource"> | string
  }

  export type LearningPathResourceWhereInput = {
    AND?: LearningPathResourceWhereInput | LearningPathResourceWhereInput[]
    OR?: LearningPathResourceWhereInput[]
    NOT?: LearningPathResourceWhereInput | LearningPathResourceWhereInput[]
    learningPathId?: StringFilter<"LearningPathResource"> | string
    resourceId?: StringFilter<"LearningPathResource"> | string
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }

  export type LearningPathResourceOrderByWithRelationInput = {
    learningPathId?: SortOrder
    resourceId?: SortOrder
    learningPath?: LearningPathOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type LearningPathResourceWhereUniqueInput = Prisma.AtLeast<{
    learningPathId_resourceId?: LearningPathResourceLearningPathIdResourceIdCompoundUniqueInput
    AND?: LearningPathResourceWhereInput | LearningPathResourceWhereInput[]
    OR?: LearningPathResourceWhereInput[]
    NOT?: LearningPathResourceWhereInput | LearningPathResourceWhereInput[]
    learningPathId?: StringFilter<"LearningPathResource"> | string
    resourceId?: StringFilter<"LearningPathResource"> | string
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }, "learningPathId_resourceId">

  export type LearningPathResourceOrderByWithAggregationInput = {
    learningPathId?: SortOrder
    resourceId?: SortOrder
    _count?: LearningPathResourceCountOrderByAggregateInput
    _max?: LearningPathResourceMaxOrderByAggregateInput
    _min?: LearningPathResourceMinOrderByAggregateInput
  }

  export type LearningPathResourceScalarWhereWithAggregatesInput = {
    AND?: LearningPathResourceScalarWhereWithAggregatesInput | LearningPathResourceScalarWhereWithAggregatesInput[]
    OR?: LearningPathResourceScalarWhereWithAggregatesInput[]
    NOT?: LearningPathResourceScalarWhereWithAggregatesInput | LearningPathResourceScalarWhereWithAggregatesInput[]
    learningPathId?: StringWithAggregatesFilter<"LearningPathResource"> | string
    resourceId?: StringWithAggregatesFilter<"LearningPathResource"> | string
  }

  export type CourseResourceWhereInput = {
    AND?: CourseResourceWhereInput | CourseResourceWhereInput[]
    OR?: CourseResourceWhereInput[]
    NOT?: CourseResourceWhereInput | CourseResourceWhereInput[]
    courseId?: StringFilter<"CourseResource"> | string
    resourceId?: StringFilter<"CourseResource"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }

  export type CourseResourceOrderByWithRelationInput = {
    courseId?: SortOrder
    resourceId?: SortOrder
    course?: CourseOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type CourseResourceWhereUniqueInput = Prisma.AtLeast<{
    courseId_resourceId?: CourseResourceCourseIdResourceIdCompoundUniqueInput
    AND?: CourseResourceWhereInput | CourseResourceWhereInput[]
    OR?: CourseResourceWhereInput[]
    NOT?: CourseResourceWhereInput | CourseResourceWhereInput[]
    courseId?: StringFilter<"CourseResource"> | string
    resourceId?: StringFilter<"CourseResource"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }, "courseId_resourceId">

  export type CourseResourceOrderByWithAggregationInput = {
    courseId?: SortOrder
    resourceId?: SortOrder
    _count?: CourseResourceCountOrderByAggregateInput
    _max?: CourseResourceMaxOrderByAggregateInput
    _min?: CourseResourceMinOrderByAggregateInput
  }

  export type CourseResourceScalarWhereWithAggregatesInput = {
    AND?: CourseResourceScalarWhereWithAggregatesInput | CourseResourceScalarWhereWithAggregatesInput[]
    OR?: CourseResourceScalarWhereWithAggregatesInput[]
    NOT?: CourseResourceScalarWhereWithAggregatesInput | CourseResourceScalarWhereWithAggregatesInput[]
    courseId?: StringWithAggregatesFilter<"CourseResource"> | string
    resourceId?: StringWithAggregatesFilter<"CourseResource"> | string
  }

  export type LessonResourceWhereInput = {
    AND?: LessonResourceWhereInput | LessonResourceWhereInput[]
    OR?: LessonResourceWhereInput[]
    NOT?: LessonResourceWhereInput | LessonResourceWhereInput[]
    lessonId?: StringFilter<"LessonResource"> | string
    resourceId?: StringFilter<"LessonResource"> | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }

  export type LessonResourceOrderByWithRelationInput = {
    lessonId?: SortOrder
    resourceId?: SortOrder
    lesson?: LessonOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type LessonResourceWhereUniqueInput = Prisma.AtLeast<{
    lessonId_resourceId?: LessonResourceLessonIdResourceIdCompoundUniqueInput
    AND?: LessonResourceWhereInput | LessonResourceWhereInput[]
    OR?: LessonResourceWhereInput[]
    NOT?: LessonResourceWhereInput | LessonResourceWhereInput[]
    lessonId?: StringFilter<"LessonResource"> | string
    resourceId?: StringFilter<"LessonResource"> | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }, "lessonId_resourceId">

  export type LessonResourceOrderByWithAggregationInput = {
    lessonId?: SortOrder
    resourceId?: SortOrder
    _count?: LessonResourceCountOrderByAggregateInput
    _max?: LessonResourceMaxOrderByAggregateInput
    _min?: LessonResourceMinOrderByAggregateInput
  }

  export type LessonResourceScalarWhereWithAggregatesInput = {
    AND?: LessonResourceScalarWhereWithAggregatesInput | LessonResourceScalarWhereWithAggregatesInput[]
    OR?: LessonResourceScalarWhereWithAggregatesInput[]
    NOT?: LessonResourceScalarWhereWithAggregatesInput | LessonResourceScalarWhereWithAggregatesInput[]
    lessonId?: StringWithAggregatesFilter<"LessonResource"> | string
    resourceId?: StringWithAggregatesFilter<"LessonResource"> | string
  }

  export type WorkshopResourceWhereInput = {
    AND?: WorkshopResourceWhereInput | WorkshopResourceWhereInput[]
    OR?: WorkshopResourceWhereInput[]
    NOT?: WorkshopResourceWhereInput | WorkshopResourceWhereInput[]
    workshopId?: StringFilter<"WorkshopResource"> | string
    resourceId?: StringFilter<"WorkshopResource"> | string
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }

  export type WorkshopResourceOrderByWithRelationInput = {
    workshopId?: SortOrder
    resourceId?: SortOrder
    workshop?: WorkshopOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type WorkshopResourceWhereUniqueInput = Prisma.AtLeast<{
    workshopId_resourceId?: WorkshopResourceWorkshopIdResourceIdCompoundUniqueInput
    AND?: WorkshopResourceWhereInput | WorkshopResourceWhereInput[]
    OR?: WorkshopResourceWhereInput[]
    NOT?: WorkshopResourceWhereInput | WorkshopResourceWhereInput[]
    workshopId?: StringFilter<"WorkshopResource"> | string
    resourceId?: StringFilter<"WorkshopResource"> | string
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }, "workshopId_resourceId">

  export type WorkshopResourceOrderByWithAggregationInput = {
    workshopId?: SortOrder
    resourceId?: SortOrder
    _count?: WorkshopResourceCountOrderByAggregateInput
    _max?: WorkshopResourceMaxOrderByAggregateInput
    _min?: WorkshopResourceMinOrderByAggregateInput
  }

  export type WorkshopResourceScalarWhereWithAggregatesInput = {
    AND?: WorkshopResourceScalarWhereWithAggregatesInput | WorkshopResourceScalarWhereWithAggregatesInput[]
    OR?: WorkshopResourceScalarWhereWithAggregatesInput[]
    NOT?: WorkshopResourceScalarWhereWithAggregatesInput | WorkshopResourceScalarWhereWithAggregatesInput[]
    workshopId?: StringWithAggregatesFilter<"WorkshopResource"> | string
    resourceId?: StringWithAggregatesFilter<"WorkshopResource"> | string
  }

  export type LessonProgressWhereInput = {
    AND?: LessonProgressWhereInput | LessonProgressWhereInput[]
    OR?: LessonProgressWhereInput[]
    NOT?: LessonProgressWhereInput | LessonProgressWhereInput[]
    id?: StringFilter<"LessonProgress"> | string
    completed?: BoolFilter<"LessonProgress"> | boolean
    startTime?: DateTimeNullableFilter<"LessonProgress"> | Date | string | null
    endTime?: DateTimeNullableFilter<"LessonProgress"> | Date | string | null
    watchedSeconds?: IntNullableFilter<"LessonProgress"> | number | null
    createdAt?: DateTimeFilter<"LessonProgress"> | Date | string
    updatedAt?: DateTimeFilter<"LessonProgress"> | Date | string
    userId?: StringFilter<"LessonProgress"> | string
    lessonId?: StringFilter<"LessonProgress"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }

  export type LessonProgressOrderByWithRelationInput = {
    id?: SortOrder
    completed?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    watchedSeconds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    user?: UserOrderByWithRelationInput
    Lesson?: LessonOrderByWithRelationInput
  }

  export type LessonProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_lessonId?: LessonProgressUserIdLessonIdCompoundUniqueInput
    AND?: LessonProgressWhereInput | LessonProgressWhereInput[]
    OR?: LessonProgressWhereInput[]
    NOT?: LessonProgressWhereInput | LessonProgressWhereInput[]
    completed?: BoolFilter<"LessonProgress"> | boolean
    startTime?: DateTimeNullableFilter<"LessonProgress"> | Date | string | null
    endTime?: DateTimeNullableFilter<"LessonProgress"> | Date | string | null
    watchedSeconds?: IntNullableFilter<"LessonProgress"> | number | null
    createdAt?: DateTimeFilter<"LessonProgress"> | Date | string
    updatedAt?: DateTimeFilter<"LessonProgress"> | Date | string
    userId?: StringFilter<"LessonProgress"> | string
    lessonId?: StringFilter<"LessonProgress"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }, "id" | "userId_lessonId">

  export type LessonProgressOrderByWithAggregationInput = {
    id?: SortOrder
    completed?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    watchedSeconds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    _count?: LessonProgressCountOrderByAggregateInput
    _avg?: LessonProgressAvgOrderByAggregateInput
    _max?: LessonProgressMaxOrderByAggregateInput
    _min?: LessonProgressMinOrderByAggregateInput
    _sum?: LessonProgressSumOrderByAggregateInput
  }

  export type LessonProgressScalarWhereWithAggregatesInput = {
    AND?: LessonProgressScalarWhereWithAggregatesInput | LessonProgressScalarWhereWithAggregatesInput[]
    OR?: LessonProgressScalarWhereWithAggregatesInput[]
    NOT?: LessonProgressScalarWhereWithAggregatesInput | LessonProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LessonProgress"> | string
    completed?: BoolWithAggregatesFilter<"LessonProgress"> | boolean
    startTime?: DateTimeNullableWithAggregatesFilter<"LessonProgress"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"LessonProgress"> | Date | string | null
    watchedSeconds?: IntNullableWithAggregatesFilter<"LessonProgress"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"LessonProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LessonProgress"> | Date | string
    userId?: StringWithAggregatesFilter<"LessonProgress"> | string
    lessonId?: StringWithAggregatesFilter<"LessonProgress"> | string
  }

  export type UserProgressWhereInput = {
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    type?: StringFilter<"UserProgress"> | string
    itemId?: StringFilter<"UserProgress"> | string
    completed?: BoolFilter<"UserProgress"> | boolean
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
    progressPercentage?: FloatNullableFilter<"UserProgress"> | number | null
    startedAt?: DateTimeNullableFilter<"UserProgress"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"UserProgress"> | Date | string | null
    timeSpent?: IntNullableFilter<"UserProgress"> | number | null
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    workshop?: XOR<WorkshopNullableScalarRelationFilter, WorkshopWhereInput> | null
    path?: XOR<LearningPathNullableScalarRelationFilter, LearningPathWhereInput> | null
  }

  export type UserProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    completed?: SortOrder
    updatedAt?: SortOrder
    progressPercentage?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    timeSpent?: SortOrderInput | SortOrder
    course?: CourseOrderByWithRelationInput
    workshop?: WorkshopOrderByWithRelationInput
    path?: LearningPathOrderByWithRelationInput
  }

  export type UserProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    userId?: StringFilter<"UserProgress"> | string
    type?: StringFilter<"UserProgress"> | string
    itemId?: StringFilter<"UserProgress"> | string
    completed?: BoolFilter<"UserProgress"> | boolean
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
    progressPercentage?: FloatNullableFilter<"UserProgress"> | number | null
    startedAt?: DateTimeNullableFilter<"UserProgress"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"UserProgress"> | Date | string | null
    timeSpent?: IntNullableFilter<"UserProgress"> | number | null
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    workshop?: XOR<WorkshopNullableScalarRelationFilter, WorkshopWhereInput> | null
    path?: XOR<LearningPathNullableScalarRelationFilter, LearningPathWhereInput> | null
  }, "id">

  export type UserProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    completed?: SortOrder
    updatedAt?: SortOrder
    progressPercentage?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    timeSpent?: SortOrderInput | SortOrder
    _count?: UserProgressCountOrderByAggregateInput
    _avg?: UserProgressAvgOrderByAggregateInput
    _max?: UserProgressMaxOrderByAggregateInput
    _min?: UserProgressMinOrderByAggregateInput
    _sum?: UserProgressSumOrderByAggregateInput
  }

  export type UserProgressScalarWhereWithAggregatesInput = {
    AND?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    OR?: UserProgressScalarWhereWithAggregatesInput[]
    NOT?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProgress"> | string
    userId?: StringWithAggregatesFilter<"UserProgress"> | string
    type?: StringWithAggregatesFilter<"UserProgress"> | string
    itemId?: StringWithAggregatesFilter<"UserProgress"> | string
    completed?: BoolWithAggregatesFilter<"UserProgress"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
    progressPercentage?: FloatNullableWithAggregatesFilter<"UserProgress"> | number | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"UserProgress"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserProgress"> | Date | string | null
    timeSpent?: IntNullableWithAggregatesFilter<"UserProgress"> | number | null
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    title?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    color?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    courseTags?: CourseTagListRelationFilter
    workshopTags?: WorkshopTagListRelationFilter
    learningPathTags?: LearningPathTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseTags?: CourseTagOrderByRelationAggregateInput
    workshopTags?: WorkshopTagOrderByRelationAggregateInput
    learningPathTags?: LearningPathTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    title?: StringFilter<"Tag"> | string
    color?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    courseTags?: CourseTagListRelationFilter
    workshopTags?: WorkshopTagListRelationFilter
    learningPathTags?: LearningPathTagListRelationFilter
  }, "id" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    title?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type CourseTagWhereInput = {
    AND?: CourseTagWhereInput | CourseTagWhereInput[]
    OR?: CourseTagWhereInput[]
    NOT?: CourseTagWhereInput | CourseTagWhereInput[]
    courseId?: StringFilter<"CourseTag"> | string
    tagId?: StringFilter<"CourseTag"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type CourseTagOrderByWithRelationInput = {
    courseId?: SortOrder
    tagId?: SortOrder
    course?: CourseOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type CourseTagWhereUniqueInput = Prisma.AtLeast<{
    courseId_tagId?: CourseTagCourseIdTagIdCompoundUniqueInput
    AND?: CourseTagWhereInput | CourseTagWhereInput[]
    OR?: CourseTagWhereInput[]
    NOT?: CourseTagWhereInput | CourseTagWhereInput[]
    courseId?: StringFilter<"CourseTag"> | string
    tagId?: StringFilter<"CourseTag"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "courseId_tagId">

  export type CourseTagOrderByWithAggregationInput = {
    courseId?: SortOrder
    tagId?: SortOrder
    _count?: CourseTagCountOrderByAggregateInput
    _max?: CourseTagMaxOrderByAggregateInput
    _min?: CourseTagMinOrderByAggregateInput
  }

  export type CourseTagScalarWhereWithAggregatesInput = {
    AND?: CourseTagScalarWhereWithAggregatesInput | CourseTagScalarWhereWithAggregatesInput[]
    OR?: CourseTagScalarWhereWithAggregatesInput[]
    NOT?: CourseTagScalarWhereWithAggregatesInput | CourseTagScalarWhereWithAggregatesInput[]
    courseId?: StringWithAggregatesFilter<"CourseTag"> | string
    tagId?: StringWithAggregatesFilter<"CourseTag"> | string
  }

  export type WorkshopTagWhereInput = {
    AND?: WorkshopTagWhereInput | WorkshopTagWhereInput[]
    OR?: WorkshopTagWhereInput[]
    NOT?: WorkshopTagWhereInput | WorkshopTagWhereInput[]
    workshopId?: StringFilter<"WorkshopTag"> | string
    tagId?: StringFilter<"WorkshopTag"> | string
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type WorkshopTagOrderByWithRelationInput = {
    workshopId?: SortOrder
    tagId?: SortOrder
    workshop?: WorkshopOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type WorkshopTagWhereUniqueInput = Prisma.AtLeast<{
    workshopId_tagId?: WorkshopTagWorkshopIdTagIdCompoundUniqueInput
    AND?: WorkshopTagWhereInput | WorkshopTagWhereInput[]
    OR?: WorkshopTagWhereInput[]
    NOT?: WorkshopTagWhereInput | WorkshopTagWhereInput[]
    workshopId?: StringFilter<"WorkshopTag"> | string
    tagId?: StringFilter<"WorkshopTag"> | string
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "workshopId_tagId">

  export type WorkshopTagOrderByWithAggregationInput = {
    workshopId?: SortOrder
    tagId?: SortOrder
    _count?: WorkshopTagCountOrderByAggregateInput
    _max?: WorkshopTagMaxOrderByAggregateInput
    _min?: WorkshopTagMinOrderByAggregateInput
  }

  export type WorkshopTagScalarWhereWithAggregatesInput = {
    AND?: WorkshopTagScalarWhereWithAggregatesInput | WorkshopTagScalarWhereWithAggregatesInput[]
    OR?: WorkshopTagScalarWhereWithAggregatesInput[]
    NOT?: WorkshopTagScalarWhereWithAggregatesInput | WorkshopTagScalarWhereWithAggregatesInput[]
    workshopId?: StringWithAggregatesFilter<"WorkshopTag"> | string
    tagId?: StringWithAggregatesFilter<"WorkshopTag"> | string
  }

  export type LearningPathTagWhereInput = {
    AND?: LearningPathTagWhereInput | LearningPathTagWhereInput[]
    OR?: LearningPathTagWhereInput[]
    NOT?: LearningPathTagWhereInput | LearningPathTagWhereInput[]
    learningPathId?: StringFilter<"LearningPathTag"> | string
    tagId?: StringFilter<"LearningPathTag"> | string
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type LearningPathTagOrderByWithRelationInput = {
    learningPathId?: SortOrder
    tagId?: SortOrder
    learningPath?: LearningPathOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type LearningPathTagWhereUniqueInput = Prisma.AtLeast<{
    learningPathId_tagId?: LearningPathTagLearningPathIdTagIdCompoundUniqueInput
    AND?: LearningPathTagWhereInput | LearningPathTagWhereInput[]
    OR?: LearningPathTagWhereInput[]
    NOT?: LearningPathTagWhereInput | LearningPathTagWhereInput[]
    learningPathId?: StringFilter<"LearningPathTag"> | string
    tagId?: StringFilter<"LearningPathTag"> | string
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "learningPathId_tagId">

  export type LearningPathTagOrderByWithAggregationInput = {
    learningPathId?: SortOrder
    tagId?: SortOrder
    _count?: LearningPathTagCountOrderByAggregateInput
    _max?: LearningPathTagMaxOrderByAggregateInput
    _min?: LearningPathTagMinOrderByAggregateInput
  }

  export type LearningPathTagScalarWhereWithAggregatesInput = {
    AND?: LearningPathTagScalarWhereWithAggregatesInput | LearningPathTagScalarWhereWithAggregatesInput[]
    OR?: LearningPathTagScalarWhereWithAggregatesInput[]
    NOT?: LearningPathTagScalarWhereWithAggregatesInput | LearningPathTagScalarWhereWithAggregatesInput[]
    learningPathId?: StringWithAggregatesFilter<"LearningPathTag"> | string
    tagId?: StringWithAggregatesFilter<"LearningPathTag"> | string
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: StringFilter<"Promotion"> | string
    title?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    discount?: IntFilter<"Promotion"> | number
    type?: StringFilter<"Promotion"> | string
    startsAt?: DateTimeFilter<"Promotion"> | Date | string
    endsAt?: DateTimeFilter<"Promotion"> | Date | string
    active?: BoolFilter<"Promotion"> | boolean
    itemType?: StringFilter<"Promotion"> | string
    courseId?: StringNullableFilter<"Promotion"> | string | null
    workshopId?: StringNullableFilter<"Promotion"> | string | null
    learningPathId?: StringNullableFilter<"Promotion"> | string | null
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    workshop?: XOR<WorkshopNullableScalarRelationFilter, WorkshopWhereInput> | null
    learningPath?: XOR<LearningPathNullableScalarRelationFilter, LearningPathWhereInput> | null
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    discount?: SortOrder
    type?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    active?: SortOrder
    itemType?: SortOrder
    courseId?: SortOrderInput | SortOrder
    workshopId?: SortOrderInput | SortOrder
    learningPathId?: SortOrderInput | SortOrder
    course?: CourseOrderByWithRelationInput
    workshop?: WorkshopOrderByWithRelationInput
    learningPath?: LearningPathOrderByWithRelationInput
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    title?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    discount?: IntFilter<"Promotion"> | number
    type?: StringFilter<"Promotion"> | string
    startsAt?: DateTimeFilter<"Promotion"> | Date | string
    endsAt?: DateTimeFilter<"Promotion"> | Date | string
    active?: BoolFilter<"Promotion"> | boolean
    itemType?: StringFilter<"Promotion"> | string
    courseId?: StringNullableFilter<"Promotion"> | string | null
    workshopId?: StringNullableFilter<"Promotion"> | string | null
    learningPathId?: StringNullableFilter<"Promotion"> | string | null
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    workshop?: XOR<WorkshopNullableScalarRelationFilter, WorkshopWhereInput> | null
    learningPath?: XOR<LearningPathNullableScalarRelationFilter, LearningPathWhereInput> | null
  }, "id">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    discount?: SortOrder
    type?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    active?: SortOrder
    itemType?: SortOrder
    courseId?: SortOrderInput | SortOrder
    workshopId?: SortOrderInput | SortOrder
    learningPathId?: SortOrderInput | SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Promotion"> | string
    title?: StringWithAggregatesFilter<"Promotion"> | string
    description?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    discount?: IntWithAggregatesFilter<"Promotion"> | number
    type?: StringWithAggregatesFilter<"Promotion"> | string
    startsAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    endsAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    active?: BoolWithAggregatesFilter<"Promotion"> | boolean
    itemType?: StringWithAggregatesFilter<"Promotion"> | string
    courseId?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    workshopId?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    learningPathId?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
  }

  export type PromoCodeWhereInput = {
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    id?: StringFilter<"PromoCode"> | string
    code?: StringFilter<"PromoCode"> | string
    description?: StringNullableFilter<"PromoCode"> | string | null
    discount?: IntFilter<"PromoCode"> | number
    type?: StringFilter<"PromoCode"> | string
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    usedCount?: IntFilter<"PromoCode"> | number
    startsAt?: DateTimeFilter<"PromoCode"> | Date | string
    endsAt?: DateTimeFilter<"PromoCode"> | Date | string
    active?: BoolFilter<"PromoCode"> | boolean
    applicableCourses?: CourseListRelationFilter
    applicableWorkshops?: WorkshopListRelationFilter
    applicableLearningPaths?: LearningPathListRelationFilter
  }

  export type PromoCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discount?: SortOrder
    type?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    active?: SortOrder
    applicableCourses?: CourseOrderByRelationAggregateInput
    applicableWorkshops?: WorkshopOrderByRelationAggregateInput
    applicableLearningPaths?: LearningPathOrderByRelationAggregateInput
  }

  export type PromoCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    description?: StringNullableFilter<"PromoCode"> | string | null
    discount?: IntFilter<"PromoCode"> | number
    type?: StringFilter<"PromoCode"> | string
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    usedCount?: IntFilter<"PromoCode"> | number
    startsAt?: DateTimeFilter<"PromoCode"> | Date | string
    endsAt?: DateTimeFilter<"PromoCode"> | Date | string
    active?: BoolFilter<"PromoCode"> | boolean
    applicableCourses?: CourseListRelationFilter
    applicableWorkshops?: WorkshopListRelationFilter
    applicableLearningPaths?: LearningPathListRelationFilter
  }, "id" | "code">

  export type PromoCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discount?: SortOrder
    type?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    active?: SortOrder
    _count?: PromoCodeCountOrderByAggregateInput
    _avg?: PromoCodeAvgOrderByAggregateInput
    _max?: PromoCodeMaxOrderByAggregateInput
    _min?: PromoCodeMinOrderByAggregateInput
    _sum?: PromoCodeSumOrderByAggregateInput
  }

  export type PromoCodeScalarWhereWithAggregatesInput = {
    AND?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    OR?: PromoCodeScalarWhereWithAggregatesInput[]
    NOT?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromoCode"> | string
    code?: StringWithAggregatesFilter<"PromoCode"> | string
    description?: StringNullableWithAggregatesFilter<"PromoCode"> | string | null
    discount?: IntWithAggregatesFilter<"PromoCode"> | number
    type?: StringWithAggregatesFilter<"PromoCode"> | string
    usageLimit?: IntNullableWithAggregatesFilter<"PromoCode"> | number | null
    usedCount?: IntWithAggregatesFilter<"PromoCode"> | number
    startsAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
    endsAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
    active?: BoolWithAggregatesFilter<"PromoCode"> | boolean
  }

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    amount?: IntFilter<"Enrollment"> | number
    status?: EnumenrollmentStatusFilter<"Enrollment"> | $Enums.enrollmentStatus
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
    courseId?: StringNullableFilter<"Enrollment"> | string | null
    learningPathId?: StringNullableFilter<"Enrollment"> | string | null
    workshopId?: StringNullableFilter<"Enrollment"> | string | null
    userId?: StringFilter<"Enrollment"> | string
    paymentId?: StringNullableFilter<"Enrollment"> | string | null
    deletedAt?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    learningPath?: XOR<LearningPathNullableScalarRelationFilter, LearningPathWhereInput> | null
    workshop?: XOR<WorkshopNullableScalarRelationFilter, WorkshopWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
  }

  export type EnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrderInput | SortOrder
    learningPathId?: SortOrderInput | SortOrder
    workshopId?: SortOrderInput | SortOrder
    userId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    course?: CourseOrderByWithRelationInput
    learningPath?: LearningPathOrderByWithRelationInput
    workshop?: WorkshopOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
  }

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentId?: string
    userId_learningPathId?: EnrollmentUserIdLearningPathIdCompoundUniqueInput
    userId_courseId?: EnrollmentUserIdCourseIdCompoundUniqueInput
    userId_workshopId?: EnrollmentUserIdWorkshopIdCompoundUniqueInput
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    amount?: IntFilter<"Enrollment"> | number
    status?: EnumenrollmentStatusFilter<"Enrollment"> | $Enums.enrollmentStatus
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
    courseId?: StringNullableFilter<"Enrollment"> | string | null
    learningPathId?: StringNullableFilter<"Enrollment"> | string | null
    workshopId?: StringNullableFilter<"Enrollment"> | string | null
    userId?: StringFilter<"Enrollment"> | string
    deletedAt?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    learningPath?: XOR<LearningPathNullableScalarRelationFilter, LearningPathWhereInput> | null
    workshop?: XOR<WorkshopNullableScalarRelationFilter, WorkshopWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
  }, "id" | "paymentId" | "userId_learningPathId" | "userId_courseId" | "userId_workshopId">

  export type EnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrderInput | SortOrder
    learningPathId?: SortOrderInput | SortOrder
    workshopId?: SortOrderInput | SortOrder
    userId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: EnrollmentCountOrderByAggregateInput
    _avg?: EnrollmentAvgOrderByAggregateInput
    _max?: EnrollmentMaxOrderByAggregateInput
    _min?: EnrollmentMinOrderByAggregateInput
    _sum?: EnrollmentSumOrderByAggregateInput
  }

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    OR?: EnrollmentScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Enrollment"> | string
    amount?: IntWithAggregatesFilter<"Enrollment"> | number
    status?: EnumenrollmentStatusWithAggregatesFilter<"Enrollment"> | $Enums.enrollmentStatus
    createdAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
    courseId?: StringNullableWithAggregatesFilter<"Enrollment"> | string | null
    learningPathId?: StringNullableWithAggregatesFilter<"Enrollment"> | string | null
    workshopId?: StringNullableWithAggregatesFilter<"Enrollment"> | string | null
    userId?: StringWithAggregatesFilter<"Enrollment"> | string
    paymentId?: StringNullableWithAggregatesFilter<"Enrollment"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Enrollment"> | Date | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    stripeId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    courseId?: StringNullableFilter<"Payment"> | string | null
    learningPathId?: StringNullableFilter<"Payment"> | string | null
    workshopId?: StringNullableFilter<"Payment"> | string | null
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    method?: StringNullableFilter<"Payment"> | string | null
    receiptUrl?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    learningPath?: XOR<LearningPathNullableScalarRelationFilter, LearningPathWhereInput> | null
    workshop?: XOR<WorkshopNullableScalarRelationFilter, WorkshopWhereInput> | null
    enrollment?: XOR<EnrollmentNullableScalarRelationFilter, EnrollmentWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    stripeId?: SortOrder
    userId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    learningPathId?: SortOrderInput | SortOrder
    workshopId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    learningPath?: LearningPathOrderByWithRelationInput
    workshop?: WorkshopOrderByWithRelationInput
    enrollment?: EnrollmentOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: StringFilter<"Payment"> | string
    courseId?: StringNullableFilter<"Payment"> | string | null
    learningPathId?: StringNullableFilter<"Payment"> | string | null
    workshopId?: StringNullableFilter<"Payment"> | string | null
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    method?: StringNullableFilter<"Payment"> | string | null
    receiptUrl?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    learningPath?: XOR<LearningPathNullableScalarRelationFilter, LearningPathWhereInput> | null
    workshop?: XOR<WorkshopNullableScalarRelationFilter, WorkshopWhereInput> | null
    enrollment?: XOR<EnrollmentNullableScalarRelationFilter, EnrollmentWhereInput> | null
  }, "id" | "stripeId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    stripeId?: SortOrder
    userId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    learningPathId?: SortOrderInput | SortOrder
    workshopId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    stripeId?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    courseId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    learningPathId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    workshopId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: IntWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    method?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    receiptUrl?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    number?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    amount?: IntFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    date?: DateTimeFilter<"Invoice"> | Date | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: InvoiceItemListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    number?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    amount?: IntFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    date?: DateTimeFilter<"Invoice"> | Date | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: InvoiceItemListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    number?: StringWithAggregatesFilter<"Invoice"> | string
    userId?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: IntWithAggregatesFilter<"Invoice"> | number
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    pdfUrl?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    title?: StringFilter<"InvoiceItem"> | string
    type?: StringFilter<"InvoiceItem"> | string
    referenceId?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: IntFilter<"InvoiceItem"> | number
    total?: IntFilter<"InvoiceItem"> | number
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: StringFilter<"InvoiceItem"> | string
    title?: StringFilter<"InvoiceItem"> | string
    type?: StringFilter<"InvoiceItem"> | string
    referenceId?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: IntFilter<"InvoiceItem"> | number
    total?: IntFilter<"InvoiceItem"> | number
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceItem"> | string
    title?: StringWithAggregatesFilter<"InvoiceItem"> | string
    type?: StringWithAggregatesFilter<"InvoiceItem"> | string
    referenceId?: StringWithAggregatesFilter<"InvoiceItem"> | string
    quantity?: IntWithAggregatesFilter<"InvoiceItem"> | number
    unitPrice?: IntWithAggregatesFilter<"InvoiceItem"> | number
    total?: IntWithAggregatesFilter<"InvoiceItem"> | number
  }

  export type ObjectiveWhereInput = {
    AND?: ObjectiveWhereInput | ObjectiveWhereInput[]
    OR?: ObjectiveWhereInput[]
    NOT?: ObjectiveWhereInput | ObjectiveWhereInput[]
    id?: StringFilter<"Objective"> | string
    content?: StringFilter<"Objective"> | string
    createdAt?: DateTimeFilter<"Objective"> | Date | string
    courses?: CourseObjectiveListRelationFilter
    workshops?: WorkshopObjectiveListRelationFilter
    learningPaths?: LearningPathObjectiveListRelationFilter
  }

  export type ObjectiveOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    courses?: CourseObjectiveOrderByRelationAggregateInput
    workshops?: WorkshopObjectiveOrderByRelationAggregateInput
    learningPaths?: LearningPathObjectiveOrderByRelationAggregateInput
  }

  export type ObjectiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObjectiveWhereInput | ObjectiveWhereInput[]
    OR?: ObjectiveWhereInput[]
    NOT?: ObjectiveWhereInput | ObjectiveWhereInput[]
    content?: StringFilter<"Objective"> | string
    createdAt?: DateTimeFilter<"Objective"> | Date | string
    courses?: CourseObjectiveListRelationFilter
    workshops?: WorkshopObjectiveListRelationFilter
    learningPaths?: LearningPathObjectiveListRelationFilter
  }, "id">

  export type ObjectiveOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: ObjectiveCountOrderByAggregateInput
    _max?: ObjectiveMaxOrderByAggregateInput
    _min?: ObjectiveMinOrderByAggregateInput
  }

  export type ObjectiveScalarWhereWithAggregatesInput = {
    AND?: ObjectiveScalarWhereWithAggregatesInput | ObjectiveScalarWhereWithAggregatesInput[]
    OR?: ObjectiveScalarWhereWithAggregatesInput[]
    NOT?: ObjectiveScalarWhereWithAggregatesInput | ObjectiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Objective"> | string
    content?: StringWithAggregatesFilter<"Objective"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Objective"> | Date | string
  }

  export type PrerequisiteWhereInput = {
    AND?: PrerequisiteWhereInput | PrerequisiteWhereInput[]
    OR?: PrerequisiteWhereInput[]
    NOT?: PrerequisiteWhereInput | PrerequisiteWhereInput[]
    id?: StringFilter<"Prerequisite"> | string
    content?: StringFilter<"Prerequisite"> | string
    createdAt?: DateTimeFilter<"Prerequisite"> | Date | string
    courses?: CoursePrerequisiteListRelationFilter
    workshops?: WorkshopPrerequisiteListRelationFilter
    learningPaths?: LearningPathPrerequisiteListRelationFilter
  }

  export type PrerequisiteOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    courses?: CoursePrerequisiteOrderByRelationAggregateInput
    workshops?: WorkshopPrerequisiteOrderByRelationAggregateInput
    learningPaths?: LearningPathPrerequisiteOrderByRelationAggregateInput
  }

  export type PrerequisiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrerequisiteWhereInput | PrerequisiteWhereInput[]
    OR?: PrerequisiteWhereInput[]
    NOT?: PrerequisiteWhereInput | PrerequisiteWhereInput[]
    content?: StringFilter<"Prerequisite"> | string
    createdAt?: DateTimeFilter<"Prerequisite"> | Date | string
    courses?: CoursePrerequisiteListRelationFilter
    workshops?: WorkshopPrerequisiteListRelationFilter
    learningPaths?: LearningPathPrerequisiteListRelationFilter
  }, "id">

  export type PrerequisiteOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: PrerequisiteCountOrderByAggregateInput
    _max?: PrerequisiteMaxOrderByAggregateInput
    _min?: PrerequisiteMinOrderByAggregateInput
  }

  export type PrerequisiteScalarWhereWithAggregatesInput = {
    AND?: PrerequisiteScalarWhereWithAggregatesInput | PrerequisiteScalarWhereWithAggregatesInput[]
    OR?: PrerequisiteScalarWhereWithAggregatesInput[]
    NOT?: PrerequisiteScalarWhereWithAggregatesInput | PrerequisiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prerequisite"> | string
    content?: StringWithAggregatesFilter<"Prerequisite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Prerequisite"> | Date | string
  }

  export type CourseObjectiveWhereInput = {
    AND?: CourseObjectiveWhereInput | CourseObjectiveWhereInput[]
    OR?: CourseObjectiveWhereInput[]
    NOT?: CourseObjectiveWhereInput | CourseObjectiveWhereInput[]
    courseId?: StringFilter<"CourseObjective"> | string
    objectiveId?: StringFilter<"CourseObjective"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    objective?: XOR<ObjectiveScalarRelationFilter, ObjectiveWhereInput>
  }

  export type CourseObjectiveOrderByWithRelationInput = {
    courseId?: SortOrder
    objectiveId?: SortOrder
    course?: CourseOrderByWithRelationInput
    objective?: ObjectiveOrderByWithRelationInput
  }

  export type CourseObjectiveWhereUniqueInput = Prisma.AtLeast<{
    courseId_objectiveId?: CourseObjectiveCourseIdObjectiveIdCompoundUniqueInput
    AND?: CourseObjectiveWhereInput | CourseObjectiveWhereInput[]
    OR?: CourseObjectiveWhereInput[]
    NOT?: CourseObjectiveWhereInput | CourseObjectiveWhereInput[]
    courseId?: StringFilter<"CourseObjective"> | string
    objectiveId?: StringFilter<"CourseObjective"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    objective?: XOR<ObjectiveScalarRelationFilter, ObjectiveWhereInput>
  }, "courseId_objectiveId">

  export type CourseObjectiveOrderByWithAggregationInput = {
    courseId?: SortOrder
    objectiveId?: SortOrder
    _count?: CourseObjectiveCountOrderByAggregateInput
    _max?: CourseObjectiveMaxOrderByAggregateInput
    _min?: CourseObjectiveMinOrderByAggregateInput
  }

  export type CourseObjectiveScalarWhereWithAggregatesInput = {
    AND?: CourseObjectiveScalarWhereWithAggregatesInput | CourseObjectiveScalarWhereWithAggregatesInput[]
    OR?: CourseObjectiveScalarWhereWithAggregatesInput[]
    NOT?: CourseObjectiveScalarWhereWithAggregatesInput | CourseObjectiveScalarWhereWithAggregatesInput[]
    courseId?: StringWithAggregatesFilter<"CourseObjective"> | string
    objectiveId?: StringWithAggregatesFilter<"CourseObjective"> | string
  }

  export type CoursePrerequisiteWhereInput = {
    AND?: CoursePrerequisiteWhereInput | CoursePrerequisiteWhereInput[]
    OR?: CoursePrerequisiteWhereInput[]
    NOT?: CoursePrerequisiteWhereInput | CoursePrerequisiteWhereInput[]
    courseId?: StringFilter<"CoursePrerequisite"> | string
    prerequisiteId?: StringFilter<"CoursePrerequisite"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    prerequisite?: XOR<PrerequisiteScalarRelationFilter, PrerequisiteWhereInput>
  }

  export type CoursePrerequisiteOrderByWithRelationInput = {
    courseId?: SortOrder
    prerequisiteId?: SortOrder
    course?: CourseOrderByWithRelationInput
    prerequisite?: PrerequisiteOrderByWithRelationInput
  }

  export type CoursePrerequisiteWhereUniqueInput = Prisma.AtLeast<{
    courseId_prerequisiteId?: CoursePrerequisiteCourseIdPrerequisiteIdCompoundUniqueInput
    AND?: CoursePrerequisiteWhereInput | CoursePrerequisiteWhereInput[]
    OR?: CoursePrerequisiteWhereInput[]
    NOT?: CoursePrerequisiteWhereInput | CoursePrerequisiteWhereInput[]
    courseId?: StringFilter<"CoursePrerequisite"> | string
    prerequisiteId?: StringFilter<"CoursePrerequisite"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    prerequisite?: XOR<PrerequisiteScalarRelationFilter, PrerequisiteWhereInput>
  }, "courseId_prerequisiteId">

  export type CoursePrerequisiteOrderByWithAggregationInput = {
    courseId?: SortOrder
    prerequisiteId?: SortOrder
    _count?: CoursePrerequisiteCountOrderByAggregateInput
    _max?: CoursePrerequisiteMaxOrderByAggregateInput
    _min?: CoursePrerequisiteMinOrderByAggregateInput
  }

  export type CoursePrerequisiteScalarWhereWithAggregatesInput = {
    AND?: CoursePrerequisiteScalarWhereWithAggregatesInput | CoursePrerequisiteScalarWhereWithAggregatesInput[]
    OR?: CoursePrerequisiteScalarWhereWithAggregatesInput[]
    NOT?: CoursePrerequisiteScalarWhereWithAggregatesInput | CoursePrerequisiteScalarWhereWithAggregatesInput[]
    courseId?: StringWithAggregatesFilter<"CoursePrerequisite"> | string
    prerequisiteId?: StringWithAggregatesFilter<"CoursePrerequisite"> | string
  }

  export type WorkshopObjectiveWhereInput = {
    AND?: WorkshopObjectiveWhereInput | WorkshopObjectiveWhereInput[]
    OR?: WorkshopObjectiveWhereInput[]
    NOT?: WorkshopObjectiveWhereInput | WorkshopObjectiveWhereInput[]
    workshopId?: StringFilter<"WorkshopObjective"> | string
    objectiveId?: StringFilter<"WorkshopObjective"> | string
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    objective?: XOR<ObjectiveScalarRelationFilter, ObjectiveWhereInput>
  }

  export type WorkshopObjectiveOrderByWithRelationInput = {
    workshopId?: SortOrder
    objectiveId?: SortOrder
    workshop?: WorkshopOrderByWithRelationInput
    objective?: ObjectiveOrderByWithRelationInput
  }

  export type WorkshopObjectiveWhereUniqueInput = Prisma.AtLeast<{
    workshopId_objectiveId?: WorkshopObjectiveWorkshopIdObjectiveIdCompoundUniqueInput
    AND?: WorkshopObjectiveWhereInput | WorkshopObjectiveWhereInput[]
    OR?: WorkshopObjectiveWhereInput[]
    NOT?: WorkshopObjectiveWhereInput | WorkshopObjectiveWhereInput[]
    workshopId?: StringFilter<"WorkshopObjective"> | string
    objectiveId?: StringFilter<"WorkshopObjective"> | string
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    objective?: XOR<ObjectiveScalarRelationFilter, ObjectiveWhereInput>
  }, "workshopId_objectiveId">

  export type WorkshopObjectiveOrderByWithAggregationInput = {
    workshopId?: SortOrder
    objectiveId?: SortOrder
    _count?: WorkshopObjectiveCountOrderByAggregateInput
    _max?: WorkshopObjectiveMaxOrderByAggregateInput
    _min?: WorkshopObjectiveMinOrderByAggregateInput
  }

  export type WorkshopObjectiveScalarWhereWithAggregatesInput = {
    AND?: WorkshopObjectiveScalarWhereWithAggregatesInput | WorkshopObjectiveScalarWhereWithAggregatesInput[]
    OR?: WorkshopObjectiveScalarWhereWithAggregatesInput[]
    NOT?: WorkshopObjectiveScalarWhereWithAggregatesInput | WorkshopObjectiveScalarWhereWithAggregatesInput[]
    workshopId?: StringWithAggregatesFilter<"WorkshopObjective"> | string
    objectiveId?: StringWithAggregatesFilter<"WorkshopObjective"> | string
  }

  export type WorkshopPrerequisiteWhereInput = {
    AND?: WorkshopPrerequisiteWhereInput | WorkshopPrerequisiteWhereInput[]
    OR?: WorkshopPrerequisiteWhereInput[]
    NOT?: WorkshopPrerequisiteWhereInput | WorkshopPrerequisiteWhereInput[]
    workshopId?: StringFilter<"WorkshopPrerequisite"> | string
    prerequisiteId?: StringFilter<"WorkshopPrerequisite"> | string
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    prerequisite?: XOR<PrerequisiteScalarRelationFilter, PrerequisiteWhereInput>
  }

  export type WorkshopPrerequisiteOrderByWithRelationInput = {
    workshopId?: SortOrder
    prerequisiteId?: SortOrder
    workshop?: WorkshopOrderByWithRelationInput
    prerequisite?: PrerequisiteOrderByWithRelationInput
  }

  export type WorkshopPrerequisiteWhereUniqueInput = Prisma.AtLeast<{
    workshopId_prerequisiteId?: WorkshopPrerequisiteWorkshopIdPrerequisiteIdCompoundUniqueInput
    AND?: WorkshopPrerequisiteWhereInput | WorkshopPrerequisiteWhereInput[]
    OR?: WorkshopPrerequisiteWhereInput[]
    NOT?: WorkshopPrerequisiteWhereInput | WorkshopPrerequisiteWhereInput[]
    workshopId?: StringFilter<"WorkshopPrerequisite"> | string
    prerequisiteId?: StringFilter<"WorkshopPrerequisite"> | string
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    prerequisite?: XOR<PrerequisiteScalarRelationFilter, PrerequisiteWhereInput>
  }, "workshopId_prerequisiteId">

  export type WorkshopPrerequisiteOrderByWithAggregationInput = {
    workshopId?: SortOrder
    prerequisiteId?: SortOrder
    _count?: WorkshopPrerequisiteCountOrderByAggregateInput
    _max?: WorkshopPrerequisiteMaxOrderByAggregateInput
    _min?: WorkshopPrerequisiteMinOrderByAggregateInput
  }

  export type WorkshopPrerequisiteScalarWhereWithAggregatesInput = {
    AND?: WorkshopPrerequisiteScalarWhereWithAggregatesInput | WorkshopPrerequisiteScalarWhereWithAggregatesInput[]
    OR?: WorkshopPrerequisiteScalarWhereWithAggregatesInput[]
    NOT?: WorkshopPrerequisiteScalarWhereWithAggregatesInput | WorkshopPrerequisiteScalarWhereWithAggregatesInput[]
    workshopId?: StringWithAggregatesFilter<"WorkshopPrerequisite"> | string
    prerequisiteId?: StringWithAggregatesFilter<"WorkshopPrerequisite"> | string
  }

  export type LearningPathObjectiveWhereInput = {
    AND?: LearningPathObjectiveWhereInput | LearningPathObjectiveWhereInput[]
    OR?: LearningPathObjectiveWhereInput[]
    NOT?: LearningPathObjectiveWhereInput | LearningPathObjectiveWhereInput[]
    learningPathId?: StringFilter<"LearningPathObjective"> | string
    objectiveId?: StringFilter<"LearningPathObjective"> | string
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    objective?: XOR<ObjectiveScalarRelationFilter, ObjectiveWhereInput>
  }

  export type LearningPathObjectiveOrderByWithRelationInput = {
    learningPathId?: SortOrder
    objectiveId?: SortOrder
    learningPath?: LearningPathOrderByWithRelationInput
    objective?: ObjectiveOrderByWithRelationInput
  }

  export type LearningPathObjectiveWhereUniqueInput = Prisma.AtLeast<{
    learningPathId_objectiveId?: LearningPathObjectiveLearningPathIdObjectiveIdCompoundUniqueInput
    AND?: LearningPathObjectiveWhereInput | LearningPathObjectiveWhereInput[]
    OR?: LearningPathObjectiveWhereInput[]
    NOT?: LearningPathObjectiveWhereInput | LearningPathObjectiveWhereInput[]
    learningPathId?: StringFilter<"LearningPathObjective"> | string
    objectiveId?: StringFilter<"LearningPathObjective"> | string
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    objective?: XOR<ObjectiveScalarRelationFilter, ObjectiveWhereInput>
  }, "learningPathId_objectiveId">

  export type LearningPathObjectiveOrderByWithAggregationInput = {
    learningPathId?: SortOrder
    objectiveId?: SortOrder
    _count?: LearningPathObjectiveCountOrderByAggregateInput
    _max?: LearningPathObjectiveMaxOrderByAggregateInput
    _min?: LearningPathObjectiveMinOrderByAggregateInput
  }

  export type LearningPathObjectiveScalarWhereWithAggregatesInput = {
    AND?: LearningPathObjectiveScalarWhereWithAggregatesInput | LearningPathObjectiveScalarWhereWithAggregatesInput[]
    OR?: LearningPathObjectiveScalarWhereWithAggregatesInput[]
    NOT?: LearningPathObjectiveScalarWhereWithAggregatesInput | LearningPathObjectiveScalarWhereWithAggregatesInput[]
    learningPathId?: StringWithAggregatesFilter<"LearningPathObjective"> | string
    objectiveId?: StringWithAggregatesFilter<"LearningPathObjective"> | string
  }

  export type LearningPathPrerequisiteWhereInput = {
    AND?: LearningPathPrerequisiteWhereInput | LearningPathPrerequisiteWhereInput[]
    OR?: LearningPathPrerequisiteWhereInput[]
    NOT?: LearningPathPrerequisiteWhereInput | LearningPathPrerequisiteWhereInput[]
    learningPathId?: StringFilter<"LearningPathPrerequisite"> | string
    prerequisiteId?: StringFilter<"LearningPathPrerequisite"> | string
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    prerequisite?: XOR<PrerequisiteScalarRelationFilter, PrerequisiteWhereInput>
  }

  export type LearningPathPrerequisiteOrderByWithRelationInput = {
    learningPathId?: SortOrder
    prerequisiteId?: SortOrder
    learningPath?: LearningPathOrderByWithRelationInput
    prerequisite?: PrerequisiteOrderByWithRelationInput
  }

  export type LearningPathPrerequisiteWhereUniqueInput = Prisma.AtLeast<{
    learningPathId_prerequisiteId?: LearningPathPrerequisiteLearningPathIdPrerequisiteIdCompoundUniqueInput
    AND?: LearningPathPrerequisiteWhereInput | LearningPathPrerequisiteWhereInput[]
    OR?: LearningPathPrerequisiteWhereInput[]
    NOT?: LearningPathPrerequisiteWhereInput | LearningPathPrerequisiteWhereInput[]
    learningPathId?: StringFilter<"LearningPathPrerequisite"> | string
    prerequisiteId?: StringFilter<"LearningPathPrerequisite"> | string
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    prerequisite?: XOR<PrerequisiteScalarRelationFilter, PrerequisiteWhereInput>
  }, "learningPathId_prerequisiteId">

  export type LearningPathPrerequisiteOrderByWithAggregationInput = {
    learningPathId?: SortOrder
    prerequisiteId?: SortOrder
    _count?: LearningPathPrerequisiteCountOrderByAggregateInput
    _max?: LearningPathPrerequisiteMaxOrderByAggregateInput
    _min?: LearningPathPrerequisiteMinOrderByAggregateInput
  }

  export type LearningPathPrerequisiteScalarWhereWithAggregatesInput = {
    AND?: LearningPathPrerequisiteScalarWhereWithAggregatesInput | LearningPathPrerequisiteScalarWhereWithAggregatesInput[]
    OR?: LearningPathPrerequisiteScalarWhereWithAggregatesInput[]
    NOT?: LearningPathPrerequisiteScalarWhereWithAggregatesInput | LearningPathPrerequisiteScalarWhereWithAggregatesInput[]
    learningPathId?: StringWithAggregatesFilter<"LearningPathPrerequisite"> | string
    prerequisiteId?: StringWithAggregatesFilter<"LearningPathPrerequisite"> | string
  }

  export type FeatureWhereInput = {
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    id?: StringFilter<"Feature"> | string
    title?: StringFilter<"Feature"> | string
    desc?: StringFilter<"Feature"> | string
    color?: StringNullableFilter<"Feature"> | string | null
    iconName?: StringNullableFilter<"Feature"> | string | null
    iconLib?: StringNullableFilter<"Feature"> | string | null
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
  }

  export type FeatureOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    color?: SortOrderInput | SortOrder
    iconName?: SortOrderInput | SortOrder
    iconLib?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    desc?: StringFilter<"Feature"> | string
    color?: StringNullableFilter<"Feature"> | string | null
    iconName?: StringNullableFilter<"Feature"> | string | null
    iconLib?: StringNullableFilter<"Feature"> | string | null
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
  }, "id" | "title">

  export type FeatureOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    color?: SortOrderInput | SortOrder
    iconName?: SortOrderInput | SortOrder
    iconLib?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeatureCountOrderByAggregateInput
    _max?: FeatureMaxOrderByAggregateInput
    _min?: FeatureMinOrderByAggregateInput
  }

  export type FeatureScalarWhereWithAggregatesInput = {
    AND?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    OR?: FeatureScalarWhereWithAggregatesInput[]
    NOT?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feature"> | string
    title?: StringWithAggregatesFilter<"Feature"> | string
    desc?: StringWithAggregatesFilter<"Feature"> | string
    color?: StringNullableWithAggregatesFilter<"Feature"> | string | null
    iconName?: StringNullableWithAggregatesFilter<"Feature"> | string | null
    iconLib?: StringNullableWithAggregatesFilter<"Feature"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Feature"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feature"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    address?: StringFilter<"Company"> | string
    postalCode?: StringFilter<"Company"> | string
    city?: StringFilter<"Company"> | string
    country?: StringFilter<"Company"> | string
    email?: StringFilter<"Company"> | string
    phone?: StringNullableFilter<"Company"> | string | null
    siret?: StringNullableFilter<"Company"> | string | null
    vatNumber?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    companySocialLink?: CompanySocialLinkListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    country?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    siret?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companySocialLink?: CompanySocialLinkOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    address?: StringFilter<"Company"> | string
    postalCode?: StringFilter<"Company"> | string
    city?: StringFilter<"Company"> | string
    country?: StringFilter<"Company"> | string
    email?: StringFilter<"Company"> | string
    phone?: StringNullableFilter<"Company"> | string | null
    siret?: StringNullableFilter<"Company"> | string | null
    vatNumber?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    companySocialLink?: CompanySocialLinkListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    country?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    siret?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    address?: StringWithAggregatesFilter<"Company"> | string
    postalCode?: StringWithAggregatesFilter<"Company"> | string
    city?: StringWithAggregatesFilter<"Company"> | string
    country?: StringWithAggregatesFilter<"Company"> | string
    email?: StringWithAggregatesFilter<"Company"> | string
    phone?: StringNullableWithAggregatesFilter<"Company"> | string | null
    siret?: StringNullableWithAggregatesFilter<"Company"> | string | null
    vatNumber?: StringNullableWithAggregatesFilter<"Company"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Company"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type SocialLinkWhereInput = {
    AND?: SocialLinkWhereInput | SocialLinkWhereInput[]
    OR?: SocialLinkWhereInput[]
    NOT?: SocialLinkWhereInput | SocialLinkWhereInput[]
    id?: StringFilter<"SocialLink"> | string
    name?: StringFilter<"SocialLink"> | string
    iconLib?: StringFilter<"SocialLink"> | string
    iconName?: StringFilter<"SocialLink"> | string
    createdAt?: DateTimeFilter<"SocialLink"> | Date | string
    updatedAt?: DateTimeFilter<"SocialLink"> | Date | string
    companySocialLink?: CompanySocialLinkListRelationFilter
  }

  export type SocialLinkOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    iconLib?: SortOrder
    iconName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companySocialLink?: CompanySocialLinkOrderByRelationAggregateInput
  }

  export type SocialLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SocialLinkWhereInput | SocialLinkWhereInput[]
    OR?: SocialLinkWhereInput[]
    NOT?: SocialLinkWhereInput | SocialLinkWhereInput[]
    name?: StringFilter<"SocialLink"> | string
    iconLib?: StringFilter<"SocialLink"> | string
    iconName?: StringFilter<"SocialLink"> | string
    createdAt?: DateTimeFilter<"SocialLink"> | Date | string
    updatedAt?: DateTimeFilter<"SocialLink"> | Date | string
    companySocialLink?: CompanySocialLinkListRelationFilter
  }, "id">

  export type SocialLinkOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    iconLib?: SortOrder
    iconName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocialLinkCountOrderByAggregateInput
    _max?: SocialLinkMaxOrderByAggregateInput
    _min?: SocialLinkMinOrderByAggregateInput
  }

  export type SocialLinkScalarWhereWithAggregatesInput = {
    AND?: SocialLinkScalarWhereWithAggregatesInput | SocialLinkScalarWhereWithAggregatesInput[]
    OR?: SocialLinkScalarWhereWithAggregatesInput[]
    NOT?: SocialLinkScalarWhereWithAggregatesInput | SocialLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialLink"> | string
    name?: StringWithAggregatesFilter<"SocialLink"> | string
    iconLib?: StringWithAggregatesFilter<"SocialLink"> | string
    iconName?: StringWithAggregatesFilter<"SocialLink"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SocialLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SocialLink"> | Date | string
  }

  export type CompanySocialLinkWhereInput = {
    AND?: CompanySocialLinkWhereInput | CompanySocialLinkWhereInput[]
    OR?: CompanySocialLinkWhereInput[]
    NOT?: CompanySocialLinkWhereInput | CompanySocialLinkWhereInput[]
    id?: StringFilter<"CompanySocialLink"> | string
    companyId?: StringFilter<"CompanySocialLink"> | string
    socialLinkId?: StringFilter<"CompanySocialLink"> | string
    url?: StringFilter<"CompanySocialLink"> | string
    createdAt?: DateTimeFilter<"CompanySocialLink"> | Date | string
    updatedAt?: DateTimeFilter<"CompanySocialLink"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    socialLink?: XOR<SocialLinkScalarRelationFilter, SocialLinkWhereInput>
  }

  export type CompanySocialLinkOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    socialLinkId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    socialLink?: SocialLinkOrderByWithRelationInput
  }

  export type CompanySocialLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_socialLinkId?: CompanySocialLinkCompanyIdSocialLinkIdCompoundUniqueInput
    AND?: CompanySocialLinkWhereInput | CompanySocialLinkWhereInput[]
    OR?: CompanySocialLinkWhereInput[]
    NOT?: CompanySocialLinkWhereInput | CompanySocialLinkWhereInput[]
    companyId?: StringFilter<"CompanySocialLink"> | string
    socialLinkId?: StringFilter<"CompanySocialLink"> | string
    url?: StringFilter<"CompanySocialLink"> | string
    createdAt?: DateTimeFilter<"CompanySocialLink"> | Date | string
    updatedAt?: DateTimeFilter<"CompanySocialLink"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    socialLink?: XOR<SocialLinkScalarRelationFilter, SocialLinkWhereInput>
  }, "id" | "companyId_socialLinkId">

  export type CompanySocialLinkOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    socialLinkId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanySocialLinkCountOrderByAggregateInput
    _max?: CompanySocialLinkMaxOrderByAggregateInput
    _min?: CompanySocialLinkMinOrderByAggregateInput
  }

  export type CompanySocialLinkScalarWhereWithAggregatesInput = {
    AND?: CompanySocialLinkScalarWhereWithAggregatesInput | CompanySocialLinkScalarWhereWithAggregatesInput[]
    OR?: CompanySocialLinkScalarWhereWithAggregatesInput[]
    NOT?: CompanySocialLinkScalarWhereWithAggregatesInput | CompanySocialLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanySocialLink"> | string
    companyId?: StringWithAggregatesFilter<"CompanySocialLink"> | string
    socialLinkId?: StringWithAggregatesFilter<"CompanySocialLink"> | string
    url?: StringWithAggregatesFilter<"CompanySocialLink"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CompanySocialLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanySocialLink"> | Date | string
  }

  export type PageWhereInput = {
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    id?: StringFilter<"Page"> | string
    title?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    content?: StringFilter<"Page"> | string
    type?: StringFilter<"Page"> | string
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
  }

  export type PageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    slug?: string
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    content?: StringFilter<"Page"> | string
    type?: StringFilter<"Page"> | string
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
  }, "id" | "title" | "slug">

  export type PageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PageCountOrderByAggregateInput
    _max?: PageMaxOrderByAggregateInput
    _min?: PageMinOrderByAggregateInput
  }

  export type PageScalarWhereWithAggregatesInput = {
    AND?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    OR?: PageScalarWhereWithAggregatesInput[]
    NOT?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Page"> | string
    title?: StringWithAggregatesFilter<"Page"> | string
    slug?: StringWithAggregatesFilter<"Page"> | string
    content?: StringWithAggregatesFilter<"Page"> | string
    type?: StringWithAggregatesFilter<"Page"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
  }

  export type QuizWhereInput = {
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    id?: StringFilter<"Quiz"> | string
    title?: StringFilter<"Quiz"> | string
    slug?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    type?: StringNullableFilter<"Quiz"> | string | null
    chapterId?: StringNullableFilter<"Quiz"> | string | null
    courseId?: StringNullableFilter<"Quiz"> | string | null
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    userId?: StringNullableFilter<"Quiz"> | string | null
    questions?: QuizQuestionListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type QuizOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    chapterId?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    questions?: QuizQuestionOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type QuizWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    title?: StringFilter<"Quiz"> | string
    slug?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    type?: StringNullableFilter<"Quiz"> | string | null
    chapterId?: StringNullableFilter<"Quiz"> | string | null
    courseId?: StringNullableFilter<"Quiz"> | string | null
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    userId?: StringNullableFilter<"Quiz"> | string | null
    questions?: QuizQuestionListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type QuizOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    chapterId?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: QuizCountOrderByAggregateInput
    _max?: QuizMaxOrderByAggregateInput
    _min?: QuizMinOrderByAggregateInput
  }

  export type QuizScalarWhereWithAggregatesInput = {
    AND?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    OR?: QuizScalarWhereWithAggregatesInput[]
    NOT?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quiz"> | string
    title?: StringWithAggregatesFilter<"Quiz"> | string
    slug?: StringWithAggregatesFilter<"Quiz"> | string
    description?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    type?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    chapterId?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    courseId?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
  }

  export type QuizQuestionWhereInput = {
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    id?: StringFilter<"QuizQuestion"> | string
    question?: StringFilter<"QuizQuestion"> | string
    type?: StringNullableFilter<"QuizQuestion"> | string | null
    quizId?: StringFilter<"QuizQuestion"> | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    options?: QuizOptionListRelationFilter
  }

  export type QuizQuestionOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrderInput | SortOrder
    quizId?: SortOrder
    quiz?: QuizOrderByWithRelationInput
    options?: QuizOptionOrderByRelationAggregateInput
  }

  export type QuizQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    question?: StringFilter<"QuizQuestion"> | string
    type?: StringNullableFilter<"QuizQuestion"> | string | null
    quizId?: StringFilter<"QuizQuestion"> | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    options?: QuizOptionListRelationFilter
  }, "id">

  export type QuizQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrderInput | SortOrder
    quizId?: SortOrder
    _count?: QuizQuestionCountOrderByAggregateInput
    _max?: QuizQuestionMaxOrderByAggregateInput
    _min?: QuizQuestionMinOrderByAggregateInput
  }

  export type QuizQuestionScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizQuestion"> | string
    question?: StringWithAggregatesFilter<"QuizQuestion"> | string
    type?: StringNullableWithAggregatesFilter<"QuizQuestion"> | string | null
    quizId?: StringWithAggregatesFilter<"QuizQuestion"> | string
  }

  export type QuizOptionWhereInput = {
    AND?: QuizOptionWhereInput | QuizOptionWhereInput[]
    OR?: QuizOptionWhereInput[]
    NOT?: QuizOptionWhereInput | QuizOptionWhereInput[]
    id?: StringFilter<"QuizOption"> | string
    content?: StringFilter<"QuizOption"> | string
    isCorrect?: BoolFilter<"QuizOption"> | boolean
    questionId?: StringFilter<"QuizOption"> | string
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
  }

  export type QuizOptionOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    isCorrect?: SortOrder
    questionId?: SortOrder
    question?: QuizQuestionOrderByWithRelationInput
  }

  export type QuizOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizOptionWhereInput | QuizOptionWhereInput[]
    OR?: QuizOptionWhereInput[]
    NOT?: QuizOptionWhereInput | QuizOptionWhereInput[]
    content?: StringFilter<"QuizOption"> | string
    isCorrect?: BoolFilter<"QuizOption"> | boolean
    questionId?: StringFilter<"QuizOption"> | string
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
  }, "id">

  export type QuizOptionOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    isCorrect?: SortOrder
    questionId?: SortOrder
    _count?: QuizOptionCountOrderByAggregateInput
    _max?: QuizOptionMaxOrderByAggregateInput
    _min?: QuizOptionMinOrderByAggregateInput
  }

  export type QuizOptionScalarWhereWithAggregatesInput = {
    AND?: QuizOptionScalarWhereWithAggregatesInput | QuizOptionScalarWhereWithAggregatesInput[]
    OR?: QuizOptionScalarWhereWithAggregatesInput[]
    NOT?: QuizOptionScalarWhereWithAggregatesInput | QuizOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizOption"> | string
    content?: StringWithAggregatesFilter<"QuizOption"> | string
    isCorrect?: BoolWithAggregatesFilter<"QuizOption"> | boolean
    questionId?: StringWithAggregatesFilter<"QuizOption"> | string
  }

  export type QuizResultWhereInput = {
    AND?: QuizResultWhereInput | QuizResultWhereInput[]
    OR?: QuizResultWhereInput[]
    NOT?: QuizResultWhereInput | QuizResultWhereInput[]
    id?: StringFilter<"QuizResult"> | string
    userId?: StringFilter<"QuizResult"> | string
    quizId?: StringFilter<"QuizResult"> | string
    score?: FloatFilter<"QuizResult"> | number
    passed?: BoolFilter<"QuizResult"> | boolean
    createdAt?: DateTimeFilter<"QuizResult"> | Date | string
    updatedAt?: DateTimeFilter<"QuizResult"> | Date | string
  }

  export type QuizResultOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizResultWhereInput | QuizResultWhereInput[]
    OR?: QuizResultWhereInput[]
    NOT?: QuizResultWhereInput | QuizResultWhereInput[]
    userId?: StringFilter<"QuizResult"> | string
    quizId?: StringFilter<"QuizResult"> | string
    score?: FloatFilter<"QuizResult"> | number
    passed?: BoolFilter<"QuizResult"> | boolean
    createdAt?: DateTimeFilter<"QuizResult"> | Date | string
    updatedAt?: DateTimeFilter<"QuizResult"> | Date | string
  }, "id">

  export type QuizResultOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizResultCountOrderByAggregateInput
    _avg?: QuizResultAvgOrderByAggregateInput
    _max?: QuizResultMaxOrderByAggregateInput
    _min?: QuizResultMinOrderByAggregateInput
    _sum?: QuizResultSumOrderByAggregateInput
  }

  export type QuizResultScalarWhereWithAggregatesInput = {
    AND?: QuizResultScalarWhereWithAggregatesInput | QuizResultScalarWhereWithAggregatesInput[]
    OR?: QuizResultScalarWhereWithAggregatesInput[]
    NOT?: QuizResultScalarWhereWithAggregatesInput | QuizResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizResult"> | string
    userId?: StringWithAggregatesFilter<"QuizResult"> | string
    quizId?: StringWithAggregatesFilter<"QuizResult"> | string
    score?: FloatWithAggregatesFilter<"QuizResult"> | number
    passed?: BoolWithAggregatesFilter<"QuizResult"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"QuizResult"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuizResult"> | Date | string
  }

  export type TestimonialWhereInput = {
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    id?: StringFilter<"Testimonial"> | string
    userId?: StringFilter<"Testimonial"> | string
    rating?: IntFilter<"Testimonial"> | number
    text?: StringFilter<"Testimonial"> | string
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
  }

  export type TestimonialOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    rating?: IntFilter<"Testimonial"> | number
    text?: StringFilter<"Testimonial"> | string
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
  }, "id" | "userId">

  export type TestimonialOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestimonialCountOrderByAggregateInput
    _avg?: TestimonialAvgOrderByAggregateInput
    _max?: TestimonialMaxOrderByAggregateInput
    _min?: TestimonialMinOrderByAggregateInput
    _sum?: TestimonialSumOrderByAggregateInput
  }

  export type TestimonialScalarWhereWithAggregatesInput = {
    AND?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    OR?: TestimonialScalarWhereWithAggregatesInput[]
    NOT?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Testimonial"> | string
    userId?: StringWithAggregatesFilter<"Testimonial"> | string
    rating?: IntWithAggregatesFilter<"Testimonial"> | number
    text?: StringWithAggregatesFilter<"Testimonial"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
  }

  export type NewsletterSubscriptionWhereInput = {
    AND?: NewsletterSubscriptionWhereInput | NewsletterSubscriptionWhereInput[]
    OR?: NewsletterSubscriptionWhereInput[]
    NOT?: NewsletterSubscriptionWhereInput | NewsletterSubscriptionWhereInput[]
    id?: StringFilter<"NewsletterSubscription"> | string
    email?: StringFilter<"NewsletterSubscription"> | string
    name?: StringNullableFilter<"NewsletterSubscription"> | string | null
    createdAt?: DateTimeFilter<"NewsletterSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"NewsletterSubscription"> | Date | string
    confirmed?: BoolFilter<"NewsletterSubscription"> | boolean
  }

  export type NewsletterSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confirmed?: SortOrder
  }

  export type NewsletterSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: NewsletterSubscriptionWhereInput | NewsletterSubscriptionWhereInput[]
    OR?: NewsletterSubscriptionWhereInput[]
    NOT?: NewsletterSubscriptionWhereInput | NewsletterSubscriptionWhereInput[]
    name?: StringNullableFilter<"NewsletterSubscription"> | string | null
    createdAt?: DateTimeFilter<"NewsletterSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"NewsletterSubscription"> | Date | string
    confirmed?: BoolFilter<"NewsletterSubscription"> | boolean
  }, "id" | "email">

  export type NewsletterSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confirmed?: SortOrder
    _count?: NewsletterSubscriptionCountOrderByAggregateInput
    _max?: NewsletterSubscriptionMaxOrderByAggregateInput
    _min?: NewsletterSubscriptionMinOrderByAggregateInput
  }

  export type NewsletterSubscriptionScalarWhereWithAggregatesInput = {
    AND?: NewsletterSubscriptionScalarWhereWithAggregatesInput | NewsletterSubscriptionScalarWhereWithAggregatesInput[]
    OR?: NewsletterSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: NewsletterSubscriptionScalarWhereWithAggregatesInput | NewsletterSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsletterSubscription"> | string
    email?: StringWithAggregatesFilter<"NewsletterSubscription"> | string
    name?: StringNullableWithAggregatesFilter<"NewsletterSubscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NewsletterSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NewsletterSubscription"> | Date | string
    confirmed?: BoolWithAggregatesFilter<"NewsletterSubscription"> | boolean
  }

  export type UserCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    workshops?: WorkshopCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    quiz?: QuizCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    workshops?: WorkshopUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    quiz?: QuizUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    quiz?: QuizUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    quiz?: QuizUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
    impersonatedBy?: string | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
    impersonatedBy?: string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DomainCreateInput = {
    id?: string
    title: string
    slug: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categories?: CategoryCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: CategoryUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: CategoryUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainCreateManyInput = {
    id?: string
    title: string
    slug: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DomainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DomainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryCreateInput = {
    id?: string
    title: string
    slug: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    courses?: CourseCreateNestedManyWithoutCategoryInput
    domain: DomainCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domainId: string
    deletedAt?: Date | string | null
    courses?: CourseUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: CourseUpdateManyWithoutCategoryNestedInput
    domain?: DomainUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: CourseUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    title: string
    slug: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domainId: string
    deletedAt?: Date | string | null
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningPathCreateInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLearningPathsInput
    tags?: LearningPathTagCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearningPathInput
    payments?: PaymentCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: LearningPathTagUncheckedCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceUncheckedCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearningPathInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLearningPathsNestedInput
    tags?: LearningPathTagUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: LearningPathTagUncheckedUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUncheckedUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathCreateManyInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
  }

  export type LearningPathUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningPathUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningPathItemCreateInput = {
    id?: string
    type: string
    position: number
    learningPath: LearningPathCreateNestedOneWithoutContentsInput
    course?: CourseCreateNestedOneWithoutLearningPathItemsInput
    workshop?: WorkshopCreateNestedOneWithoutLearningPathItemsInput
    resource?: ResourceCreateNestedOneWithoutLearningPathItemsInput
  }

  export type LearningPathItemUncheckedCreateInput = {
    id?: string
    type: string
    position: number
    learningPathId: string
    courseId?: string | null
    workshopId?: string | null
    resourceId?: string | null
  }

  export type LearningPathItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    learningPath?: LearningPathUpdateOneRequiredWithoutContentsNestedInput
    course?: CourseUpdateOneWithoutLearningPathItemsNestedInput
    workshop?: WorkshopUpdateOneWithoutLearningPathItemsNestedInput
    resource?: ResourceUpdateOneWithoutLearningPathItemsNestedInput
  }

  export type LearningPathItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LearningPathItemCreateManyInput = {
    id?: string
    type: string
    position: number
    learningPathId: string
    courseId?: string | null
    workshopId?: string | null
    resourceId?: string | null
  }

  export type LearningPathItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type LearningPathItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseCreateInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCoursesInput
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    category: CategoryCreateNestedOneWithoutCoursesInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    promotions?: PromotionCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    progress?: UserProgressCreateNestedManyWithoutCourseInput
    resources?: CourseResourceCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    categoryId: string
    deletedAt?: Date | string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutCourseInput
    resources?: CourseResourceUncheckedCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCoursesNestedInput
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUncheckedUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    categoryId: string
    deletedAt?: Date | string | null
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChapterCreateInput = {
    id?: string
    title: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutChaptersInput
    lessons?: LessonCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateInput = {
    id?: string
    title: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutChaptersNestedInput
    lessons?: LessonUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterCreateManyInput = {
    id?: string
    title: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId: string
  }

  export type ChapterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonCreateInput = {
    id?: string
    title: string
    description?: string | null
    thumbnailKey?: string | null
    videoKey?: string | null
    position: number
    duration?: number
    public?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutLessonsInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutLessonInput
    resources?: LessonResourceCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    thumbnailKey?: string | null
    videoKey?: string | null
    position: number
    duration?: number
    public?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chapterId: string
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
    resources?: LessonResourceUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailKey?: NullableStringFieldUpdateOperationsInput | string | null
    videoKey?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutLessonsNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutLessonNestedInput
    resources?: LessonResourceUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailKey?: NullableStringFieldUpdateOperationsInput | string | null
    videoKey?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapterId?: StringFieldUpdateOperationsInput | string
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    resources?: LessonResourceUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    thumbnailKey?: string | null
    videoKey?: string | null
    position: number
    duration?: number
    public?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chapterId: string
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailKey?: NullableStringFieldUpdateOperationsInput | string | null
    videoKey?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailKey?: NullableStringFieldUpdateOperationsInput | string | null
    videoKey?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapterId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopCreateInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutWorkshopsInput
    tags?: WorkshopTagCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentCreateNestedManyWithoutWorkshopInput
    payments?: PaymentCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: WorkshopTagUncheckedCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceUncheckedCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveUncheckedCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutWorkshopInput
    payments?: PaymentUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutWorkshopsNestedInput
    tags?: WorkshopTagUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: WorkshopTagUncheckedUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUncheckedUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopCreateManyInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
  }

  export type WorkshopUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkshopUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResourceCreateInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    courseResources?: CourseResourceCreateNestedManyWithoutResourceInput
    lessonResources?: LessonResourceCreateNestedManyWithoutResourceInput
    workshopResources?: WorkshopResourceCreateNestedManyWithoutResourceInput
    learningPathResources?: LearningPathResourceCreateNestedManyWithoutResourceInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutResourceInput
    user?: UserCreateNestedOneWithoutResourcesInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    userId: string
    courseResources?: CourseResourceUncheckedCreateNestedManyWithoutResourceInput
    lessonResources?: LessonResourceUncheckedCreateNestedManyWithoutResourceInput
    workshopResources?: WorkshopResourceUncheckedCreateNestedManyWithoutResourceInput
    learningPathResources?: LearningPathResourceUncheckedCreateNestedManyWithoutResourceInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseResources?: CourseResourceUpdateManyWithoutResourceNestedInput
    lessonResources?: LessonResourceUpdateManyWithoutResourceNestedInput
    workshopResources?: WorkshopResourceUpdateManyWithoutResourceNestedInput
    learningPathResources?: LearningPathResourceUpdateManyWithoutResourceNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutResourceNestedInput
    user?: UserUpdateOneWithoutResourcesNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    courseResources?: CourseResourceUncheckedUpdateManyWithoutResourceNestedInput
    lessonResources?: LessonResourceUncheckedUpdateManyWithoutResourceNestedInput
    workshopResources?: WorkshopResourceUncheckedUpdateManyWithoutResourceNestedInput
    learningPathResources?: LearningPathResourceUncheckedUpdateManyWithoutResourceNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    userId: string
  }

  export type ResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathResourceCreateInput = {
    learningPath: LearningPathCreateNestedOneWithoutResourcesInput
    resource: ResourceCreateNestedOneWithoutLearningPathResourcesInput
  }

  export type LearningPathResourceUncheckedCreateInput = {
    learningPathId: string
    resourceId: string
  }

  export type LearningPathResourceUpdateInput = {
    learningPath?: LearningPathUpdateOneRequiredWithoutResourcesNestedInput
    resource?: ResourceUpdateOneRequiredWithoutLearningPathResourcesNestedInput
  }

  export type LearningPathResourceUncheckedUpdateInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathResourceCreateManyInput = {
    learningPathId: string
    resourceId: string
  }

  export type LearningPathResourceUpdateManyMutationInput = {

  }

  export type LearningPathResourceUncheckedUpdateManyInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseResourceCreateInput = {
    course: CourseCreateNestedOneWithoutResourcesInput
    resource: ResourceCreateNestedOneWithoutCourseResourcesInput
  }

  export type CourseResourceUncheckedCreateInput = {
    courseId: string
    resourceId: string
  }

  export type CourseResourceUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutResourcesNestedInput
    resource?: ResourceUpdateOneRequiredWithoutCourseResourcesNestedInput
  }

  export type CourseResourceUncheckedUpdateInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseResourceCreateManyInput = {
    courseId: string
    resourceId: string
  }

  export type CourseResourceUpdateManyMutationInput = {

  }

  export type CourseResourceUncheckedUpdateManyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonResourceCreateInput = {
    lesson: LessonCreateNestedOneWithoutResourcesInput
    resource: ResourceCreateNestedOneWithoutLessonResourcesInput
  }

  export type LessonResourceUncheckedCreateInput = {
    lessonId: string
    resourceId: string
  }

  export type LessonResourceUpdateInput = {
    lesson?: LessonUpdateOneRequiredWithoutResourcesNestedInput
    resource?: ResourceUpdateOneRequiredWithoutLessonResourcesNestedInput
  }

  export type LessonResourceUncheckedUpdateInput = {
    lessonId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonResourceCreateManyInput = {
    lessonId: string
    resourceId: string
  }

  export type LessonResourceUpdateManyMutationInput = {

  }

  export type LessonResourceUncheckedUpdateManyInput = {
    lessonId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopResourceCreateInput = {
    workshop: WorkshopCreateNestedOneWithoutResourcesInput
    resource: ResourceCreateNestedOneWithoutWorkshopResourcesInput
  }

  export type WorkshopResourceUncheckedCreateInput = {
    workshopId: string
    resourceId: string
  }

  export type WorkshopResourceUpdateInput = {
    workshop?: WorkshopUpdateOneRequiredWithoutResourcesNestedInput
    resource?: ResourceUpdateOneRequiredWithoutWorkshopResourcesNestedInput
  }

  export type WorkshopResourceUncheckedUpdateInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopResourceCreateManyInput = {
    workshopId: string
    resourceId: string
  }

  export type WorkshopResourceUpdateManyMutationInput = {

  }

  export type WorkshopResourceUncheckedUpdateManyInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonProgressCreateInput = {
    id?: string
    completed?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    watchedSeconds?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLessonProgressInput
    Lesson: LessonCreateNestedOneWithoutLessonProgressInput
  }

  export type LessonProgressUncheckedCreateInput = {
    id?: string
    completed?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    watchedSeconds?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    lessonId: string
  }

  export type LessonProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLessonProgressNestedInput
    Lesson?: LessonUpdateOneRequiredWithoutLessonProgressNestedInput
  }

  export type LessonProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonProgressCreateManyInput = {
    id?: string
    completed?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    watchedSeconds?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    lessonId: string
  }

  export type LessonProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
  }

  export type UserProgressCreateInput = {
    id?: string
    userId: string
    type: string
    completed?: boolean
    updatedAt?: Date | string
    progressPercentage?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    timeSpent?: number | null
    course?: CourseCreateNestedOneWithoutProgressInput
    workshop?: WorkshopCreateNestedOneWithoutProgressInput
    path?: LearningPathCreateNestedOneWithoutProgressInput
  }

  export type UserProgressUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    itemId: string
    completed?: boolean
    updatedAt?: Date | string
    progressPercentage?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type UserProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    course?: CourseUpdateOneWithoutProgressNestedInput
    workshop?: WorkshopUpdateOneWithoutProgressNestedInput
    path?: LearningPathUpdateOneWithoutProgressNestedInput
  }

  export type UserProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserProgressCreateManyInput = {
    id?: string
    userId: string
    type: string
    itemId: string
    completed?: boolean
    updatedAt?: Date | string
    progressPercentage?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type UserProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TagCreateInput = {
    id?: string
    title: string
    slug: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseTags?: CourseTagCreateNestedManyWithoutTagInput
    workshopTags?: WorkshopTagCreateNestedManyWithoutTagInput
    learningPathTags?: LearningPathTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseTags?: CourseTagUncheckedCreateNestedManyWithoutTagInput
    workshopTags?: WorkshopTagUncheckedCreateNestedManyWithoutTagInput
    learningPathTags?: LearningPathTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseTags?: CourseTagUpdateManyWithoutTagNestedInput
    workshopTags?: WorkshopTagUpdateManyWithoutTagNestedInput
    learningPathTags?: LearningPathTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseTags?: CourseTagUncheckedUpdateManyWithoutTagNestedInput
    workshopTags?: WorkshopTagUncheckedUpdateManyWithoutTagNestedInput
    learningPathTags?: LearningPathTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    title: string
    slug: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseTagCreateInput = {
    course: CourseCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutCourseTagsInput
  }

  export type CourseTagUncheckedCreateInput = {
    courseId: string
    tagId: string
  }

  export type CourseTagUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutCourseTagsNestedInput
  }

  export type CourseTagUncheckedUpdateInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTagCreateManyInput = {
    courseId: string
    tagId: string
  }

  export type CourseTagUpdateManyMutationInput = {

  }

  export type CourseTagUncheckedUpdateManyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopTagCreateInput = {
    workshop: WorkshopCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutWorkshopTagsInput
  }

  export type WorkshopTagUncheckedCreateInput = {
    workshopId: string
    tagId: string
  }

  export type WorkshopTagUpdateInput = {
    workshop?: WorkshopUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutWorkshopTagsNestedInput
  }

  export type WorkshopTagUncheckedUpdateInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopTagCreateManyInput = {
    workshopId: string
    tagId: string
  }

  export type WorkshopTagUpdateManyMutationInput = {

  }

  export type WorkshopTagUncheckedUpdateManyInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathTagCreateInput = {
    learningPath: LearningPathCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutLearningPathTagsInput
  }

  export type LearningPathTagUncheckedCreateInput = {
    learningPathId: string
    tagId: string
  }

  export type LearningPathTagUpdateInput = {
    learningPath?: LearningPathUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutLearningPathTagsNestedInput
  }

  export type LearningPathTagUncheckedUpdateInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathTagCreateManyInput = {
    learningPathId: string
    tagId: string
  }

  export type LearningPathTagUpdateManyMutationInput = {

  }

  export type LearningPathTagUncheckedUpdateManyInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type PromotionCreateInput = {
    id?: string
    title: string
    description?: string | null
    discount: number
    type?: string
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    itemType: string
    course?: CourseCreateNestedOneWithoutPromotionsInput
    workshop?: WorkshopCreateNestedOneWithoutPromotionsInput
    learningPath?: LearningPathCreateNestedOneWithoutPromotionsInput
  }

  export type PromotionUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    discount: number
    type?: string
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    itemType: string
    courseId?: string | null
    workshopId?: string | null
    learningPathId?: string | null
  }

  export type PromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    itemType?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneWithoutPromotionsNestedInput
    workshop?: WorkshopUpdateOneWithoutPromotionsNestedInput
    learningPath?: LearningPathUpdateOneWithoutPromotionsNestedInput
  }

  export type PromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    itemType?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    discount: number
    type?: string
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    itemType: string
    courseId?: string | null
    workshopId?: string | null
    learningPathId?: string | null
  }

  export type PromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    itemType?: StringFieldUpdateOperationsInput | string
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    itemType?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromoCodeCreateInput = {
    id?: string
    code: string
    description?: string | null
    discount: number
    type?: string
    usageLimit?: number | null
    usedCount?: number
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    applicableCourses?: CourseCreateNestedManyWithoutPromoCodesInput
    applicableWorkshops?: WorkshopCreateNestedManyWithoutPromoCodesInput
    applicableLearningPaths?: LearningPathCreateNestedManyWithoutPromoCodesInput
  }

  export type PromoCodeUncheckedCreateInput = {
    id?: string
    code: string
    description?: string | null
    discount: number
    type?: string
    usageLimit?: number | null
    usedCount?: number
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    applicableCourses?: CourseUncheckedCreateNestedManyWithoutPromoCodesInput
    applicableWorkshops?: WorkshopUncheckedCreateNestedManyWithoutPromoCodesInput
    applicableLearningPaths?: LearningPathUncheckedCreateNestedManyWithoutPromoCodesInput
  }

  export type PromoCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    applicableCourses?: CourseUpdateManyWithoutPromoCodesNestedInput
    applicableWorkshops?: WorkshopUpdateManyWithoutPromoCodesNestedInput
    applicableLearningPaths?: LearningPathUpdateManyWithoutPromoCodesNestedInput
  }

  export type PromoCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    applicableCourses?: CourseUncheckedUpdateManyWithoutPromoCodesNestedInput
    applicableWorkshops?: WorkshopUncheckedUpdateManyWithoutPromoCodesNestedInput
    applicableLearningPaths?: LearningPathUncheckedUpdateManyWithoutPromoCodesNestedInput
  }

  export type PromoCodeCreateManyInput = {
    id?: string
    code: string
    description?: string | null
    discount: number
    type?: string
    usageLimit?: number | null
    usedCount?: number
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
  }

  export type PromoCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromoCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EnrollmentCreateInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    course?: CourseCreateNestedOneWithoutEnrollmentsInput
    learningPath?: LearningPathCreateNestedOneWithoutEnrollmentsInput
    workshop?: WorkshopCreateNestedOneWithoutEnrollmentsInput
    user: UserCreateNestedOneWithoutEnrollmentInput
    payment?: PaymentCreateNestedOneWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: string | null
    learningPathId?: string | null
    workshopId?: string | null
    userId: string
    paymentId?: string | null
    deletedAt?: Date | string | null
  }

  export type EnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneWithoutEnrollmentsNestedInput
    learningPath?: LearningPathUpdateOneWithoutEnrollmentsNestedInput
    workshop?: WorkshopUpdateOneWithoutEnrollmentsNestedInput
    user?: UserUpdateOneRequiredWithoutEnrollmentNestedInput
    payment?: PaymentUpdateOneWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentCreateManyInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: string | null
    learningPathId?: string | null
    workshopId?: string | null
    userId: string
    paymentId?: string | null
    deletedAt?: Date | string | null
  }

  export type EnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentCreateInput = {
    id?: string
    stripeId: string
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPaymentsInput
    course?: CourseCreateNestedOneWithoutPaymentsInput
    learningPath?: LearningPathCreateNestedOneWithoutPaymentsInput
    workshop?: WorkshopCreateNestedOneWithoutPaymentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    stripeId: string
    userId: string
    courseId?: string | null
    learningPathId?: string | null
    workshopId?: string | null
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    enrollment?: EnrollmentUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    course?: CourseUpdateOneWithoutPaymentsNestedInput
    learningPath?: LearningPathUpdateOneWithoutPaymentsNestedInput
    workshop?: WorkshopUpdateOneWithoutPaymentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollment?: EnrollmentUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    stripeId: string
    userId: string
    courseId?: string | null
    learningPathId?: string | null
    workshopId?: string | null
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceCreateInput = {
    id?: string
    number: string
    amount: number
    currency?: string
    pdfUrl?: string | null
    date?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    number: string
    userId: string
    amount: number
    currency?: string
    pdfUrl?: string | null
    date?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    number: string
    userId: string
    amount: number
    currency?: string
    pdfUrl?: string | null
    date?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceItemCreateInput = {
    id?: string
    title: string
    type: string
    referenceId: string
    quantity?: number
    unitPrice: number
    total: number
    invoice: InvoiceCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    title: string
    type: string
    referenceId: string
    quantity?: number
    unitPrice: number
    total: number
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    referenceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    referenceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    title: string
    type: string
    referenceId: string
    quantity?: number
    unitPrice: number
    total: number
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    referenceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    referenceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectiveCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    courses?: CourseObjectiveCreateNestedManyWithoutObjectiveInput
    workshops?: WorkshopObjectiveCreateNestedManyWithoutObjectiveInput
    learningPaths?: LearningPathObjectiveCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    courses?: CourseObjectiveUncheckedCreateNestedManyWithoutObjectiveInput
    workshops?: WorkshopObjectiveUncheckedCreateNestedManyWithoutObjectiveInput
    learningPaths?: LearningPathObjectiveUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseObjectiveUpdateManyWithoutObjectiveNestedInput
    workshops?: WorkshopObjectiveUpdateManyWithoutObjectiveNestedInput
    learningPaths?: LearningPathObjectiveUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseObjectiveUncheckedUpdateManyWithoutObjectiveNestedInput
    workshops?: WorkshopObjectiveUncheckedUpdateManyWithoutObjectiveNestedInput
    learningPaths?: LearningPathObjectiveUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
  }

  export type ObjectiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObjectiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrerequisiteCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    courses?: CoursePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    workshops?: WorkshopPrerequisiteCreateNestedManyWithoutPrerequisiteInput
    learningPaths?: LearningPathPrerequisiteCreateNestedManyWithoutPrerequisiteInput
  }

  export type PrerequisiteUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    courses?: CoursePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    workshops?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    learningPaths?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
  }

  export type PrerequisiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CoursePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    workshops?: WorkshopPrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    learningPaths?: LearningPathPrerequisiteUpdateManyWithoutPrerequisiteNestedInput
  }

  export type PrerequisiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CoursePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    workshops?: WorkshopPrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    learningPaths?: LearningPathPrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
  }

  export type PrerequisiteCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
  }

  export type PrerequisiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrerequisiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseObjectiveCreateInput = {
    course: CourseCreateNestedOneWithoutObjectivesInput
    objective: ObjectiveCreateNestedOneWithoutCoursesInput
  }

  export type CourseObjectiveUncheckedCreateInput = {
    courseId: string
    objectiveId: string
  }

  export type CourseObjectiveUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutObjectivesNestedInput
    objective?: ObjectiveUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseObjectiveUncheckedUpdateInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseObjectiveCreateManyInput = {
    courseId: string
    objectiveId: string
  }

  export type CourseObjectiveUpdateManyMutationInput = {

  }

  export type CourseObjectiveUncheckedUpdateManyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
  }

  export type CoursePrerequisiteCreateInput = {
    course: CourseCreateNestedOneWithoutPrerequisitesInput
    prerequisite: PrerequisiteCreateNestedOneWithoutCoursesInput
  }

  export type CoursePrerequisiteUncheckedCreateInput = {
    courseId: string
    prerequisiteId: string
  }

  export type CoursePrerequisiteUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutPrerequisitesNestedInput
    prerequisite?: PrerequisiteUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CoursePrerequisiteUncheckedUpdateInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CoursePrerequisiteCreateManyInput = {
    courseId: string
    prerequisiteId: string
  }

  export type CoursePrerequisiteUpdateManyMutationInput = {

  }

  export type CoursePrerequisiteUncheckedUpdateManyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopObjectiveCreateInput = {
    workshop: WorkshopCreateNestedOneWithoutObjectivesInput
    objective: ObjectiveCreateNestedOneWithoutWorkshopsInput
  }

  export type WorkshopObjectiveUncheckedCreateInput = {
    workshopId: string
    objectiveId: string
  }

  export type WorkshopObjectiveUpdateInput = {
    workshop?: WorkshopUpdateOneRequiredWithoutObjectivesNestedInput
    objective?: ObjectiveUpdateOneRequiredWithoutWorkshopsNestedInput
  }

  export type WorkshopObjectiveUncheckedUpdateInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopObjectiveCreateManyInput = {
    workshopId: string
    objectiveId: string
  }

  export type WorkshopObjectiveUpdateManyMutationInput = {

  }

  export type WorkshopObjectiveUncheckedUpdateManyInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopPrerequisiteCreateInput = {
    workshop: WorkshopCreateNestedOneWithoutPrerequisitesInput
    prerequisite: PrerequisiteCreateNestedOneWithoutWorkshopsInput
  }

  export type WorkshopPrerequisiteUncheckedCreateInput = {
    workshopId: string
    prerequisiteId: string
  }

  export type WorkshopPrerequisiteUpdateInput = {
    workshop?: WorkshopUpdateOneRequiredWithoutPrerequisitesNestedInput
    prerequisite?: PrerequisiteUpdateOneRequiredWithoutWorkshopsNestedInput
  }

  export type WorkshopPrerequisiteUncheckedUpdateInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopPrerequisiteCreateManyInput = {
    workshopId: string
    prerequisiteId: string
  }

  export type WorkshopPrerequisiteUpdateManyMutationInput = {

  }

  export type WorkshopPrerequisiteUncheckedUpdateManyInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathObjectiveCreateInput = {
    learningPath: LearningPathCreateNestedOneWithoutObjectivesInput
    objective: ObjectiveCreateNestedOneWithoutLearningPathsInput
  }

  export type LearningPathObjectiveUncheckedCreateInput = {
    learningPathId: string
    objectiveId: string
  }

  export type LearningPathObjectiveUpdateInput = {
    learningPath?: LearningPathUpdateOneRequiredWithoutObjectivesNestedInput
    objective?: ObjectiveUpdateOneRequiredWithoutLearningPathsNestedInput
  }

  export type LearningPathObjectiveUncheckedUpdateInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathObjectiveCreateManyInput = {
    learningPathId: string
    objectiveId: string
  }

  export type LearningPathObjectiveUpdateManyMutationInput = {

  }

  export type LearningPathObjectiveUncheckedUpdateManyInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathPrerequisiteCreateInput = {
    learningPath: LearningPathCreateNestedOneWithoutPrerequisitesInput
    prerequisite: PrerequisiteCreateNestedOneWithoutLearningPathsInput
  }

  export type LearningPathPrerequisiteUncheckedCreateInput = {
    learningPathId: string
    prerequisiteId: string
  }

  export type LearningPathPrerequisiteUpdateInput = {
    learningPath?: LearningPathUpdateOneRequiredWithoutPrerequisitesNestedInput
    prerequisite?: PrerequisiteUpdateOneRequiredWithoutLearningPathsNestedInput
  }

  export type LearningPathPrerequisiteUncheckedUpdateInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathPrerequisiteCreateManyInput = {
    learningPathId: string
    prerequisiteId: string
  }

  export type LearningPathPrerequisiteUpdateManyMutationInput = {

  }

  export type LearningPathPrerequisiteUncheckedUpdateManyInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type FeatureCreateInput = {
    id?: string
    title: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureUncheckedCreateInput = {
    id?: string
    title: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureCreateManyInput = {
    id?: string
    title: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    address: string
    postalCode: string
    city: string
    country: string
    email: string
    phone?: string | null
    siret?: string | null
    vatNumber?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companySocialLink?: CompanySocialLinkCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    postalCode: string
    city: string
    country: string
    email: string
    phone?: string | null
    siret?: string | null
    vatNumber?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companySocialLink?: CompanySocialLinkUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companySocialLink?: CompanySocialLinkUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companySocialLink?: CompanySocialLinkUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    address: string
    postalCode: string
    city: string
    country: string
    email: string
    phone?: string | null
    siret?: string | null
    vatNumber?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialLinkCreateInput = {
    id?: string
    name: string
    iconLib: string
    iconName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companySocialLink?: CompanySocialLinkCreateNestedManyWithoutSocialLinkInput
  }

  export type SocialLinkUncheckedCreateInput = {
    id?: string
    name: string
    iconLib: string
    iconName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companySocialLink?: CompanySocialLinkUncheckedCreateNestedManyWithoutSocialLinkInput
  }

  export type SocialLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconLib?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companySocialLink?: CompanySocialLinkUpdateManyWithoutSocialLinkNestedInput
  }

  export type SocialLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconLib?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companySocialLink?: CompanySocialLinkUncheckedUpdateManyWithoutSocialLinkNestedInput
  }

  export type SocialLinkCreateManyInput = {
    id?: string
    name: string
    iconLib: string
    iconName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconLib?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconLib?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySocialLinkCreateInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCompanySocialLinkInput
    socialLink: SocialLinkCreateNestedOneWithoutCompanySocialLinkInput
  }

  export type CompanySocialLinkUncheckedCreateInput = {
    id?: string
    companyId: string
    socialLinkId: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanySocialLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCompanySocialLinkNestedInput
    socialLink?: SocialLinkUpdateOneRequiredWithoutCompanySocialLinkNestedInput
  }

  export type CompanySocialLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    socialLinkId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySocialLinkCreateManyInput = {
    id?: string
    companyId: string
    socialLinkId: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanySocialLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySocialLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    socialLinkId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageCreateManyInput = {
    id?: string
    title: string
    slug: string
    content: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type?: string | null
    chapterId?: string | null
    courseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    user?: UserCreateNestedOneWithoutQuizInput
  }

  export type QuizUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type?: string | null
    chapterId?: string | null
    courseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    user?: UserUpdateOneWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizCreateManyInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type?: string | null
    chapterId?: string | null
    courseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type QuizUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizQuestionCreateInput = {
    id?: string
    question: string
    type?: string | null
    quiz: QuizCreateNestedOneWithoutQuestionsInput
    options?: QuizOptionCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateInput = {
    id?: string
    question: string
    type?: string | null
    quizId: string
    options?: QuizOptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
    options?: QuizOptionUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quizId?: StringFieldUpdateOperationsInput | string
    options?: QuizOptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionCreateManyInput = {
    id?: string
    question: string
    type?: string | null
    quizId: string
  }

  export type QuizQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quizId?: StringFieldUpdateOperationsInput | string
  }

  export type QuizOptionCreateInput = {
    id?: string
    content: string
    isCorrect?: boolean
    question: QuizQuestionCreateNestedOneWithoutOptionsInput
  }

  export type QuizOptionUncheckedCreateInput = {
    id?: string
    content: string
    isCorrect?: boolean
    questionId: string
  }

  export type QuizOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    question?: QuizQuestionUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type QuizOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    questionId?: StringFieldUpdateOperationsInput | string
  }

  export type QuizOptionCreateManyInput = {
    id?: string
    content: string
    isCorrect?: boolean
    questionId: string
  }

  export type QuizOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuizOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    questionId?: StringFieldUpdateOperationsInput | string
  }

  export type QuizResultCreateInput = {
    id?: string
    userId: string
    quizId: string
    score: number
    passed: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizResultUncheckedCreateInput = {
    id?: string
    userId: string
    quizId: string
    score: number
    passed: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizResultCreateManyInput = {
    id?: string
    userId: string
    quizId: string
    score: number
    passed: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialCreateInput = {
    id?: string
    userId: string
    rating: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialUncheckedCreateInput = {
    id?: string
    userId: string
    rating: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialCreateManyInput = {
    id?: string
    userId: string
    rating: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterSubscriptionCreateInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmed?: boolean
  }

  export type NewsletterSubscriptionUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmed?: boolean
  }

  export type NewsletterSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NewsletterSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NewsletterSubscriptionCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmed?: boolean
  }

  export type NewsletterSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NewsletterSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type LessonProgressListRelationFilter = {
    every?: LessonProgressWhereInput
    some?: LessonProgressWhereInput
    none?: LessonProgressWhereInput
  }

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput
    some?: EnrollmentWhereInput
    none?: EnrollmentWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type LearningPathListRelationFilter = {
    every?: LearningPathWhereInput
    some?: LearningPathWhereInput
    none?: LearningPathWhereInput
  }

  export type WorkshopListRelationFilter = {
    every?: WorkshopWhereInput
    some?: WorkshopWhereInput
    none?: WorkshopWhereInput
  }

  export type ResourceListRelationFilter = {
    every?: ResourceWhereInput
    some?: ResourceWhereInput
    none?: ResourceWhereInput
  }

  export type QuizListRelationFilter = {
    every?: QuizWhereInput
    some?: QuizWhereInput
    none?: QuizWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningPathOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkshopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeCustomerId?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeCustomerId?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeCustomerId?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DomainCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    desc?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    iconLib?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DomainMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    desc?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    iconLib?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DomainMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    desc?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    iconLib?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DomainScalarRelationFilter = {
    is?: DomainWhereInput
    isNot?: DomainWhereInput
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    desc?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    iconLib?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domainId?: SortOrder
    deletedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    desc?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    iconLib?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domainId?: SortOrder
    deletedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    desc?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    iconLib?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domainId?: SortOrder
    deletedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LearningPathTagListRelationFilter = {
    every?: LearningPathTagWhereInput
    some?: LearningPathTagWhereInput
    none?: LearningPathTagWhereInput
  }

  export type LearningPathItemListRelationFilter = {
    every?: LearningPathItemWhereInput
    some?: LearningPathItemWhereInput
    none?: LearningPathItemWhereInput
  }

  export type UserProgressListRelationFilter = {
    every?: UserProgressWhereInput
    some?: UserProgressWhereInput
    none?: UserProgressWhereInput
  }

  export type LearningPathResourceListRelationFilter = {
    every?: LearningPathResourceWhereInput
    some?: LearningPathResourceWhereInput
    none?: LearningPathResourceWhereInput
  }

  export type LearningPathObjectiveListRelationFilter = {
    every?: LearningPathObjectiveWhereInput
    some?: LearningPathObjectiveWhereInput
    none?: LearningPathObjectiveWhereInput
  }

  export type LearningPathPrerequisiteListRelationFilter = {
    every?: LearningPathPrerequisiteWhereInput
    some?: LearningPathPrerequisiteWhereInput
    none?: LearningPathPrerequisiteWhereInput
  }

  export type PromoCodeListRelationFilter = {
    every?: PromoCodeWhereInput
    some?: PromoCodeWhereInput
    none?: PromoCodeWhereInput
  }

  export type PromotionListRelationFilter = {
    every?: PromotionWhereInput
    some?: PromotionWhereInput
    none?: PromotionWhereInput
  }

  export type LearningPathTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningPathItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningPathResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningPathObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningPathPrerequisiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromoCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromotionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningPathCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    smallDescription?: SortOrder
    fileKey?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
  }

  export type LearningPathAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type LearningPathMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    smallDescription?: SortOrder
    fileKey?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
  }

  export type LearningPathMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    smallDescription?: SortOrder
    fileKey?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
  }

  export type LearningPathSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type LearningPathScalarRelationFilter = {
    is?: LearningPathWhereInput
    isNot?: LearningPathWhereInput
  }

  export type CourseNullableScalarRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type WorkshopNullableScalarRelationFilter = {
    is?: WorkshopWhereInput | null
    isNot?: WorkshopWhereInput | null
  }

  export type ResourceNullableScalarRelationFilter = {
    is?: ResourceWhereInput | null
    isNot?: ResourceWhereInput | null
  }

  export type LearningPathItemCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    position?: SortOrder
    learningPathId?: SortOrder
    courseId?: SortOrder
    workshopId?: SortOrder
    resourceId?: SortOrder
  }

  export type LearningPathItemAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type LearningPathItemMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    position?: SortOrder
    learningPathId?: SortOrder
    courseId?: SortOrder
    workshopId?: SortOrder
    resourceId?: SortOrder
  }

  export type LearningPathItemMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    position?: SortOrder
    learningPathId?: SortOrder
    courseId?: SortOrder
    workshopId?: SortOrder
    resourceId?: SortOrder
  }

  export type LearningPathItemSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ChapterListRelationFilter = {
    every?: ChapterWhereInput
    some?: ChapterWhereInput
    none?: ChapterWhereInput
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type CourseTagListRelationFilter = {
    every?: CourseTagWhereInput
    some?: CourseTagWhereInput
    none?: CourseTagWhereInput
  }

  export type CourseResourceListRelationFilter = {
    every?: CourseResourceWhereInput
    some?: CourseResourceWhereInput
    none?: CourseResourceWhereInput
  }

  export type CourseObjectiveListRelationFilter = {
    every?: CourseObjectiveWhereInput
    some?: CourseObjectiveWhereInput
    none?: CourseObjectiveWhereInput
  }

  export type CoursePrerequisiteListRelationFilter = {
    every?: CoursePrerequisiteWhereInput
    some?: CoursePrerequisiteWhereInput
    none?: CoursePrerequisiteWhereInput
  }

  export type ChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoursePrerequisiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    smallDescription?: SortOrder
    description?: SortOrder
    fileKey?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    deletedAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    smallDescription?: SortOrder
    description?: SortOrder
    fileKey?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    deletedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    smallDescription?: SortOrder
    description?: SortOrder
    fileKey?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    deletedAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
  }

  export type ChapterAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
  }

  export type ChapterMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
  }

  export type ChapterSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ChapterScalarRelationFilter = {
    is?: ChapterWhereInput
    isNot?: ChapterWhereInput
  }

  export type LessonResourceListRelationFilter = {
    every?: LessonResourceWhereInput
    some?: LessonResourceWhereInput
    none?: LessonResourceWhereInput
  }

  export type LessonResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnailKey?: SortOrder
    videoKey?: SortOrder
    position?: SortOrder
    duration?: SortOrder
    public?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chapterId?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    position?: SortOrder
    duration?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnailKey?: SortOrder
    videoKey?: SortOrder
    position?: SortOrder
    duration?: SortOrder
    public?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chapterId?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnailKey?: SortOrder
    videoKey?: SortOrder
    position?: SortOrder
    duration?: SortOrder
    public?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chapterId?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    position?: SortOrder
    duration?: SortOrder
  }

  export type WorkshopTagListRelationFilter = {
    every?: WorkshopTagWhereInput
    some?: WorkshopTagWhereInput
    none?: WorkshopTagWhereInput
  }

  export type WorkshopResourceListRelationFilter = {
    every?: WorkshopResourceWhereInput
    some?: WorkshopResourceWhereInput
    none?: WorkshopResourceWhereInput
  }

  export type WorkshopObjectiveListRelationFilter = {
    every?: WorkshopObjectiveWhereInput
    some?: WorkshopObjectiveWhereInput
    none?: WorkshopObjectiveWhereInput
  }

  export type WorkshopPrerequisiteListRelationFilter = {
    every?: WorkshopPrerequisiteWhereInput
    some?: WorkshopPrerequisiteWhereInput
    none?: WorkshopPrerequisiteWhereInput
  }

  export type WorkshopTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkshopResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkshopObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkshopPrerequisiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkshopCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    statement?: SortOrder
    fileKey?: SortOrder
    statementsStartFileKey?: SortOrder
    statementsStartFileUrl?: SortOrder
    statementVideoKey?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrder
    solution?: SortOrder
    solutionFileKey?: SortOrder
    solutionFileUrl?: SortOrder
    solutionVideoKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkshopAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type WorkshopMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    statement?: SortOrder
    fileKey?: SortOrder
    statementsStartFileKey?: SortOrder
    statementsStartFileUrl?: SortOrder
    statementVideoKey?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrder
    solution?: SortOrder
    solutionFileKey?: SortOrder
    solutionFileUrl?: SortOrder
    solutionVideoKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkshopMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    statement?: SortOrder
    fileKey?: SortOrder
    statementsStartFileKey?: SortOrder
    statementsStartFileUrl?: SortOrder
    statementVideoKey?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    level?: SortOrder
    stripePriceId?: SortOrder
    solution?: SortOrder
    solutionFileKey?: SortOrder
    solutionFileUrl?: SortOrder
    solutionVideoKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkshopSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileKey?: SortOrder
    url?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileKey?: SortOrder
    url?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileKey?: SortOrder
    url?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type ResourceScalarRelationFilter = {
    is?: ResourceWhereInput
    isNot?: ResourceWhereInput
  }

  export type LearningPathResourceLearningPathIdResourceIdCompoundUniqueInput = {
    learningPathId: string
    resourceId: string
  }

  export type LearningPathResourceCountOrderByAggregateInput = {
    learningPathId?: SortOrder
    resourceId?: SortOrder
  }

  export type LearningPathResourceMaxOrderByAggregateInput = {
    learningPathId?: SortOrder
    resourceId?: SortOrder
  }

  export type LearningPathResourceMinOrderByAggregateInput = {
    learningPathId?: SortOrder
    resourceId?: SortOrder
  }

  export type CourseResourceCourseIdResourceIdCompoundUniqueInput = {
    courseId: string
    resourceId: string
  }

  export type CourseResourceCountOrderByAggregateInput = {
    courseId?: SortOrder
    resourceId?: SortOrder
  }

  export type CourseResourceMaxOrderByAggregateInput = {
    courseId?: SortOrder
    resourceId?: SortOrder
  }

  export type CourseResourceMinOrderByAggregateInput = {
    courseId?: SortOrder
    resourceId?: SortOrder
  }

  export type LessonScalarRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type LessonResourceLessonIdResourceIdCompoundUniqueInput = {
    lessonId: string
    resourceId: string
  }

  export type LessonResourceCountOrderByAggregateInput = {
    lessonId?: SortOrder
    resourceId?: SortOrder
  }

  export type LessonResourceMaxOrderByAggregateInput = {
    lessonId?: SortOrder
    resourceId?: SortOrder
  }

  export type LessonResourceMinOrderByAggregateInput = {
    lessonId?: SortOrder
    resourceId?: SortOrder
  }

  export type WorkshopScalarRelationFilter = {
    is?: WorkshopWhereInput
    isNot?: WorkshopWhereInput
  }

  export type WorkshopResourceWorkshopIdResourceIdCompoundUniqueInput = {
    workshopId: string
    resourceId: string
  }

  export type WorkshopResourceCountOrderByAggregateInput = {
    workshopId?: SortOrder
    resourceId?: SortOrder
  }

  export type WorkshopResourceMaxOrderByAggregateInput = {
    workshopId?: SortOrder
    resourceId?: SortOrder
  }

  export type WorkshopResourceMinOrderByAggregateInput = {
    workshopId?: SortOrder
    resourceId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type LessonProgressUserIdLessonIdCompoundUniqueInput = {
    userId: string
    lessonId: string
  }

  export type LessonProgressCountOrderByAggregateInput = {
    id?: SortOrder
    completed?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    watchedSeconds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
  }

  export type LessonProgressAvgOrderByAggregateInput = {
    watchedSeconds?: SortOrder
  }

  export type LessonProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    completed?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    watchedSeconds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
  }

  export type LessonProgressMinOrderByAggregateInput = {
    id?: SortOrder
    completed?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    watchedSeconds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
  }

  export type LessonProgressSumOrderByAggregateInput = {
    watchedSeconds?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type LearningPathNullableScalarRelationFilter = {
    is?: LearningPathWhereInput | null
    isNot?: LearningPathWhereInput | null
  }

  export type UserProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    completed?: SortOrder
    updatedAt?: SortOrder
    progressPercentage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    timeSpent?: SortOrder
  }

  export type UserProgressAvgOrderByAggregateInput = {
    progressPercentage?: SortOrder
    timeSpent?: SortOrder
  }

  export type UserProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    completed?: SortOrder
    updatedAt?: SortOrder
    progressPercentage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    timeSpent?: SortOrder
  }

  export type UserProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    completed?: SortOrder
    updatedAt?: SortOrder
    progressPercentage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    timeSpent?: SortOrder
  }

  export type UserProgressSumOrderByAggregateInput = {
    progressPercentage?: SortOrder
    timeSpent?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type CourseTagCourseIdTagIdCompoundUniqueInput = {
    courseId: string
    tagId: string
  }

  export type CourseTagCountOrderByAggregateInput = {
    courseId?: SortOrder
    tagId?: SortOrder
  }

  export type CourseTagMaxOrderByAggregateInput = {
    courseId?: SortOrder
    tagId?: SortOrder
  }

  export type CourseTagMinOrderByAggregateInput = {
    courseId?: SortOrder
    tagId?: SortOrder
  }

  export type WorkshopTagWorkshopIdTagIdCompoundUniqueInput = {
    workshopId: string
    tagId: string
  }

  export type WorkshopTagCountOrderByAggregateInput = {
    workshopId?: SortOrder
    tagId?: SortOrder
  }

  export type WorkshopTagMaxOrderByAggregateInput = {
    workshopId?: SortOrder
    tagId?: SortOrder
  }

  export type WorkshopTagMinOrderByAggregateInput = {
    workshopId?: SortOrder
    tagId?: SortOrder
  }

  export type LearningPathTagLearningPathIdTagIdCompoundUniqueInput = {
    learningPathId: string
    tagId: string
  }

  export type LearningPathTagCountOrderByAggregateInput = {
    learningPathId?: SortOrder
    tagId?: SortOrder
  }

  export type LearningPathTagMaxOrderByAggregateInput = {
    learningPathId?: SortOrder
    tagId?: SortOrder
  }

  export type LearningPathTagMinOrderByAggregateInput = {
    learningPathId?: SortOrder
    tagId?: SortOrder
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    active?: SortOrder
    itemType?: SortOrder
    courseId?: SortOrder
    workshopId?: SortOrder
    learningPathId?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    discount?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    active?: SortOrder
    itemType?: SortOrder
    courseId?: SortOrder
    workshopId?: SortOrder
    learningPathId?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    active?: SortOrder
    itemType?: SortOrder
    courseId?: SortOrder
    workshopId?: SortOrder
    learningPathId?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    discount?: SortOrder
  }

  export type PromoCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    active?: SortOrder
  }

  export type PromoCodeAvgOrderByAggregateInput = {
    discount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
  }

  export type PromoCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    active?: SortOrder
  }

  export type PromoCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    active?: SortOrder
  }

  export type PromoCodeSumOrderByAggregateInput = {
    discount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
  }

  export type EnumenrollmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.enrollmentStatus | EnumenrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.enrollmentStatus[] | ListEnumenrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.enrollmentStatus[] | ListEnumenrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumenrollmentStatusFilter<$PrismaModel> | $Enums.enrollmentStatus
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type EnrollmentUserIdLearningPathIdCompoundUniqueInput = {
    userId: string
    learningPathId: string
  }

  export type EnrollmentUserIdCourseIdCompoundUniqueInput = {
    userId: string
    courseId: string
  }

  export type EnrollmentUserIdWorkshopIdCompoundUniqueInput = {
    userId: string
    workshopId: string
  }

  export type EnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
    learningPathId?: SortOrder
    workshopId?: SortOrder
    userId?: SortOrder
    paymentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnrollmentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
    learningPathId?: SortOrder
    workshopId?: SortOrder
    userId?: SortOrder
    paymentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
    learningPathId?: SortOrder
    workshopId?: SortOrder
    userId?: SortOrder
    paymentId?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnrollmentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumenrollmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enrollmentStatus | EnumenrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.enrollmentStatus[] | ListEnumenrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.enrollmentStatus[] | ListEnumenrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumenrollmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.enrollmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenrollmentStatusFilter<$PrismaModel>
    _max?: NestedEnumenrollmentStatusFilter<$PrismaModel>
  }

  export type EnrollmentNullableScalarRelationFilter = {
    is?: EnrollmentWhereInput | null
    isNot?: EnrollmentWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    stripeId?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    learningPathId?: SortOrder
    workshopId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    stripeId?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    learningPathId?: SortOrder
    workshopId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    stripeId?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    learningPathId?: SortOrder
    workshopId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    pdfUrl?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    pdfUrl?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    pdfUrl?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type ObjectiveCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ObjectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ObjectiveMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type PrerequisiteCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type PrerequisiteMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type PrerequisiteMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ObjectiveScalarRelationFilter = {
    is?: ObjectiveWhereInput
    isNot?: ObjectiveWhereInput
  }

  export type CourseObjectiveCourseIdObjectiveIdCompoundUniqueInput = {
    courseId: string
    objectiveId: string
  }

  export type CourseObjectiveCountOrderByAggregateInput = {
    courseId?: SortOrder
    objectiveId?: SortOrder
  }

  export type CourseObjectiveMaxOrderByAggregateInput = {
    courseId?: SortOrder
    objectiveId?: SortOrder
  }

  export type CourseObjectiveMinOrderByAggregateInput = {
    courseId?: SortOrder
    objectiveId?: SortOrder
  }

  export type PrerequisiteScalarRelationFilter = {
    is?: PrerequisiteWhereInput
    isNot?: PrerequisiteWhereInput
  }

  export type CoursePrerequisiteCourseIdPrerequisiteIdCompoundUniqueInput = {
    courseId: string
    prerequisiteId: string
  }

  export type CoursePrerequisiteCountOrderByAggregateInput = {
    courseId?: SortOrder
    prerequisiteId?: SortOrder
  }

  export type CoursePrerequisiteMaxOrderByAggregateInput = {
    courseId?: SortOrder
    prerequisiteId?: SortOrder
  }

  export type CoursePrerequisiteMinOrderByAggregateInput = {
    courseId?: SortOrder
    prerequisiteId?: SortOrder
  }

  export type WorkshopObjectiveWorkshopIdObjectiveIdCompoundUniqueInput = {
    workshopId: string
    objectiveId: string
  }

  export type WorkshopObjectiveCountOrderByAggregateInput = {
    workshopId?: SortOrder
    objectiveId?: SortOrder
  }

  export type WorkshopObjectiveMaxOrderByAggregateInput = {
    workshopId?: SortOrder
    objectiveId?: SortOrder
  }

  export type WorkshopObjectiveMinOrderByAggregateInput = {
    workshopId?: SortOrder
    objectiveId?: SortOrder
  }

  export type WorkshopPrerequisiteWorkshopIdPrerequisiteIdCompoundUniqueInput = {
    workshopId: string
    prerequisiteId: string
  }

  export type WorkshopPrerequisiteCountOrderByAggregateInput = {
    workshopId?: SortOrder
    prerequisiteId?: SortOrder
  }

  export type WorkshopPrerequisiteMaxOrderByAggregateInput = {
    workshopId?: SortOrder
    prerequisiteId?: SortOrder
  }

  export type WorkshopPrerequisiteMinOrderByAggregateInput = {
    workshopId?: SortOrder
    prerequisiteId?: SortOrder
  }

  export type LearningPathObjectiveLearningPathIdObjectiveIdCompoundUniqueInput = {
    learningPathId: string
    objectiveId: string
  }

  export type LearningPathObjectiveCountOrderByAggregateInput = {
    learningPathId?: SortOrder
    objectiveId?: SortOrder
  }

  export type LearningPathObjectiveMaxOrderByAggregateInput = {
    learningPathId?: SortOrder
    objectiveId?: SortOrder
  }

  export type LearningPathObjectiveMinOrderByAggregateInput = {
    learningPathId?: SortOrder
    objectiveId?: SortOrder
  }

  export type LearningPathPrerequisiteLearningPathIdPrerequisiteIdCompoundUniqueInput = {
    learningPathId: string
    prerequisiteId: string
  }

  export type LearningPathPrerequisiteCountOrderByAggregateInput = {
    learningPathId?: SortOrder
    prerequisiteId?: SortOrder
  }

  export type LearningPathPrerequisiteMaxOrderByAggregateInput = {
    learningPathId?: SortOrder
    prerequisiteId?: SortOrder
  }

  export type LearningPathPrerequisiteMinOrderByAggregateInput = {
    learningPathId?: SortOrder
    prerequisiteId?: SortOrder
  }

  export type FeatureCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    iconLib?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    iconLib?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    color?: SortOrder
    iconName?: SortOrder
    iconLib?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySocialLinkListRelationFilter = {
    every?: CompanySocialLinkWhereInput
    some?: CompanySocialLinkWhereInput
    none?: CompanySocialLinkWhereInput
  }

  export type CompanySocialLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    country?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    siret?: SortOrder
    vatNumber?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    country?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    siret?: SortOrder
    vatNumber?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    country?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    siret?: SortOrder
    vatNumber?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialLinkCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iconLib?: SortOrder
    iconName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iconLib?: SortOrder
    iconName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialLinkMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iconLib?: SortOrder
    iconName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type SocialLinkScalarRelationFilter = {
    is?: SocialLinkWhereInput
    isNot?: SocialLinkWhereInput
  }

  export type CompanySocialLinkCompanyIdSocialLinkIdCompoundUniqueInput = {
    companyId: string
    socialLinkId: string
  }

  export type CompanySocialLinkCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    socialLinkId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySocialLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    socialLinkId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySocialLinkMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    socialLinkId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizQuestionListRelationFilter = {
    every?: QuizQuestionWhereInput
    some?: QuizQuestionWhereInput
    none?: QuizQuestionWhereInput
  }

  export type QuizQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    type?: SortOrder
    chapterId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type QuizMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    type?: SortOrder
    chapterId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type QuizMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    type?: SortOrder
    chapterId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type QuizScalarRelationFilter = {
    is?: QuizWhereInput
    isNot?: QuizWhereInput
  }

  export type QuizOptionListRelationFilter = {
    every?: QuizOptionWhereInput
    some?: QuizOptionWhereInput
    none?: QuizOptionWhereInput
  }

  export type QuizOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    quizId?: SortOrder
  }

  export type QuizQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    quizId?: SortOrder
  }

  export type QuizQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    quizId?: SortOrder
  }

  export type QuizQuestionScalarRelationFilter = {
    is?: QuizQuestionWhereInput
    isNot?: QuizQuestionWhereInput
  }

  export type QuizOptionCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isCorrect?: SortOrder
    questionId?: SortOrder
  }

  export type QuizOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isCorrect?: SortOrder
    questionId?: SortOrder
  }

  export type QuizOptionMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isCorrect?: SortOrder
    questionId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type QuizResultCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizResultAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type QuizResultMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizResultMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizResultSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TestimonialCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type TestimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type NewsletterSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confirmed?: SortOrder
  }

  export type NewsletterSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confirmed?: SortOrder
  }

  export type NewsletterSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confirmed?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type LessonProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput> | LessonProgressCreateWithoutUserInput[] | LessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUserInput | LessonProgressCreateOrConnectWithoutUserInput[]
    createMany?: LessonProgressCreateManyUserInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput> | CourseCreateWithoutUserInput[] | CourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUserInput | CourseCreateOrConnectWithoutUserInput[]
    createMany?: CourseCreateManyUserInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type LearningPathCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningPathCreateWithoutUserInput, LearningPathUncheckedCreateWithoutUserInput> | LearningPathCreateWithoutUserInput[] | LearningPathUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningPathCreateOrConnectWithoutUserInput | LearningPathCreateOrConnectWithoutUserInput[]
    createMany?: LearningPathCreateManyUserInputEnvelope
    connect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
  }

  export type WorkshopCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkshopCreateWithoutUserInput, WorkshopUncheckedCreateWithoutUserInput> | WorkshopCreateWithoutUserInput[] | WorkshopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutUserInput | WorkshopCreateOrConnectWithoutUserInput[]
    createMany?: WorkshopCreateManyUserInputEnvelope
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
  }

  export type ResourceCreateNestedManyWithoutUserInput = {
    create?: XOR<ResourceCreateWithoutUserInput, ResourceUncheckedCreateWithoutUserInput> | ResourceCreateWithoutUserInput[] | ResourceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUserInput | ResourceCreateOrConnectWithoutUserInput[]
    createMany?: ResourceCreateManyUserInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type QuizCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizCreateWithoutUserInput, QuizUncheckedCreateWithoutUserInput> | QuizCreateWithoutUserInput[] | QuizUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutUserInput | QuizCreateOrConnectWithoutUserInput[]
    createMany?: QuizCreateManyUserInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type LessonProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput> | LessonProgressCreateWithoutUserInput[] | LessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUserInput | LessonProgressCreateOrConnectWithoutUserInput[]
    createMany?: LessonProgressCreateManyUserInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput> | CourseCreateWithoutUserInput[] | CourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUserInput | CourseCreateOrConnectWithoutUserInput[]
    createMany?: CourseCreateManyUserInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type LearningPathUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningPathCreateWithoutUserInput, LearningPathUncheckedCreateWithoutUserInput> | LearningPathCreateWithoutUserInput[] | LearningPathUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningPathCreateOrConnectWithoutUserInput | LearningPathCreateOrConnectWithoutUserInput[]
    createMany?: LearningPathCreateManyUserInputEnvelope
    connect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
  }

  export type WorkshopUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkshopCreateWithoutUserInput, WorkshopUncheckedCreateWithoutUserInput> | WorkshopCreateWithoutUserInput[] | WorkshopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutUserInput | WorkshopCreateOrConnectWithoutUserInput[]
    createMany?: WorkshopCreateManyUserInputEnvelope
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResourceCreateWithoutUserInput, ResourceUncheckedCreateWithoutUserInput> | ResourceCreateWithoutUserInput[] | ResourceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUserInput | ResourceCreateOrConnectWithoutUserInput[]
    createMany?: ResourceCreateManyUserInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizCreateWithoutUserInput, QuizUncheckedCreateWithoutUserInput> | QuizCreateWithoutUserInput[] | QuizUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutUserInput | QuizCreateOrConnectWithoutUserInput[]
    createMany?: QuizCreateManyUserInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type LessonProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput> | LessonProgressCreateWithoutUserInput[] | LessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUserInput | LessonProgressCreateOrConnectWithoutUserInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutUserInput | LessonProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonProgressCreateManyUserInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutUserInput | LessonProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutUserInput | LessonProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput> | CourseCreateWithoutUserInput[] | CourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUserInput | CourseCreateOrConnectWithoutUserInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutUserInput | CourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseCreateManyUserInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutUserInput | CourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutUserInput | CourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type LearningPathUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningPathCreateWithoutUserInput, LearningPathUncheckedCreateWithoutUserInput> | LearningPathCreateWithoutUserInput[] | LearningPathUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningPathCreateOrConnectWithoutUserInput | LearningPathCreateOrConnectWithoutUserInput[]
    upsert?: LearningPathUpsertWithWhereUniqueWithoutUserInput | LearningPathUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningPathCreateManyUserInputEnvelope
    set?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    disconnect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    delete?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    connect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    update?: LearningPathUpdateWithWhereUniqueWithoutUserInput | LearningPathUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningPathUpdateManyWithWhereWithoutUserInput | LearningPathUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningPathScalarWhereInput | LearningPathScalarWhereInput[]
  }

  export type WorkshopUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkshopCreateWithoutUserInput, WorkshopUncheckedCreateWithoutUserInput> | WorkshopCreateWithoutUserInput[] | WorkshopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutUserInput | WorkshopCreateOrConnectWithoutUserInput[]
    upsert?: WorkshopUpsertWithWhereUniqueWithoutUserInput | WorkshopUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkshopCreateManyUserInputEnvelope
    set?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    disconnect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    delete?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    update?: WorkshopUpdateWithWhereUniqueWithoutUserInput | WorkshopUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkshopUpdateManyWithWhereWithoutUserInput | WorkshopUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkshopScalarWhereInput | WorkshopScalarWhereInput[]
  }

  export type ResourceUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResourceCreateWithoutUserInput, ResourceUncheckedCreateWithoutUserInput> | ResourceCreateWithoutUserInput[] | ResourceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUserInput | ResourceCreateOrConnectWithoutUserInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutUserInput | ResourceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResourceCreateManyUserInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutUserInput | ResourceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutUserInput | ResourceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type QuizUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizCreateWithoutUserInput, QuizUncheckedCreateWithoutUserInput> | QuizCreateWithoutUserInput[] | QuizUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutUserInput | QuizCreateOrConnectWithoutUserInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutUserInput | QuizUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizCreateManyUserInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutUserInput | QuizUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutUserInput | QuizUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type LessonProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput> | LessonProgressCreateWithoutUserInput[] | LessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUserInput | LessonProgressCreateOrConnectWithoutUserInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutUserInput | LessonProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonProgressCreateManyUserInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutUserInput | LessonProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutUserInput | LessonProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput> | CourseCreateWithoutUserInput[] | CourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUserInput | CourseCreateOrConnectWithoutUserInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutUserInput | CourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseCreateManyUserInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutUserInput | CourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutUserInput | CourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type LearningPathUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningPathCreateWithoutUserInput, LearningPathUncheckedCreateWithoutUserInput> | LearningPathCreateWithoutUserInput[] | LearningPathUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningPathCreateOrConnectWithoutUserInput | LearningPathCreateOrConnectWithoutUserInput[]
    upsert?: LearningPathUpsertWithWhereUniqueWithoutUserInput | LearningPathUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningPathCreateManyUserInputEnvelope
    set?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    disconnect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    delete?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    connect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    update?: LearningPathUpdateWithWhereUniqueWithoutUserInput | LearningPathUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningPathUpdateManyWithWhereWithoutUserInput | LearningPathUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningPathScalarWhereInput | LearningPathScalarWhereInput[]
  }

  export type WorkshopUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkshopCreateWithoutUserInput, WorkshopUncheckedCreateWithoutUserInput> | WorkshopCreateWithoutUserInput[] | WorkshopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutUserInput | WorkshopCreateOrConnectWithoutUserInput[]
    upsert?: WorkshopUpsertWithWhereUniqueWithoutUserInput | WorkshopUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkshopCreateManyUserInputEnvelope
    set?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    disconnect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    delete?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    update?: WorkshopUpdateWithWhereUniqueWithoutUserInput | WorkshopUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkshopUpdateManyWithWhereWithoutUserInput | WorkshopUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkshopScalarWhereInput | WorkshopScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResourceCreateWithoutUserInput, ResourceUncheckedCreateWithoutUserInput> | ResourceCreateWithoutUserInput[] | ResourceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUserInput | ResourceCreateOrConnectWithoutUserInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutUserInput | ResourceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResourceCreateManyUserInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutUserInput | ResourceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutUserInput | ResourceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizCreateWithoutUserInput, QuizUncheckedCreateWithoutUserInput> | QuizCreateWithoutUserInput[] | QuizUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutUserInput | QuizCreateOrConnectWithoutUserInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutUserInput | QuizUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizCreateManyUserInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutUserInput | QuizUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutUserInput | QuizUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type CategoryCreateNestedManyWithoutDomainInput = {
    create?: XOR<CategoryCreateWithoutDomainInput, CategoryUncheckedCreateWithoutDomainInput> | CategoryCreateWithoutDomainInput[] | CategoryUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutDomainInput | CategoryCreateOrConnectWithoutDomainInput[]
    createMany?: CategoryCreateManyDomainInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<CategoryCreateWithoutDomainInput, CategoryUncheckedCreateWithoutDomainInput> | CategoryCreateWithoutDomainInput[] | CategoryUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutDomainInput | CategoryCreateOrConnectWithoutDomainInput[]
    createMany?: CategoryCreateManyDomainInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CategoryUpdateManyWithoutDomainNestedInput = {
    create?: XOR<CategoryCreateWithoutDomainInput, CategoryUncheckedCreateWithoutDomainInput> | CategoryCreateWithoutDomainInput[] | CategoryUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutDomainInput | CategoryCreateOrConnectWithoutDomainInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutDomainInput | CategoryUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: CategoryCreateManyDomainInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutDomainInput | CategoryUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutDomainInput | CategoryUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<CategoryCreateWithoutDomainInput, CategoryUncheckedCreateWithoutDomainInput> | CategoryCreateWithoutDomainInput[] | CategoryUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutDomainInput | CategoryCreateOrConnectWithoutDomainInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutDomainInput | CategoryUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: CategoryCreateManyDomainInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutDomainInput | CategoryUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutDomainInput | CategoryUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CourseCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CourseCreateWithoutCategoryInput, CourseUncheckedCreateWithoutCategoryInput> | CourseCreateWithoutCategoryInput[] | CourseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCategoryInput | CourseCreateOrConnectWithoutCategoryInput[]
    createMany?: CourseCreateManyCategoryInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type DomainCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<DomainCreateWithoutCategoriesInput, DomainUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutCategoriesInput
    connect?: DomainWhereUniqueInput
  }

  export type CourseUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CourseCreateWithoutCategoryInput, CourseUncheckedCreateWithoutCategoryInput> | CourseCreateWithoutCategoryInput[] | CourseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCategoryInput | CourseCreateOrConnectWithoutCategoryInput[]
    createMany?: CourseCreateManyCategoryInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CourseCreateWithoutCategoryInput, CourseUncheckedCreateWithoutCategoryInput> | CourseCreateWithoutCategoryInput[] | CourseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCategoryInput | CourseCreateOrConnectWithoutCategoryInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCategoryInput | CourseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CourseCreateManyCategoryInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCategoryInput | CourseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCategoryInput | CourseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type DomainUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<DomainCreateWithoutCategoriesInput, DomainUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutCategoriesInput
    upsert?: DomainUpsertWithoutCategoriesInput
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutCategoriesInput, DomainUpdateWithoutCategoriesInput>, DomainUncheckedUpdateWithoutCategoriesInput>
  }

  export type CourseUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CourseCreateWithoutCategoryInput, CourseUncheckedCreateWithoutCategoryInput> | CourseCreateWithoutCategoryInput[] | CourseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCategoryInput | CourseCreateOrConnectWithoutCategoryInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCategoryInput | CourseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CourseCreateManyCategoryInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCategoryInput | CourseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCategoryInput | CourseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLearningPathsInput = {
    create?: XOR<UserCreateWithoutLearningPathsInput, UserUncheckedCreateWithoutLearningPathsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningPathsInput
    connect?: UserWhereUniqueInput
  }

  export type LearningPathTagCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<LearningPathTagCreateWithoutLearningPathInput, LearningPathTagUncheckedCreateWithoutLearningPathInput> | LearningPathTagCreateWithoutLearningPathInput[] | LearningPathTagUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathTagCreateOrConnectWithoutLearningPathInput | LearningPathTagCreateOrConnectWithoutLearningPathInput[]
    createMany?: LearningPathTagCreateManyLearningPathInputEnvelope
    connect?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
  }

  export type LearningPathItemCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<LearningPathItemCreateWithoutLearningPathInput, LearningPathItemUncheckedCreateWithoutLearningPathInput> | LearningPathItemCreateWithoutLearningPathInput[] | LearningPathItemUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutLearningPathInput | LearningPathItemCreateOrConnectWithoutLearningPathInput[]
    createMany?: LearningPathItemCreateManyLearningPathInputEnvelope
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
  }

  export type UserProgressCreateNestedManyWithoutPathInput = {
    create?: XOR<UserProgressCreateWithoutPathInput, UserProgressUncheckedCreateWithoutPathInput> | UserProgressCreateWithoutPathInput[] | UserProgressUncheckedCreateWithoutPathInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutPathInput | UserProgressCreateOrConnectWithoutPathInput[]
    createMany?: UserProgressCreateManyPathInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type LearningPathResourceCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<LearningPathResourceCreateWithoutLearningPathInput, LearningPathResourceUncheckedCreateWithoutLearningPathInput> | LearningPathResourceCreateWithoutLearningPathInput[] | LearningPathResourceUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathResourceCreateOrConnectWithoutLearningPathInput | LearningPathResourceCreateOrConnectWithoutLearningPathInput[]
    createMany?: LearningPathResourceCreateManyLearningPathInputEnvelope
    connect?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
  }

  export type LearningPathObjectiveCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<LearningPathObjectiveCreateWithoutLearningPathInput, LearningPathObjectiveUncheckedCreateWithoutLearningPathInput> | LearningPathObjectiveCreateWithoutLearningPathInput[] | LearningPathObjectiveUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathObjectiveCreateOrConnectWithoutLearningPathInput | LearningPathObjectiveCreateOrConnectWithoutLearningPathInput[]
    createMany?: LearningPathObjectiveCreateManyLearningPathInputEnvelope
    connect?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
  }

  export type LearningPathPrerequisiteCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<LearningPathPrerequisiteCreateWithoutLearningPathInput, LearningPathPrerequisiteUncheckedCreateWithoutLearningPathInput> | LearningPathPrerequisiteCreateWithoutLearningPathInput[] | LearningPathPrerequisiteUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathPrerequisiteCreateOrConnectWithoutLearningPathInput | LearningPathPrerequisiteCreateOrConnectWithoutLearningPathInput[]
    createMany?: LearningPathPrerequisiteCreateManyLearningPathInputEnvelope
    connect?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
  }

  export type PromoCodeCreateNestedManyWithoutApplicableLearningPathsInput = {
    create?: XOR<PromoCodeCreateWithoutApplicableLearningPathsInput, PromoCodeUncheckedCreateWithoutApplicableLearningPathsInput> | PromoCodeCreateWithoutApplicableLearningPathsInput[] | PromoCodeUncheckedCreateWithoutApplicableLearningPathsInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutApplicableLearningPathsInput | PromoCodeCreateOrConnectWithoutApplicableLearningPathsInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type PromotionCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<PromotionCreateWithoutLearningPathInput, PromotionUncheckedCreateWithoutLearningPathInput> | PromotionCreateWithoutLearningPathInput[] | PromotionUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutLearningPathInput | PromotionCreateOrConnectWithoutLearningPathInput[]
    createMany?: PromotionCreateManyLearningPathInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<EnrollmentCreateWithoutLearningPathInput, EnrollmentUncheckedCreateWithoutLearningPathInput> | EnrollmentCreateWithoutLearningPathInput[] | EnrollmentUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutLearningPathInput | EnrollmentCreateOrConnectWithoutLearningPathInput[]
    createMany?: EnrollmentCreateManyLearningPathInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<PaymentCreateWithoutLearningPathInput, PaymentUncheckedCreateWithoutLearningPathInput> | PaymentCreateWithoutLearningPathInput[] | PaymentUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLearningPathInput | PaymentCreateOrConnectWithoutLearningPathInput[]
    createMany?: PaymentCreateManyLearningPathInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type LearningPathTagUncheckedCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<LearningPathTagCreateWithoutLearningPathInput, LearningPathTagUncheckedCreateWithoutLearningPathInput> | LearningPathTagCreateWithoutLearningPathInput[] | LearningPathTagUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathTagCreateOrConnectWithoutLearningPathInput | LearningPathTagCreateOrConnectWithoutLearningPathInput[]
    createMany?: LearningPathTagCreateManyLearningPathInputEnvelope
    connect?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
  }

  export type LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<LearningPathItemCreateWithoutLearningPathInput, LearningPathItemUncheckedCreateWithoutLearningPathInput> | LearningPathItemCreateWithoutLearningPathInput[] | LearningPathItemUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutLearningPathInput | LearningPathItemCreateOrConnectWithoutLearningPathInput[]
    createMany?: LearningPathItemCreateManyLearningPathInputEnvelope
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutPathInput = {
    create?: XOR<UserProgressCreateWithoutPathInput, UserProgressUncheckedCreateWithoutPathInput> | UserProgressCreateWithoutPathInput[] | UserProgressUncheckedCreateWithoutPathInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutPathInput | UserProgressCreateOrConnectWithoutPathInput[]
    createMany?: UserProgressCreateManyPathInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type LearningPathResourceUncheckedCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<LearningPathResourceCreateWithoutLearningPathInput, LearningPathResourceUncheckedCreateWithoutLearningPathInput> | LearningPathResourceCreateWithoutLearningPathInput[] | LearningPathResourceUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathResourceCreateOrConnectWithoutLearningPathInput | LearningPathResourceCreateOrConnectWithoutLearningPathInput[]
    createMany?: LearningPathResourceCreateManyLearningPathInputEnvelope
    connect?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
  }

  export type LearningPathObjectiveUncheckedCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<LearningPathObjectiveCreateWithoutLearningPathInput, LearningPathObjectiveUncheckedCreateWithoutLearningPathInput> | LearningPathObjectiveCreateWithoutLearningPathInput[] | LearningPathObjectiveUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathObjectiveCreateOrConnectWithoutLearningPathInput | LearningPathObjectiveCreateOrConnectWithoutLearningPathInput[]
    createMany?: LearningPathObjectiveCreateManyLearningPathInputEnvelope
    connect?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
  }

  export type LearningPathPrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<LearningPathPrerequisiteCreateWithoutLearningPathInput, LearningPathPrerequisiteUncheckedCreateWithoutLearningPathInput> | LearningPathPrerequisiteCreateWithoutLearningPathInput[] | LearningPathPrerequisiteUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathPrerequisiteCreateOrConnectWithoutLearningPathInput | LearningPathPrerequisiteCreateOrConnectWithoutLearningPathInput[]
    createMany?: LearningPathPrerequisiteCreateManyLearningPathInputEnvelope
    connect?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
  }

  export type PromoCodeUncheckedCreateNestedManyWithoutApplicableLearningPathsInput = {
    create?: XOR<PromoCodeCreateWithoutApplicableLearningPathsInput, PromoCodeUncheckedCreateWithoutApplicableLearningPathsInput> | PromoCodeCreateWithoutApplicableLearningPathsInput[] | PromoCodeUncheckedCreateWithoutApplicableLearningPathsInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutApplicableLearningPathsInput | PromoCodeCreateOrConnectWithoutApplicableLearningPathsInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type PromotionUncheckedCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<PromotionCreateWithoutLearningPathInput, PromotionUncheckedCreateWithoutLearningPathInput> | PromotionCreateWithoutLearningPathInput[] | PromotionUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutLearningPathInput | PromotionCreateOrConnectWithoutLearningPathInput[]
    createMany?: PromotionCreateManyLearningPathInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<EnrollmentCreateWithoutLearningPathInput, EnrollmentUncheckedCreateWithoutLearningPathInput> | EnrollmentCreateWithoutLearningPathInput[] | EnrollmentUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutLearningPathInput | EnrollmentCreateOrConnectWithoutLearningPathInput[]
    createMany?: EnrollmentCreateManyLearningPathInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<PaymentCreateWithoutLearningPathInput, PaymentUncheckedCreateWithoutLearningPathInput> | PaymentCreateWithoutLearningPathInput[] | PaymentUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLearningPathInput | PaymentCreateOrConnectWithoutLearningPathInput[]
    createMany?: PaymentCreateManyLearningPathInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutLearningPathsNestedInput = {
    create?: XOR<UserCreateWithoutLearningPathsInput, UserUncheckedCreateWithoutLearningPathsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningPathsInput
    upsert?: UserUpsertWithoutLearningPathsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLearningPathsInput, UserUpdateWithoutLearningPathsInput>, UserUncheckedUpdateWithoutLearningPathsInput>
  }

  export type LearningPathTagUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<LearningPathTagCreateWithoutLearningPathInput, LearningPathTagUncheckedCreateWithoutLearningPathInput> | LearningPathTagCreateWithoutLearningPathInput[] | LearningPathTagUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathTagCreateOrConnectWithoutLearningPathInput | LearningPathTagCreateOrConnectWithoutLearningPathInput[]
    upsert?: LearningPathTagUpsertWithWhereUniqueWithoutLearningPathInput | LearningPathTagUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: LearningPathTagCreateManyLearningPathInputEnvelope
    set?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    disconnect?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    delete?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    connect?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    update?: LearningPathTagUpdateWithWhereUniqueWithoutLearningPathInput | LearningPathTagUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: LearningPathTagUpdateManyWithWhereWithoutLearningPathInput | LearningPathTagUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: LearningPathTagScalarWhereInput | LearningPathTagScalarWhereInput[]
  }

  export type LearningPathItemUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<LearningPathItemCreateWithoutLearningPathInput, LearningPathItemUncheckedCreateWithoutLearningPathInput> | LearningPathItemCreateWithoutLearningPathInput[] | LearningPathItemUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutLearningPathInput | LearningPathItemCreateOrConnectWithoutLearningPathInput[]
    upsert?: LearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput | LearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: LearningPathItemCreateManyLearningPathInputEnvelope
    set?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    disconnect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    delete?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    update?: LearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput | LearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: LearningPathItemUpdateManyWithWhereWithoutLearningPathInput | LearningPathItemUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
  }

  export type UserProgressUpdateManyWithoutPathNestedInput = {
    create?: XOR<UserProgressCreateWithoutPathInput, UserProgressUncheckedCreateWithoutPathInput> | UserProgressCreateWithoutPathInput[] | UserProgressUncheckedCreateWithoutPathInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutPathInput | UserProgressCreateOrConnectWithoutPathInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutPathInput | UserProgressUpsertWithWhereUniqueWithoutPathInput[]
    createMany?: UserProgressCreateManyPathInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutPathInput | UserProgressUpdateWithWhereUniqueWithoutPathInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutPathInput | UserProgressUpdateManyWithWhereWithoutPathInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type LearningPathResourceUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<LearningPathResourceCreateWithoutLearningPathInput, LearningPathResourceUncheckedCreateWithoutLearningPathInput> | LearningPathResourceCreateWithoutLearningPathInput[] | LearningPathResourceUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathResourceCreateOrConnectWithoutLearningPathInput | LearningPathResourceCreateOrConnectWithoutLearningPathInput[]
    upsert?: LearningPathResourceUpsertWithWhereUniqueWithoutLearningPathInput | LearningPathResourceUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: LearningPathResourceCreateManyLearningPathInputEnvelope
    set?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    disconnect?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    delete?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    connect?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    update?: LearningPathResourceUpdateWithWhereUniqueWithoutLearningPathInput | LearningPathResourceUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: LearningPathResourceUpdateManyWithWhereWithoutLearningPathInput | LearningPathResourceUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: LearningPathResourceScalarWhereInput | LearningPathResourceScalarWhereInput[]
  }

  export type LearningPathObjectiveUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<LearningPathObjectiveCreateWithoutLearningPathInput, LearningPathObjectiveUncheckedCreateWithoutLearningPathInput> | LearningPathObjectiveCreateWithoutLearningPathInput[] | LearningPathObjectiveUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathObjectiveCreateOrConnectWithoutLearningPathInput | LearningPathObjectiveCreateOrConnectWithoutLearningPathInput[]
    upsert?: LearningPathObjectiveUpsertWithWhereUniqueWithoutLearningPathInput | LearningPathObjectiveUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: LearningPathObjectiveCreateManyLearningPathInputEnvelope
    set?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    disconnect?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    delete?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    connect?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    update?: LearningPathObjectiveUpdateWithWhereUniqueWithoutLearningPathInput | LearningPathObjectiveUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: LearningPathObjectiveUpdateManyWithWhereWithoutLearningPathInput | LearningPathObjectiveUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: LearningPathObjectiveScalarWhereInput | LearningPathObjectiveScalarWhereInput[]
  }

  export type LearningPathPrerequisiteUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<LearningPathPrerequisiteCreateWithoutLearningPathInput, LearningPathPrerequisiteUncheckedCreateWithoutLearningPathInput> | LearningPathPrerequisiteCreateWithoutLearningPathInput[] | LearningPathPrerequisiteUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathPrerequisiteCreateOrConnectWithoutLearningPathInput | LearningPathPrerequisiteCreateOrConnectWithoutLearningPathInput[]
    upsert?: LearningPathPrerequisiteUpsertWithWhereUniqueWithoutLearningPathInput | LearningPathPrerequisiteUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: LearningPathPrerequisiteCreateManyLearningPathInputEnvelope
    set?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    disconnect?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    delete?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    connect?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    update?: LearningPathPrerequisiteUpdateWithWhereUniqueWithoutLearningPathInput | LearningPathPrerequisiteUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: LearningPathPrerequisiteUpdateManyWithWhereWithoutLearningPathInput | LearningPathPrerequisiteUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: LearningPathPrerequisiteScalarWhereInput | LearningPathPrerequisiteScalarWhereInput[]
  }

  export type PromoCodeUpdateManyWithoutApplicableLearningPathsNestedInput = {
    create?: XOR<PromoCodeCreateWithoutApplicableLearningPathsInput, PromoCodeUncheckedCreateWithoutApplicableLearningPathsInput> | PromoCodeCreateWithoutApplicableLearningPathsInput[] | PromoCodeUncheckedCreateWithoutApplicableLearningPathsInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutApplicableLearningPathsInput | PromoCodeCreateOrConnectWithoutApplicableLearningPathsInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutApplicableLearningPathsInput | PromoCodeUpsertWithWhereUniqueWithoutApplicableLearningPathsInput[]
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutApplicableLearningPathsInput | PromoCodeUpdateWithWhereUniqueWithoutApplicableLearningPathsInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutApplicableLearningPathsInput | PromoCodeUpdateManyWithWhereWithoutApplicableLearningPathsInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type PromotionUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<PromotionCreateWithoutLearningPathInput, PromotionUncheckedCreateWithoutLearningPathInput> | PromotionCreateWithoutLearningPathInput[] | PromotionUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutLearningPathInput | PromotionCreateOrConnectWithoutLearningPathInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutLearningPathInput | PromotionUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: PromotionCreateManyLearningPathInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutLearningPathInput | PromotionUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutLearningPathInput | PromotionUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<EnrollmentCreateWithoutLearningPathInput, EnrollmentUncheckedCreateWithoutLearningPathInput> | EnrollmentCreateWithoutLearningPathInput[] | EnrollmentUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutLearningPathInput | EnrollmentCreateOrConnectWithoutLearningPathInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutLearningPathInput | EnrollmentUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: EnrollmentCreateManyLearningPathInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutLearningPathInput | EnrollmentUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutLearningPathInput | EnrollmentUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<PaymentCreateWithoutLearningPathInput, PaymentUncheckedCreateWithoutLearningPathInput> | PaymentCreateWithoutLearningPathInput[] | PaymentUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLearningPathInput | PaymentCreateOrConnectWithoutLearningPathInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutLearningPathInput | PaymentUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: PaymentCreateManyLearningPathInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutLearningPathInput | PaymentUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutLearningPathInput | PaymentUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type LearningPathTagUncheckedUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<LearningPathTagCreateWithoutLearningPathInput, LearningPathTagUncheckedCreateWithoutLearningPathInput> | LearningPathTagCreateWithoutLearningPathInput[] | LearningPathTagUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathTagCreateOrConnectWithoutLearningPathInput | LearningPathTagCreateOrConnectWithoutLearningPathInput[]
    upsert?: LearningPathTagUpsertWithWhereUniqueWithoutLearningPathInput | LearningPathTagUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: LearningPathTagCreateManyLearningPathInputEnvelope
    set?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    disconnect?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    delete?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    connect?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    update?: LearningPathTagUpdateWithWhereUniqueWithoutLearningPathInput | LearningPathTagUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: LearningPathTagUpdateManyWithWhereWithoutLearningPathInput | LearningPathTagUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: LearningPathTagScalarWhereInput | LearningPathTagScalarWhereInput[]
  }

  export type LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<LearningPathItemCreateWithoutLearningPathInput, LearningPathItemUncheckedCreateWithoutLearningPathInput> | LearningPathItemCreateWithoutLearningPathInput[] | LearningPathItemUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutLearningPathInput | LearningPathItemCreateOrConnectWithoutLearningPathInput[]
    upsert?: LearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput | LearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: LearningPathItemCreateManyLearningPathInputEnvelope
    set?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    disconnect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    delete?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    update?: LearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput | LearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: LearningPathItemUpdateManyWithWhereWithoutLearningPathInput | LearningPathItemUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutPathNestedInput = {
    create?: XOR<UserProgressCreateWithoutPathInput, UserProgressUncheckedCreateWithoutPathInput> | UserProgressCreateWithoutPathInput[] | UserProgressUncheckedCreateWithoutPathInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutPathInput | UserProgressCreateOrConnectWithoutPathInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutPathInput | UserProgressUpsertWithWhereUniqueWithoutPathInput[]
    createMany?: UserProgressCreateManyPathInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutPathInput | UserProgressUpdateWithWhereUniqueWithoutPathInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutPathInput | UserProgressUpdateManyWithWhereWithoutPathInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type LearningPathResourceUncheckedUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<LearningPathResourceCreateWithoutLearningPathInput, LearningPathResourceUncheckedCreateWithoutLearningPathInput> | LearningPathResourceCreateWithoutLearningPathInput[] | LearningPathResourceUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathResourceCreateOrConnectWithoutLearningPathInput | LearningPathResourceCreateOrConnectWithoutLearningPathInput[]
    upsert?: LearningPathResourceUpsertWithWhereUniqueWithoutLearningPathInput | LearningPathResourceUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: LearningPathResourceCreateManyLearningPathInputEnvelope
    set?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    disconnect?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    delete?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    connect?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    update?: LearningPathResourceUpdateWithWhereUniqueWithoutLearningPathInput | LearningPathResourceUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: LearningPathResourceUpdateManyWithWhereWithoutLearningPathInput | LearningPathResourceUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: LearningPathResourceScalarWhereInput | LearningPathResourceScalarWhereInput[]
  }

  export type LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<LearningPathObjectiveCreateWithoutLearningPathInput, LearningPathObjectiveUncheckedCreateWithoutLearningPathInput> | LearningPathObjectiveCreateWithoutLearningPathInput[] | LearningPathObjectiveUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathObjectiveCreateOrConnectWithoutLearningPathInput | LearningPathObjectiveCreateOrConnectWithoutLearningPathInput[]
    upsert?: LearningPathObjectiveUpsertWithWhereUniqueWithoutLearningPathInput | LearningPathObjectiveUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: LearningPathObjectiveCreateManyLearningPathInputEnvelope
    set?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    disconnect?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    delete?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    connect?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    update?: LearningPathObjectiveUpdateWithWhereUniqueWithoutLearningPathInput | LearningPathObjectiveUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: LearningPathObjectiveUpdateManyWithWhereWithoutLearningPathInput | LearningPathObjectiveUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: LearningPathObjectiveScalarWhereInput | LearningPathObjectiveScalarWhereInput[]
  }

  export type LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<LearningPathPrerequisiteCreateWithoutLearningPathInput, LearningPathPrerequisiteUncheckedCreateWithoutLearningPathInput> | LearningPathPrerequisiteCreateWithoutLearningPathInput[] | LearningPathPrerequisiteUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathPrerequisiteCreateOrConnectWithoutLearningPathInput | LearningPathPrerequisiteCreateOrConnectWithoutLearningPathInput[]
    upsert?: LearningPathPrerequisiteUpsertWithWhereUniqueWithoutLearningPathInput | LearningPathPrerequisiteUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: LearningPathPrerequisiteCreateManyLearningPathInputEnvelope
    set?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    disconnect?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    delete?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    connect?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    update?: LearningPathPrerequisiteUpdateWithWhereUniqueWithoutLearningPathInput | LearningPathPrerequisiteUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: LearningPathPrerequisiteUpdateManyWithWhereWithoutLearningPathInput | LearningPathPrerequisiteUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: LearningPathPrerequisiteScalarWhereInput | LearningPathPrerequisiteScalarWhereInput[]
  }

  export type PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsNestedInput = {
    create?: XOR<PromoCodeCreateWithoutApplicableLearningPathsInput, PromoCodeUncheckedCreateWithoutApplicableLearningPathsInput> | PromoCodeCreateWithoutApplicableLearningPathsInput[] | PromoCodeUncheckedCreateWithoutApplicableLearningPathsInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutApplicableLearningPathsInput | PromoCodeCreateOrConnectWithoutApplicableLearningPathsInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutApplicableLearningPathsInput | PromoCodeUpsertWithWhereUniqueWithoutApplicableLearningPathsInput[]
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutApplicableLearningPathsInput | PromoCodeUpdateWithWhereUniqueWithoutApplicableLearningPathsInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutApplicableLearningPathsInput | PromoCodeUpdateManyWithWhereWithoutApplicableLearningPathsInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type PromotionUncheckedUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<PromotionCreateWithoutLearningPathInput, PromotionUncheckedCreateWithoutLearningPathInput> | PromotionCreateWithoutLearningPathInput[] | PromotionUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutLearningPathInput | PromotionCreateOrConnectWithoutLearningPathInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutLearningPathInput | PromotionUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: PromotionCreateManyLearningPathInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutLearningPathInput | PromotionUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutLearningPathInput | PromotionUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<EnrollmentCreateWithoutLearningPathInput, EnrollmentUncheckedCreateWithoutLearningPathInput> | EnrollmentCreateWithoutLearningPathInput[] | EnrollmentUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutLearningPathInput | EnrollmentCreateOrConnectWithoutLearningPathInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutLearningPathInput | EnrollmentUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: EnrollmentCreateManyLearningPathInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutLearningPathInput | EnrollmentUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutLearningPathInput | EnrollmentUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<PaymentCreateWithoutLearningPathInput, PaymentUncheckedCreateWithoutLearningPathInput> | PaymentCreateWithoutLearningPathInput[] | PaymentUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLearningPathInput | PaymentCreateOrConnectWithoutLearningPathInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutLearningPathInput | PaymentUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: PaymentCreateManyLearningPathInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutLearningPathInput | PaymentUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutLearningPathInput | PaymentUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type LearningPathCreateNestedOneWithoutContentsInput = {
    create?: XOR<LearningPathCreateWithoutContentsInput, LearningPathUncheckedCreateWithoutContentsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutContentsInput
    connect?: LearningPathWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutLearningPathItemsInput = {
    create?: XOR<CourseCreateWithoutLearningPathItemsInput, CourseUncheckedCreateWithoutLearningPathItemsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLearningPathItemsInput
    connect?: CourseWhereUniqueInput
  }

  export type WorkshopCreateNestedOneWithoutLearningPathItemsInput = {
    create?: XOR<WorkshopCreateWithoutLearningPathItemsInput, WorkshopUncheckedCreateWithoutLearningPathItemsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutLearningPathItemsInput
    connect?: WorkshopWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutLearningPathItemsInput = {
    create?: XOR<ResourceCreateWithoutLearningPathItemsInput, ResourceUncheckedCreateWithoutLearningPathItemsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutLearningPathItemsInput
    connect?: ResourceWhereUniqueInput
  }

  export type LearningPathUpdateOneRequiredWithoutContentsNestedInput = {
    create?: XOR<LearningPathCreateWithoutContentsInput, LearningPathUncheckedCreateWithoutContentsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutContentsInput
    upsert?: LearningPathUpsertWithoutContentsInput
    connect?: LearningPathWhereUniqueInput
    update?: XOR<XOR<LearningPathUpdateToOneWithWhereWithoutContentsInput, LearningPathUpdateWithoutContentsInput>, LearningPathUncheckedUpdateWithoutContentsInput>
  }

  export type CourseUpdateOneWithoutLearningPathItemsNestedInput = {
    create?: XOR<CourseCreateWithoutLearningPathItemsInput, CourseUncheckedCreateWithoutLearningPathItemsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLearningPathItemsInput
    upsert?: CourseUpsertWithoutLearningPathItemsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutLearningPathItemsInput, CourseUpdateWithoutLearningPathItemsInput>, CourseUncheckedUpdateWithoutLearningPathItemsInput>
  }

  export type WorkshopUpdateOneWithoutLearningPathItemsNestedInput = {
    create?: XOR<WorkshopCreateWithoutLearningPathItemsInput, WorkshopUncheckedCreateWithoutLearningPathItemsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutLearningPathItemsInput
    upsert?: WorkshopUpsertWithoutLearningPathItemsInput
    disconnect?: WorkshopWhereInput | boolean
    delete?: WorkshopWhereInput | boolean
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutLearningPathItemsInput, WorkshopUpdateWithoutLearningPathItemsInput>, WorkshopUncheckedUpdateWithoutLearningPathItemsInput>
  }

  export type ResourceUpdateOneWithoutLearningPathItemsNestedInput = {
    create?: XOR<ResourceCreateWithoutLearningPathItemsInput, ResourceUncheckedCreateWithoutLearningPathItemsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutLearningPathItemsInput
    upsert?: ResourceUpsertWithoutLearningPathItemsInput
    disconnect?: ResourceWhereInput | boolean
    delete?: ResourceWhereInput | boolean
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutLearningPathItemsInput, ResourceUpdateWithoutLearningPathItemsInput>, ResourceUncheckedUpdateWithoutLearningPathItemsInput>
  }

  export type UserCreateNestedOneWithoutCoursesInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type ChapterCreateNestedManyWithoutCourseInput = {
    create?: XOR<ChapterCreateWithoutCourseInput, ChapterUncheckedCreateWithoutCourseInput> | ChapterCreateWithoutCourseInput[] | ChapterUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutCourseInput | ChapterCreateOrConnectWithoutCourseInput[]
    createMany?: ChapterCreateManyCourseInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutCoursesInput = {
    create?: XOR<CategoryCreateWithoutCoursesInput, CategoryUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutCoursesInput
    connect?: CategoryWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutCourseInput = {
    create?: XOR<PaymentCreateWithoutCourseInput, PaymentUncheckedCreateWithoutCourseInput> | PaymentCreateWithoutCourseInput[] | PaymentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCourseInput | PaymentCreateOrConnectWithoutCourseInput[]
    createMany?: PaymentCreateManyCourseInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PromotionCreateNestedManyWithoutCourseInput = {
    create?: XOR<PromotionCreateWithoutCourseInput, PromotionUncheckedCreateWithoutCourseInput> | PromotionCreateWithoutCourseInput[] | PromotionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutCourseInput | PromotionCreateOrConnectWithoutCourseInput[]
    createMany?: PromotionCreateManyCourseInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type PromoCodeCreateNestedManyWithoutApplicableCoursesInput = {
    create?: XOR<PromoCodeCreateWithoutApplicableCoursesInput, PromoCodeUncheckedCreateWithoutApplicableCoursesInput> | PromoCodeCreateWithoutApplicableCoursesInput[] | PromoCodeUncheckedCreateWithoutApplicableCoursesInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutApplicableCoursesInput | PromoCodeCreateOrConnectWithoutApplicableCoursesInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type CourseTagCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput> | CourseTagCreateWithoutCourseInput[] | CourseTagUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutCourseInput | CourseTagCreateOrConnectWithoutCourseInput[]
    createMany?: CourseTagCreateManyCourseInputEnvelope
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
  }

  export type UserProgressCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserProgressCreateWithoutCourseInput, UserProgressUncheckedCreateWithoutCourseInput> | UserProgressCreateWithoutCourseInput[] | UserProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutCourseInput | UserProgressCreateOrConnectWithoutCourseInput[]
    createMany?: UserProgressCreateManyCourseInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type CourseResourceCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseResourceCreateWithoutCourseInput, CourseResourceUncheckedCreateWithoutCourseInput> | CourseResourceCreateWithoutCourseInput[] | CourseResourceUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseResourceCreateOrConnectWithoutCourseInput | CourseResourceCreateOrConnectWithoutCourseInput[]
    createMany?: CourseResourceCreateManyCourseInputEnvelope
    connect?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
  }

  export type LearningPathItemCreateNestedManyWithoutCourseInput = {
    create?: XOR<LearningPathItemCreateWithoutCourseInput, LearningPathItemUncheckedCreateWithoutCourseInput> | LearningPathItemCreateWithoutCourseInput[] | LearningPathItemUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutCourseInput | LearningPathItemCreateOrConnectWithoutCourseInput[]
    createMany?: LearningPathItemCreateManyCourseInputEnvelope
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
  }

  export type CourseObjectiveCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseObjectiveCreateWithoutCourseInput, CourseObjectiveUncheckedCreateWithoutCourseInput> | CourseObjectiveCreateWithoutCourseInput[] | CourseObjectiveUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseObjectiveCreateOrConnectWithoutCourseInput | CourseObjectiveCreateOrConnectWithoutCourseInput[]
    createMany?: CourseObjectiveCreateManyCourseInputEnvelope
    connect?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
  }

  export type CoursePrerequisiteCreateNestedManyWithoutCourseInput = {
    create?: XOR<CoursePrerequisiteCreateWithoutCourseInput, CoursePrerequisiteUncheckedCreateWithoutCourseInput> | CoursePrerequisiteCreateWithoutCourseInput[] | CoursePrerequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CoursePrerequisiteCreateOrConnectWithoutCourseInput | CoursePrerequisiteCreateOrConnectWithoutCourseInput[]
    createMany?: CoursePrerequisiteCreateManyCourseInputEnvelope
    connect?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
  }

  export type ChapterUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ChapterCreateWithoutCourseInput, ChapterUncheckedCreateWithoutCourseInput> | ChapterCreateWithoutCourseInput[] | ChapterUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutCourseInput | ChapterCreateOrConnectWithoutCourseInput[]
    createMany?: ChapterCreateManyCourseInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<PaymentCreateWithoutCourseInput, PaymentUncheckedCreateWithoutCourseInput> | PaymentCreateWithoutCourseInput[] | PaymentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCourseInput | PaymentCreateOrConnectWithoutCourseInput[]
    createMany?: PaymentCreateManyCourseInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PromotionUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<PromotionCreateWithoutCourseInput, PromotionUncheckedCreateWithoutCourseInput> | PromotionCreateWithoutCourseInput[] | PromotionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutCourseInput | PromotionCreateOrConnectWithoutCourseInput[]
    createMany?: PromotionCreateManyCourseInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput = {
    create?: XOR<PromoCodeCreateWithoutApplicableCoursesInput, PromoCodeUncheckedCreateWithoutApplicableCoursesInput> | PromoCodeCreateWithoutApplicableCoursesInput[] | PromoCodeUncheckedCreateWithoutApplicableCoursesInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutApplicableCoursesInput | PromoCodeCreateOrConnectWithoutApplicableCoursesInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type CourseTagUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput> | CourseTagCreateWithoutCourseInput[] | CourseTagUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutCourseInput | CourseTagCreateOrConnectWithoutCourseInput[]
    createMany?: CourseTagCreateManyCourseInputEnvelope
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserProgressCreateWithoutCourseInput, UserProgressUncheckedCreateWithoutCourseInput> | UserProgressCreateWithoutCourseInput[] | UserProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutCourseInput | UserProgressCreateOrConnectWithoutCourseInput[]
    createMany?: UserProgressCreateManyCourseInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type CourseResourceUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseResourceCreateWithoutCourseInput, CourseResourceUncheckedCreateWithoutCourseInput> | CourseResourceCreateWithoutCourseInput[] | CourseResourceUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseResourceCreateOrConnectWithoutCourseInput | CourseResourceCreateOrConnectWithoutCourseInput[]
    createMany?: CourseResourceCreateManyCourseInputEnvelope
    connect?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
  }

  export type LearningPathItemUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<LearningPathItemCreateWithoutCourseInput, LearningPathItemUncheckedCreateWithoutCourseInput> | LearningPathItemCreateWithoutCourseInput[] | LearningPathItemUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutCourseInput | LearningPathItemCreateOrConnectWithoutCourseInput[]
    createMany?: LearningPathItemCreateManyCourseInputEnvelope
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
  }

  export type CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseObjectiveCreateWithoutCourseInput, CourseObjectiveUncheckedCreateWithoutCourseInput> | CourseObjectiveCreateWithoutCourseInput[] | CourseObjectiveUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseObjectiveCreateOrConnectWithoutCourseInput | CourseObjectiveCreateOrConnectWithoutCourseInput[]
    createMany?: CourseObjectiveCreateManyCourseInputEnvelope
    connect?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
  }

  export type CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CoursePrerequisiteCreateWithoutCourseInput, CoursePrerequisiteUncheckedCreateWithoutCourseInput> | CoursePrerequisiteCreateWithoutCourseInput[] | CoursePrerequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CoursePrerequisiteCreateOrConnectWithoutCourseInput | CoursePrerequisiteCreateOrConnectWithoutCourseInput[]
    createMany?: CoursePrerequisiteCreateManyCourseInputEnvelope
    connect?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCoursesNestedInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    upsert?: UserUpsertWithoutCoursesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoursesInput, UserUpdateWithoutCoursesInput>, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type ChapterUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ChapterCreateWithoutCourseInput, ChapterUncheckedCreateWithoutCourseInput> | ChapterCreateWithoutCourseInput[] | ChapterUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutCourseInput | ChapterCreateOrConnectWithoutCourseInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutCourseInput | ChapterUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ChapterCreateManyCourseInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutCourseInput | ChapterUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutCourseInput | ChapterUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type CategoryUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<CategoryCreateWithoutCoursesInput, CategoryUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutCoursesInput
    upsert?: CategoryUpsertWithoutCoursesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutCoursesInput, CategoryUpdateWithoutCoursesInput>, CategoryUncheckedUpdateWithoutCoursesInput>
  }

  export type PaymentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<PaymentCreateWithoutCourseInput, PaymentUncheckedCreateWithoutCourseInput> | PaymentCreateWithoutCourseInput[] | PaymentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCourseInput | PaymentCreateOrConnectWithoutCourseInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCourseInput | PaymentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: PaymentCreateManyCourseInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCourseInput | PaymentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCourseInput | PaymentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PromotionUpdateManyWithoutCourseNestedInput = {
    create?: XOR<PromotionCreateWithoutCourseInput, PromotionUncheckedCreateWithoutCourseInput> | PromotionCreateWithoutCourseInput[] | PromotionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutCourseInput | PromotionCreateOrConnectWithoutCourseInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutCourseInput | PromotionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: PromotionCreateManyCourseInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutCourseInput | PromotionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutCourseInput | PromotionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type PromoCodeUpdateManyWithoutApplicableCoursesNestedInput = {
    create?: XOR<PromoCodeCreateWithoutApplicableCoursesInput, PromoCodeUncheckedCreateWithoutApplicableCoursesInput> | PromoCodeCreateWithoutApplicableCoursesInput[] | PromoCodeUncheckedCreateWithoutApplicableCoursesInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutApplicableCoursesInput | PromoCodeCreateOrConnectWithoutApplicableCoursesInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutApplicableCoursesInput | PromoCodeUpsertWithWhereUniqueWithoutApplicableCoursesInput[]
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutApplicableCoursesInput | PromoCodeUpdateWithWhereUniqueWithoutApplicableCoursesInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutApplicableCoursesInput | PromoCodeUpdateManyWithWhereWithoutApplicableCoursesInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type CourseTagUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput> | CourseTagCreateWithoutCourseInput[] | CourseTagUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutCourseInput | CourseTagCreateOrConnectWithoutCourseInput[]
    upsert?: CourseTagUpsertWithWhereUniqueWithoutCourseInput | CourseTagUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseTagCreateManyCourseInputEnvelope
    set?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    disconnect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    delete?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    update?: CourseTagUpdateWithWhereUniqueWithoutCourseInput | CourseTagUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseTagUpdateManyWithWhereWithoutCourseInput | CourseTagUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
  }

  export type UserProgressUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserProgressCreateWithoutCourseInput, UserProgressUncheckedCreateWithoutCourseInput> | UserProgressCreateWithoutCourseInput[] | UserProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutCourseInput | UserProgressCreateOrConnectWithoutCourseInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutCourseInput | UserProgressUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserProgressCreateManyCourseInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutCourseInput | UserProgressUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutCourseInput | UserProgressUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type CourseResourceUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseResourceCreateWithoutCourseInput, CourseResourceUncheckedCreateWithoutCourseInput> | CourseResourceCreateWithoutCourseInput[] | CourseResourceUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseResourceCreateOrConnectWithoutCourseInput | CourseResourceCreateOrConnectWithoutCourseInput[]
    upsert?: CourseResourceUpsertWithWhereUniqueWithoutCourseInput | CourseResourceUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseResourceCreateManyCourseInputEnvelope
    set?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    disconnect?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    delete?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    connect?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    update?: CourseResourceUpdateWithWhereUniqueWithoutCourseInput | CourseResourceUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseResourceUpdateManyWithWhereWithoutCourseInput | CourseResourceUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseResourceScalarWhereInput | CourseResourceScalarWhereInput[]
  }

  export type LearningPathItemUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LearningPathItemCreateWithoutCourseInput, LearningPathItemUncheckedCreateWithoutCourseInput> | LearningPathItemCreateWithoutCourseInput[] | LearningPathItemUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutCourseInput | LearningPathItemCreateOrConnectWithoutCourseInput[]
    upsert?: LearningPathItemUpsertWithWhereUniqueWithoutCourseInput | LearningPathItemUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LearningPathItemCreateManyCourseInputEnvelope
    set?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    disconnect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    delete?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    update?: LearningPathItemUpdateWithWhereUniqueWithoutCourseInput | LearningPathItemUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LearningPathItemUpdateManyWithWhereWithoutCourseInput | LearningPathItemUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
  }

  export type CourseObjectiveUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseObjectiveCreateWithoutCourseInput, CourseObjectiveUncheckedCreateWithoutCourseInput> | CourseObjectiveCreateWithoutCourseInput[] | CourseObjectiveUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseObjectiveCreateOrConnectWithoutCourseInput | CourseObjectiveCreateOrConnectWithoutCourseInput[]
    upsert?: CourseObjectiveUpsertWithWhereUniqueWithoutCourseInput | CourseObjectiveUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseObjectiveCreateManyCourseInputEnvelope
    set?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    disconnect?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    delete?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    connect?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    update?: CourseObjectiveUpdateWithWhereUniqueWithoutCourseInput | CourseObjectiveUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseObjectiveUpdateManyWithWhereWithoutCourseInput | CourseObjectiveUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseObjectiveScalarWhereInput | CourseObjectiveScalarWhereInput[]
  }

  export type CoursePrerequisiteUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CoursePrerequisiteCreateWithoutCourseInput, CoursePrerequisiteUncheckedCreateWithoutCourseInput> | CoursePrerequisiteCreateWithoutCourseInput[] | CoursePrerequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CoursePrerequisiteCreateOrConnectWithoutCourseInput | CoursePrerequisiteCreateOrConnectWithoutCourseInput[]
    upsert?: CoursePrerequisiteUpsertWithWhereUniqueWithoutCourseInput | CoursePrerequisiteUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CoursePrerequisiteCreateManyCourseInputEnvelope
    set?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    disconnect?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    delete?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    connect?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    update?: CoursePrerequisiteUpdateWithWhereUniqueWithoutCourseInput | CoursePrerequisiteUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CoursePrerequisiteUpdateManyWithWhereWithoutCourseInput | CoursePrerequisiteUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CoursePrerequisiteScalarWhereInput | CoursePrerequisiteScalarWhereInput[]
  }

  export type ChapterUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ChapterCreateWithoutCourseInput, ChapterUncheckedCreateWithoutCourseInput> | ChapterCreateWithoutCourseInput[] | ChapterUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutCourseInput | ChapterCreateOrConnectWithoutCourseInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutCourseInput | ChapterUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ChapterCreateManyCourseInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutCourseInput | ChapterUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutCourseInput | ChapterUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<PaymentCreateWithoutCourseInput, PaymentUncheckedCreateWithoutCourseInput> | PaymentCreateWithoutCourseInput[] | PaymentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCourseInput | PaymentCreateOrConnectWithoutCourseInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCourseInput | PaymentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: PaymentCreateManyCourseInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCourseInput | PaymentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCourseInput | PaymentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PromotionUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<PromotionCreateWithoutCourseInput, PromotionUncheckedCreateWithoutCourseInput> | PromotionCreateWithoutCourseInput[] | PromotionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutCourseInput | PromotionCreateOrConnectWithoutCourseInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutCourseInput | PromotionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: PromotionCreateManyCourseInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutCourseInput | PromotionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutCourseInput | PromotionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput = {
    create?: XOR<PromoCodeCreateWithoutApplicableCoursesInput, PromoCodeUncheckedCreateWithoutApplicableCoursesInput> | PromoCodeCreateWithoutApplicableCoursesInput[] | PromoCodeUncheckedCreateWithoutApplicableCoursesInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutApplicableCoursesInput | PromoCodeCreateOrConnectWithoutApplicableCoursesInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutApplicableCoursesInput | PromoCodeUpsertWithWhereUniqueWithoutApplicableCoursesInput[]
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutApplicableCoursesInput | PromoCodeUpdateWithWhereUniqueWithoutApplicableCoursesInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutApplicableCoursesInput | PromoCodeUpdateManyWithWhereWithoutApplicableCoursesInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type CourseTagUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput> | CourseTagCreateWithoutCourseInput[] | CourseTagUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutCourseInput | CourseTagCreateOrConnectWithoutCourseInput[]
    upsert?: CourseTagUpsertWithWhereUniqueWithoutCourseInput | CourseTagUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseTagCreateManyCourseInputEnvelope
    set?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    disconnect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    delete?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    update?: CourseTagUpdateWithWhereUniqueWithoutCourseInput | CourseTagUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseTagUpdateManyWithWhereWithoutCourseInput | CourseTagUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserProgressCreateWithoutCourseInput, UserProgressUncheckedCreateWithoutCourseInput> | UserProgressCreateWithoutCourseInput[] | UserProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutCourseInput | UserProgressCreateOrConnectWithoutCourseInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutCourseInput | UserProgressUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserProgressCreateManyCourseInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutCourseInput | UserProgressUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutCourseInput | UserProgressUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type CourseResourceUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseResourceCreateWithoutCourseInput, CourseResourceUncheckedCreateWithoutCourseInput> | CourseResourceCreateWithoutCourseInput[] | CourseResourceUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseResourceCreateOrConnectWithoutCourseInput | CourseResourceCreateOrConnectWithoutCourseInput[]
    upsert?: CourseResourceUpsertWithWhereUniqueWithoutCourseInput | CourseResourceUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseResourceCreateManyCourseInputEnvelope
    set?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    disconnect?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    delete?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    connect?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    update?: CourseResourceUpdateWithWhereUniqueWithoutCourseInput | CourseResourceUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseResourceUpdateManyWithWhereWithoutCourseInput | CourseResourceUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseResourceScalarWhereInput | CourseResourceScalarWhereInput[]
  }

  export type LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LearningPathItemCreateWithoutCourseInput, LearningPathItemUncheckedCreateWithoutCourseInput> | LearningPathItemCreateWithoutCourseInput[] | LearningPathItemUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutCourseInput | LearningPathItemCreateOrConnectWithoutCourseInput[]
    upsert?: LearningPathItemUpsertWithWhereUniqueWithoutCourseInput | LearningPathItemUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LearningPathItemCreateManyCourseInputEnvelope
    set?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    disconnect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    delete?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    update?: LearningPathItemUpdateWithWhereUniqueWithoutCourseInput | LearningPathItemUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LearningPathItemUpdateManyWithWhereWithoutCourseInput | LearningPathItemUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
  }

  export type CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseObjectiveCreateWithoutCourseInput, CourseObjectiveUncheckedCreateWithoutCourseInput> | CourseObjectiveCreateWithoutCourseInput[] | CourseObjectiveUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseObjectiveCreateOrConnectWithoutCourseInput | CourseObjectiveCreateOrConnectWithoutCourseInput[]
    upsert?: CourseObjectiveUpsertWithWhereUniqueWithoutCourseInput | CourseObjectiveUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseObjectiveCreateManyCourseInputEnvelope
    set?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    disconnect?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    delete?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    connect?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    update?: CourseObjectiveUpdateWithWhereUniqueWithoutCourseInput | CourseObjectiveUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseObjectiveUpdateManyWithWhereWithoutCourseInput | CourseObjectiveUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseObjectiveScalarWhereInput | CourseObjectiveScalarWhereInput[]
  }

  export type CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CoursePrerequisiteCreateWithoutCourseInput, CoursePrerequisiteUncheckedCreateWithoutCourseInput> | CoursePrerequisiteCreateWithoutCourseInput[] | CoursePrerequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CoursePrerequisiteCreateOrConnectWithoutCourseInput | CoursePrerequisiteCreateOrConnectWithoutCourseInput[]
    upsert?: CoursePrerequisiteUpsertWithWhereUniqueWithoutCourseInput | CoursePrerequisiteUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CoursePrerequisiteCreateManyCourseInputEnvelope
    set?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    disconnect?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    delete?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    connect?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    update?: CoursePrerequisiteUpdateWithWhereUniqueWithoutCourseInput | CoursePrerequisiteUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CoursePrerequisiteUpdateManyWithWhereWithoutCourseInput | CoursePrerequisiteUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CoursePrerequisiteScalarWhereInput | CoursePrerequisiteScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutChaptersInput = {
    create?: XOR<CourseCreateWithoutChaptersInput, CourseUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: CourseCreateOrConnectWithoutChaptersInput
    connect?: CourseWhereUniqueInput
  }

  export type LessonCreateNestedManyWithoutChapterInput = {
    create?: XOR<LessonCreateWithoutChapterInput, LessonUncheckedCreateWithoutChapterInput> | LessonCreateWithoutChapterInput[] | LessonUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutChapterInput | LessonCreateOrConnectWithoutChapterInput[]
    createMany?: LessonCreateManyChapterInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<LessonCreateWithoutChapterInput, LessonUncheckedCreateWithoutChapterInput> | LessonCreateWithoutChapterInput[] | LessonUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutChapterInput | LessonCreateOrConnectWithoutChapterInput[]
    createMany?: LessonCreateManyChapterInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<CourseCreateWithoutChaptersInput, CourseUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: CourseCreateOrConnectWithoutChaptersInput
    upsert?: CourseUpsertWithoutChaptersInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutChaptersInput, CourseUpdateWithoutChaptersInput>, CourseUncheckedUpdateWithoutChaptersInput>
  }

  export type LessonUpdateManyWithoutChapterNestedInput = {
    create?: XOR<LessonCreateWithoutChapterInput, LessonUncheckedCreateWithoutChapterInput> | LessonCreateWithoutChapterInput[] | LessonUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutChapterInput | LessonCreateOrConnectWithoutChapterInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutChapterInput | LessonUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: LessonCreateManyChapterInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutChapterInput | LessonUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutChapterInput | LessonUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<LessonCreateWithoutChapterInput, LessonUncheckedCreateWithoutChapterInput> | LessonCreateWithoutChapterInput[] | LessonUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutChapterInput | LessonCreateOrConnectWithoutChapterInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutChapterInput | LessonUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: LessonCreateManyChapterInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutChapterInput | LessonUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutChapterInput | LessonUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type ChapterCreateNestedOneWithoutLessonsInput = {
    create?: XOR<ChapterCreateWithoutLessonsInput, ChapterUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutLessonsInput
    connect?: ChapterWhereUniqueInput
  }

  export type LessonProgressCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput> | LessonProgressCreateWithoutLessonInput[] | LessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutLessonInput | LessonProgressCreateOrConnectWithoutLessonInput[]
    createMany?: LessonProgressCreateManyLessonInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type LessonResourceCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonResourceCreateWithoutLessonInput, LessonResourceUncheckedCreateWithoutLessonInput> | LessonResourceCreateWithoutLessonInput[] | LessonResourceUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonResourceCreateOrConnectWithoutLessonInput | LessonResourceCreateOrConnectWithoutLessonInput[]
    createMany?: LessonResourceCreateManyLessonInputEnvelope
    connect?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
  }

  export type LessonProgressUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput> | LessonProgressCreateWithoutLessonInput[] | LessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutLessonInput | LessonProgressCreateOrConnectWithoutLessonInput[]
    createMany?: LessonProgressCreateManyLessonInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type LessonResourceUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonResourceCreateWithoutLessonInput, LessonResourceUncheckedCreateWithoutLessonInput> | LessonResourceCreateWithoutLessonInput[] | LessonResourceUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonResourceCreateOrConnectWithoutLessonInput | LessonResourceCreateOrConnectWithoutLessonInput[]
    createMany?: LessonResourceCreateManyLessonInputEnvelope
    connect?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
  }

  export type ChapterUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<ChapterCreateWithoutLessonsInput, ChapterUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutLessonsInput
    upsert?: ChapterUpsertWithoutLessonsInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutLessonsInput, ChapterUpdateWithoutLessonsInput>, ChapterUncheckedUpdateWithoutLessonsInput>
  }

  export type LessonProgressUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput> | LessonProgressCreateWithoutLessonInput[] | LessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutLessonInput | LessonProgressCreateOrConnectWithoutLessonInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutLessonInput | LessonProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonProgressCreateManyLessonInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutLessonInput | LessonProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutLessonInput | LessonProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type LessonResourceUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonResourceCreateWithoutLessonInput, LessonResourceUncheckedCreateWithoutLessonInput> | LessonResourceCreateWithoutLessonInput[] | LessonResourceUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonResourceCreateOrConnectWithoutLessonInput | LessonResourceCreateOrConnectWithoutLessonInput[]
    upsert?: LessonResourceUpsertWithWhereUniqueWithoutLessonInput | LessonResourceUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonResourceCreateManyLessonInputEnvelope
    set?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    disconnect?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    delete?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    connect?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    update?: LessonResourceUpdateWithWhereUniqueWithoutLessonInput | LessonResourceUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonResourceUpdateManyWithWhereWithoutLessonInput | LessonResourceUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonResourceScalarWhereInput | LessonResourceScalarWhereInput[]
  }

  export type LessonProgressUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput> | LessonProgressCreateWithoutLessonInput[] | LessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutLessonInput | LessonProgressCreateOrConnectWithoutLessonInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutLessonInput | LessonProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonProgressCreateManyLessonInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutLessonInput | LessonProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutLessonInput | LessonProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type LessonResourceUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonResourceCreateWithoutLessonInput, LessonResourceUncheckedCreateWithoutLessonInput> | LessonResourceCreateWithoutLessonInput[] | LessonResourceUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonResourceCreateOrConnectWithoutLessonInput | LessonResourceCreateOrConnectWithoutLessonInput[]
    upsert?: LessonResourceUpsertWithWhereUniqueWithoutLessonInput | LessonResourceUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonResourceCreateManyLessonInputEnvelope
    set?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    disconnect?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    delete?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    connect?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    update?: LessonResourceUpdateWithWhereUniqueWithoutLessonInput | LessonResourceUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonResourceUpdateManyWithWhereWithoutLessonInput | LessonResourceUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonResourceScalarWhereInput | LessonResourceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWorkshopsInput = {
    create?: XOR<UserCreateWithoutWorkshopsInput, UserUncheckedCreateWithoutWorkshopsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkshopsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkshopTagCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopTagCreateWithoutWorkshopInput, WorkshopTagUncheckedCreateWithoutWorkshopInput> | WorkshopTagCreateWithoutWorkshopInput[] | WorkshopTagUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopTagCreateOrConnectWithoutWorkshopInput | WorkshopTagCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopTagCreateManyWorkshopInputEnvelope
    connect?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
  }

  export type UserProgressCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<UserProgressCreateWithoutWorkshopInput, UserProgressUncheckedCreateWithoutWorkshopInput> | UserProgressCreateWithoutWorkshopInput[] | UserProgressUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutWorkshopInput | UserProgressCreateOrConnectWithoutWorkshopInput[]
    createMany?: UserProgressCreateManyWorkshopInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type WorkshopResourceCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopResourceCreateWithoutWorkshopInput, WorkshopResourceUncheckedCreateWithoutWorkshopInput> | WorkshopResourceCreateWithoutWorkshopInput[] | WorkshopResourceUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopResourceCreateOrConnectWithoutWorkshopInput | WorkshopResourceCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopResourceCreateManyWorkshopInputEnvelope
    connect?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
  }

  export type LearningPathItemCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<LearningPathItemCreateWithoutWorkshopInput, LearningPathItemUncheckedCreateWithoutWorkshopInput> | LearningPathItemCreateWithoutWorkshopInput[] | LearningPathItemUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutWorkshopInput | LearningPathItemCreateOrConnectWithoutWorkshopInput[]
    createMany?: LearningPathItemCreateManyWorkshopInputEnvelope
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
  }

  export type WorkshopObjectiveCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopObjectiveCreateWithoutWorkshopInput, WorkshopObjectiveUncheckedCreateWithoutWorkshopInput> | WorkshopObjectiveCreateWithoutWorkshopInput[] | WorkshopObjectiveUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopObjectiveCreateOrConnectWithoutWorkshopInput | WorkshopObjectiveCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopObjectiveCreateManyWorkshopInputEnvelope
    connect?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
  }

  export type WorkshopPrerequisiteCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopPrerequisiteCreateWithoutWorkshopInput, WorkshopPrerequisiteUncheckedCreateWithoutWorkshopInput> | WorkshopPrerequisiteCreateWithoutWorkshopInput[] | WorkshopPrerequisiteUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopPrerequisiteCreateOrConnectWithoutWorkshopInput | WorkshopPrerequisiteCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopPrerequisiteCreateManyWorkshopInputEnvelope
    connect?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
  }

  export type PromoCodeCreateNestedManyWithoutApplicableWorkshopsInput = {
    create?: XOR<PromoCodeCreateWithoutApplicableWorkshopsInput, PromoCodeUncheckedCreateWithoutApplicableWorkshopsInput> | PromoCodeCreateWithoutApplicableWorkshopsInput[] | PromoCodeUncheckedCreateWithoutApplicableWorkshopsInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutApplicableWorkshopsInput | PromoCodeCreateOrConnectWithoutApplicableWorkshopsInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type PromotionCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<PromotionCreateWithoutWorkshopInput, PromotionUncheckedCreateWithoutWorkshopInput> | PromotionCreateWithoutWorkshopInput[] | PromotionUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutWorkshopInput | PromotionCreateOrConnectWithoutWorkshopInput[]
    createMany?: PromotionCreateManyWorkshopInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<EnrollmentCreateWithoutWorkshopInput, EnrollmentUncheckedCreateWithoutWorkshopInput> | EnrollmentCreateWithoutWorkshopInput[] | EnrollmentUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutWorkshopInput | EnrollmentCreateOrConnectWithoutWorkshopInput[]
    createMany?: EnrollmentCreateManyWorkshopInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<PaymentCreateWithoutWorkshopInput, PaymentUncheckedCreateWithoutWorkshopInput> | PaymentCreateWithoutWorkshopInput[] | PaymentUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutWorkshopInput | PaymentCreateOrConnectWithoutWorkshopInput[]
    createMany?: PaymentCreateManyWorkshopInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type WorkshopTagUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopTagCreateWithoutWorkshopInput, WorkshopTagUncheckedCreateWithoutWorkshopInput> | WorkshopTagCreateWithoutWorkshopInput[] | WorkshopTagUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopTagCreateOrConnectWithoutWorkshopInput | WorkshopTagCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopTagCreateManyWorkshopInputEnvelope
    connect?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<UserProgressCreateWithoutWorkshopInput, UserProgressUncheckedCreateWithoutWorkshopInput> | UserProgressCreateWithoutWorkshopInput[] | UserProgressUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutWorkshopInput | UserProgressCreateOrConnectWithoutWorkshopInput[]
    createMany?: UserProgressCreateManyWorkshopInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type WorkshopResourceUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopResourceCreateWithoutWorkshopInput, WorkshopResourceUncheckedCreateWithoutWorkshopInput> | WorkshopResourceCreateWithoutWorkshopInput[] | WorkshopResourceUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopResourceCreateOrConnectWithoutWorkshopInput | WorkshopResourceCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopResourceCreateManyWorkshopInputEnvelope
    connect?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
  }

  export type LearningPathItemUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<LearningPathItemCreateWithoutWorkshopInput, LearningPathItemUncheckedCreateWithoutWorkshopInput> | LearningPathItemCreateWithoutWorkshopInput[] | LearningPathItemUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutWorkshopInput | LearningPathItemCreateOrConnectWithoutWorkshopInput[]
    createMany?: LearningPathItemCreateManyWorkshopInputEnvelope
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
  }

  export type WorkshopObjectiveUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopObjectiveCreateWithoutWorkshopInput, WorkshopObjectiveUncheckedCreateWithoutWorkshopInput> | WorkshopObjectiveCreateWithoutWorkshopInput[] | WorkshopObjectiveUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopObjectiveCreateOrConnectWithoutWorkshopInput | WorkshopObjectiveCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopObjectiveCreateManyWorkshopInputEnvelope
    connect?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
  }

  export type WorkshopPrerequisiteUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopPrerequisiteCreateWithoutWorkshopInput, WorkshopPrerequisiteUncheckedCreateWithoutWorkshopInput> | WorkshopPrerequisiteCreateWithoutWorkshopInput[] | WorkshopPrerequisiteUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopPrerequisiteCreateOrConnectWithoutWorkshopInput | WorkshopPrerequisiteCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopPrerequisiteCreateManyWorkshopInputEnvelope
    connect?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
  }

  export type PromoCodeUncheckedCreateNestedManyWithoutApplicableWorkshopsInput = {
    create?: XOR<PromoCodeCreateWithoutApplicableWorkshopsInput, PromoCodeUncheckedCreateWithoutApplicableWorkshopsInput> | PromoCodeCreateWithoutApplicableWorkshopsInput[] | PromoCodeUncheckedCreateWithoutApplicableWorkshopsInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutApplicableWorkshopsInput | PromoCodeCreateOrConnectWithoutApplicableWorkshopsInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type PromotionUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<PromotionCreateWithoutWorkshopInput, PromotionUncheckedCreateWithoutWorkshopInput> | PromotionCreateWithoutWorkshopInput[] | PromotionUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutWorkshopInput | PromotionCreateOrConnectWithoutWorkshopInput[]
    createMany?: PromotionCreateManyWorkshopInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<EnrollmentCreateWithoutWorkshopInput, EnrollmentUncheckedCreateWithoutWorkshopInput> | EnrollmentCreateWithoutWorkshopInput[] | EnrollmentUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutWorkshopInput | EnrollmentCreateOrConnectWithoutWorkshopInput[]
    createMany?: EnrollmentCreateManyWorkshopInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<PaymentCreateWithoutWorkshopInput, PaymentUncheckedCreateWithoutWorkshopInput> | PaymentCreateWithoutWorkshopInput[] | PaymentUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutWorkshopInput | PaymentCreateOrConnectWithoutWorkshopInput[]
    createMany?: PaymentCreateManyWorkshopInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutWorkshopsNestedInput = {
    create?: XOR<UserCreateWithoutWorkshopsInput, UserUncheckedCreateWithoutWorkshopsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkshopsInput
    upsert?: UserUpsertWithoutWorkshopsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkshopsInput, UserUpdateWithoutWorkshopsInput>, UserUncheckedUpdateWithoutWorkshopsInput>
  }

  export type WorkshopTagUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopTagCreateWithoutWorkshopInput, WorkshopTagUncheckedCreateWithoutWorkshopInput> | WorkshopTagCreateWithoutWorkshopInput[] | WorkshopTagUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopTagCreateOrConnectWithoutWorkshopInput | WorkshopTagCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopTagUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopTagUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopTagCreateManyWorkshopInputEnvelope
    set?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    disconnect?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    delete?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    connect?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    update?: WorkshopTagUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopTagUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopTagUpdateManyWithWhereWithoutWorkshopInput | WorkshopTagUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopTagScalarWhereInput | WorkshopTagScalarWhereInput[]
  }

  export type UserProgressUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<UserProgressCreateWithoutWorkshopInput, UserProgressUncheckedCreateWithoutWorkshopInput> | UserProgressCreateWithoutWorkshopInput[] | UserProgressUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutWorkshopInput | UserProgressCreateOrConnectWithoutWorkshopInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutWorkshopInput | UserProgressUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: UserProgressCreateManyWorkshopInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutWorkshopInput | UserProgressUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutWorkshopInput | UserProgressUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type WorkshopResourceUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopResourceCreateWithoutWorkshopInput, WorkshopResourceUncheckedCreateWithoutWorkshopInput> | WorkshopResourceCreateWithoutWorkshopInput[] | WorkshopResourceUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopResourceCreateOrConnectWithoutWorkshopInput | WorkshopResourceCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopResourceUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopResourceUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopResourceCreateManyWorkshopInputEnvelope
    set?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    disconnect?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    delete?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    connect?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    update?: WorkshopResourceUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopResourceUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopResourceUpdateManyWithWhereWithoutWorkshopInput | WorkshopResourceUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopResourceScalarWhereInput | WorkshopResourceScalarWhereInput[]
  }

  export type LearningPathItemUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<LearningPathItemCreateWithoutWorkshopInput, LearningPathItemUncheckedCreateWithoutWorkshopInput> | LearningPathItemCreateWithoutWorkshopInput[] | LearningPathItemUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutWorkshopInput | LearningPathItemCreateOrConnectWithoutWorkshopInput[]
    upsert?: LearningPathItemUpsertWithWhereUniqueWithoutWorkshopInput | LearningPathItemUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: LearningPathItemCreateManyWorkshopInputEnvelope
    set?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    disconnect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    delete?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    update?: LearningPathItemUpdateWithWhereUniqueWithoutWorkshopInput | LearningPathItemUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: LearningPathItemUpdateManyWithWhereWithoutWorkshopInput | LearningPathItemUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
  }

  export type WorkshopObjectiveUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopObjectiveCreateWithoutWorkshopInput, WorkshopObjectiveUncheckedCreateWithoutWorkshopInput> | WorkshopObjectiveCreateWithoutWorkshopInput[] | WorkshopObjectiveUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopObjectiveCreateOrConnectWithoutWorkshopInput | WorkshopObjectiveCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopObjectiveUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopObjectiveUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopObjectiveCreateManyWorkshopInputEnvelope
    set?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    disconnect?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    delete?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    connect?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    update?: WorkshopObjectiveUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopObjectiveUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopObjectiveUpdateManyWithWhereWithoutWorkshopInput | WorkshopObjectiveUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopObjectiveScalarWhereInput | WorkshopObjectiveScalarWhereInput[]
  }

  export type WorkshopPrerequisiteUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopPrerequisiteCreateWithoutWorkshopInput, WorkshopPrerequisiteUncheckedCreateWithoutWorkshopInput> | WorkshopPrerequisiteCreateWithoutWorkshopInput[] | WorkshopPrerequisiteUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopPrerequisiteCreateOrConnectWithoutWorkshopInput | WorkshopPrerequisiteCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopPrerequisiteUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopPrerequisiteUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopPrerequisiteCreateManyWorkshopInputEnvelope
    set?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    disconnect?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    delete?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    connect?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    update?: WorkshopPrerequisiteUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopPrerequisiteUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopPrerequisiteUpdateManyWithWhereWithoutWorkshopInput | WorkshopPrerequisiteUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopPrerequisiteScalarWhereInput | WorkshopPrerequisiteScalarWhereInput[]
  }

  export type PromoCodeUpdateManyWithoutApplicableWorkshopsNestedInput = {
    create?: XOR<PromoCodeCreateWithoutApplicableWorkshopsInput, PromoCodeUncheckedCreateWithoutApplicableWorkshopsInput> | PromoCodeCreateWithoutApplicableWorkshopsInput[] | PromoCodeUncheckedCreateWithoutApplicableWorkshopsInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutApplicableWorkshopsInput | PromoCodeCreateOrConnectWithoutApplicableWorkshopsInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutApplicableWorkshopsInput | PromoCodeUpsertWithWhereUniqueWithoutApplicableWorkshopsInput[]
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutApplicableWorkshopsInput | PromoCodeUpdateWithWhereUniqueWithoutApplicableWorkshopsInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutApplicableWorkshopsInput | PromoCodeUpdateManyWithWhereWithoutApplicableWorkshopsInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type PromotionUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<PromotionCreateWithoutWorkshopInput, PromotionUncheckedCreateWithoutWorkshopInput> | PromotionCreateWithoutWorkshopInput[] | PromotionUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutWorkshopInput | PromotionCreateOrConnectWithoutWorkshopInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutWorkshopInput | PromotionUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: PromotionCreateManyWorkshopInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutWorkshopInput | PromotionUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutWorkshopInput | PromotionUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<EnrollmentCreateWithoutWorkshopInput, EnrollmentUncheckedCreateWithoutWorkshopInput> | EnrollmentCreateWithoutWorkshopInput[] | EnrollmentUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutWorkshopInput | EnrollmentCreateOrConnectWithoutWorkshopInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutWorkshopInput | EnrollmentUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: EnrollmentCreateManyWorkshopInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutWorkshopInput | EnrollmentUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutWorkshopInput | EnrollmentUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<PaymentCreateWithoutWorkshopInput, PaymentUncheckedCreateWithoutWorkshopInput> | PaymentCreateWithoutWorkshopInput[] | PaymentUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutWorkshopInput | PaymentCreateOrConnectWithoutWorkshopInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutWorkshopInput | PaymentUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: PaymentCreateManyWorkshopInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutWorkshopInput | PaymentUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutWorkshopInput | PaymentUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type WorkshopTagUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopTagCreateWithoutWorkshopInput, WorkshopTagUncheckedCreateWithoutWorkshopInput> | WorkshopTagCreateWithoutWorkshopInput[] | WorkshopTagUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopTagCreateOrConnectWithoutWorkshopInput | WorkshopTagCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopTagUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopTagUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopTagCreateManyWorkshopInputEnvelope
    set?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    disconnect?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    delete?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    connect?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    update?: WorkshopTagUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopTagUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopTagUpdateManyWithWhereWithoutWorkshopInput | WorkshopTagUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopTagScalarWhereInput | WorkshopTagScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<UserProgressCreateWithoutWorkshopInput, UserProgressUncheckedCreateWithoutWorkshopInput> | UserProgressCreateWithoutWorkshopInput[] | UserProgressUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutWorkshopInput | UserProgressCreateOrConnectWithoutWorkshopInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutWorkshopInput | UserProgressUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: UserProgressCreateManyWorkshopInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutWorkshopInput | UserProgressUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutWorkshopInput | UserProgressUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type WorkshopResourceUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopResourceCreateWithoutWorkshopInput, WorkshopResourceUncheckedCreateWithoutWorkshopInput> | WorkshopResourceCreateWithoutWorkshopInput[] | WorkshopResourceUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopResourceCreateOrConnectWithoutWorkshopInput | WorkshopResourceCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopResourceUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopResourceUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopResourceCreateManyWorkshopInputEnvelope
    set?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    disconnect?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    delete?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    connect?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    update?: WorkshopResourceUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopResourceUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopResourceUpdateManyWithWhereWithoutWorkshopInput | WorkshopResourceUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopResourceScalarWhereInput | WorkshopResourceScalarWhereInput[]
  }

  export type LearningPathItemUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<LearningPathItemCreateWithoutWorkshopInput, LearningPathItemUncheckedCreateWithoutWorkshopInput> | LearningPathItemCreateWithoutWorkshopInput[] | LearningPathItemUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutWorkshopInput | LearningPathItemCreateOrConnectWithoutWorkshopInput[]
    upsert?: LearningPathItemUpsertWithWhereUniqueWithoutWorkshopInput | LearningPathItemUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: LearningPathItemCreateManyWorkshopInputEnvelope
    set?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    disconnect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    delete?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    update?: LearningPathItemUpdateWithWhereUniqueWithoutWorkshopInput | LearningPathItemUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: LearningPathItemUpdateManyWithWhereWithoutWorkshopInput | LearningPathItemUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
  }

  export type WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopObjectiveCreateWithoutWorkshopInput, WorkshopObjectiveUncheckedCreateWithoutWorkshopInput> | WorkshopObjectiveCreateWithoutWorkshopInput[] | WorkshopObjectiveUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopObjectiveCreateOrConnectWithoutWorkshopInput | WorkshopObjectiveCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopObjectiveUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopObjectiveUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopObjectiveCreateManyWorkshopInputEnvelope
    set?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    disconnect?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    delete?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    connect?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    update?: WorkshopObjectiveUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopObjectiveUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopObjectiveUpdateManyWithWhereWithoutWorkshopInput | WorkshopObjectiveUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopObjectiveScalarWhereInput | WorkshopObjectiveScalarWhereInput[]
  }

  export type WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopPrerequisiteCreateWithoutWorkshopInput, WorkshopPrerequisiteUncheckedCreateWithoutWorkshopInput> | WorkshopPrerequisiteCreateWithoutWorkshopInput[] | WorkshopPrerequisiteUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopPrerequisiteCreateOrConnectWithoutWorkshopInput | WorkshopPrerequisiteCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopPrerequisiteUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopPrerequisiteUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopPrerequisiteCreateManyWorkshopInputEnvelope
    set?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    disconnect?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    delete?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    connect?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    update?: WorkshopPrerequisiteUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopPrerequisiteUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopPrerequisiteUpdateManyWithWhereWithoutWorkshopInput | WorkshopPrerequisiteUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopPrerequisiteScalarWhereInput | WorkshopPrerequisiteScalarWhereInput[]
  }

  export type PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsNestedInput = {
    create?: XOR<PromoCodeCreateWithoutApplicableWorkshopsInput, PromoCodeUncheckedCreateWithoutApplicableWorkshopsInput> | PromoCodeCreateWithoutApplicableWorkshopsInput[] | PromoCodeUncheckedCreateWithoutApplicableWorkshopsInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutApplicableWorkshopsInput | PromoCodeCreateOrConnectWithoutApplicableWorkshopsInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutApplicableWorkshopsInput | PromoCodeUpsertWithWhereUniqueWithoutApplicableWorkshopsInput[]
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutApplicableWorkshopsInput | PromoCodeUpdateWithWhereUniqueWithoutApplicableWorkshopsInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutApplicableWorkshopsInput | PromoCodeUpdateManyWithWhereWithoutApplicableWorkshopsInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type PromotionUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<PromotionCreateWithoutWorkshopInput, PromotionUncheckedCreateWithoutWorkshopInput> | PromotionCreateWithoutWorkshopInput[] | PromotionUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutWorkshopInput | PromotionCreateOrConnectWithoutWorkshopInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutWorkshopInput | PromotionUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: PromotionCreateManyWorkshopInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutWorkshopInput | PromotionUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutWorkshopInput | PromotionUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<EnrollmentCreateWithoutWorkshopInput, EnrollmentUncheckedCreateWithoutWorkshopInput> | EnrollmentCreateWithoutWorkshopInput[] | EnrollmentUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutWorkshopInput | EnrollmentCreateOrConnectWithoutWorkshopInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutWorkshopInput | EnrollmentUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: EnrollmentCreateManyWorkshopInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutWorkshopInput | EnrollmentUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutWorkshopInput | EnrollmentUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<PaymentCreateWithoutWorkshopInput, PaymentUncheckedCreateWithoutWorkshopInput> | PaymentCreateWithoutWorkshopInput[] | PaymentUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutWorkshopInput | PaymentCreateOrConnectWithoutWorkshopInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutWorkshopInput | PaymentUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: PaymentCreateManyWorkshopInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutWorkshopInput | PaymentUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutWorkshopInput | PaymentUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CourseResourceCreateNestedManyWithoutResourceInput = {
    create?: XOR<CourseResourceCreateWithoutResourceInput, CourseResourceUncheckedCreateWithoutResourceInput> | CourseResourceCreateWithoutResourceInput[] | CourseResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: CourseResourceCreateOrConnectWithoutResourceInput | CourseResourceCreateOrConnectWithoutResourceInput[]
    createMany?: CourseResourceCreateManyResourceInputEnvelope
    connect?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
  }

  export type LessonResourceCreateNestedManyWithoutResourceInput = {
    create?: XOR<LessonResourceCreateWithoutResourceInput, LessonResourceUncheckedCreateWithoutResourceInput> | LessonResourceCreateWithoutResourceInput[] | LessonResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LessonResourceCreateOrConnectWithoutResourceInput | LessonResourceCreateOrConnectWithoutResourceInput[]
    createMany?: LessonResourceCreateManyResourceInputEnvelope
    connect?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
  }

  export type WorkshopResourceCreateNestedManyWithoutResourceInput = {
    create?: XOR<WorkshopResourceCreateWithoutResourceInput, WorkshopResourceUncheckedCreateWithoutResourceInput> | WorkshopResourceCreateWithoutResourceInput[] | WorkshopResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: WorkshopResourceCreateOrConnectWithoutResourceInput | WorkshopResourceCreateOrConnectWithoutResourceInput[]
    createMany?: WorkshopResourceCreateManyResourceInputEnvelope
    connect?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
  }

  export type LearningPathResourceCreateNestedManyWithoutResourceInput = {
    create?: XOR<LearningPathResourceCreateWithoutResourceInput, LearningPathResourceUncheckedCreateWithoutResourceInput> | LearningPathResourceCreateWithoutResourceInput[] | LearningPathResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LearningPathResourceCreateOrConnectWithoutResourceInput | LearningPathResourceCreateOrConnectWithoutResourceInput[]
    createMany?: LearningPathResourceCreateManyResourceInputEnvelope
    connect?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
  }

  export type LearningPathItemCreateNestedManyWithoutResourceInput = {
    create?: XOR<LearningPathItemCreateWithoutResourceInput, LearningPathItemUncheckedCreateWithoutResourceInput> | LearningPathItemCreateWithoutResourceInput[] | LearningPathItemUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutResourceInput | LearningPathItemCreateOrConnectWithoutResourceInput[]
    createMany?: LearningPathItemCreateManyResourceInputEnvelope
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutResourcesInput = {
    create?: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourcesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseResourceUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<CourseResourceCreateWithoutResourceInput, CourseResourceUncheckedCreateWithoutResourceInput> | CourseResourceCreateWithoutResourceInput[] | CourseResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: CourseResourceCreateOrConnectWithoutResourceInput | CourseResourceCreateOrConnectWithoutResourceInput[]
    createMany?: CourseResourceCreateManyResourceInputEnvelope
    connect?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
  }

  export type LessonResourceUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<LessonResourceCreateWithoutResourceInput, LessonResourceUncheckedCreateWithoutResourceInput> | LessonResourceCreateWithoutResourceInput[] | LessonResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LessonResourceCreateOrConnectWithoutResourceInput | LessonResourceCreateOrConnectWithoutResourceInput[]
    createMany?: LessonResourceCreateManyResourceInputEnvelope
    connect?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
  }

  export type WorkshopResourceUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<WorkshopResourceCreateWithoutResourceInput, WorkshopResourceUncheckedCreateWithoutResourceInput> | WorkshopResourceCreateWithoutResourceInput[] | WorkshopResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: WorkshopResourceCreateOrConnectWithoutResourceInput | WorkshopResourceCreateOrConnectWithoutResourceInput[]
    createMany?: WorkshopResourceCreateManyResourceInputEnvelope
    connect?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
  }

  export type LearningPathResourceUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<LearningPathResourceCreateWithoutResourceInput, LearningPathResourceUncheckedCreateWithoutResourceInput> | LearningPathResourceCreateWithoutResourceInput[] | LearningPathResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LearningPathResourceCreateOrConnectWithoutResourceInput | LearningPathResourceCreateOrConnectWithoutResourceInput[]
    createMany?: LearningPathResourceCreateManyResourceInputEnvelope
    connect?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
  }

  export type LearningPathItemUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<LearningPathItemCreateWithoutResourceInput, LearningPathItemUncheckedCreateWithoutResourceInput> | LearningPathItemCreateWithoutResourceInput[] | LearningPathItemUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutResourceInput | LearningPathItemCreateOrConnectWithoutResourceInput[]
    createMany?: LearningPathItemCreateManyResourceInputEnvelope
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
  }

  export type CourseResourceUpdateManyWithoutResourceNestedInput = {
    create?: XOR<CourseResourceCreateWithoutResourceInput, CourseResourceUncheckedCreateWithoutResourceInput> | CourseResourceCreateWithoutResourceInput[] | CourseResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: CourseResourceCreateOrConnectWithoutResourceInput | CourseResourceCreateOrConnectWithoutResourceInput[]
    upsert?: CourseResourceUpsertWithWhereUniqueWithoutResourceInput | CourseResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: CourseResourceCreateManyResourceInputEnvelope
    set?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    disconnect?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    delete?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    connect?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    update?: CourseResourceUpdateWithWhereUniqueWithoutResourceInput | CourseResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: CourseResourceUpdateManyWithWhereWithoutResourceInput | CourseResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: CourseResourceScalarWhereInput | CourseResourceScalarWhereInput[]
  }

  export type LessonResourceUpdateManyWithoutResourceNestedInput = {
    create?: XOR<LessonResourceCreateWithoutResourceInput, LessonResourceUncheckedCreateWithoutResourceInput> | LessonResourceCreateWithoutResourceInput[] | LessonResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LessonResourceCreateOrConnectWithoutResourceInput | LessonResourceCreateOrConnectWithoutResourceInput[]
    upsert?: LessonResourceUpsertWithWhereUniqueWithoutResourceInput | LessonResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: LessonResourceCreateManyResourceInputEnvelope
    set?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    disconnect?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    delete?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    connect?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    update?: LessonResourceUpdateWithWhereUniqueWithoutResourceInput | LessonResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: LessonResourceUpdateManyWithWhereWithoutResourceInput | LessonResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: LessonResourceScalarWhereInput | LessonResourceScalarWhereInput[]
  }

  export type WorkshopResourceUpdateManyWithoutResourceNestedInput = {
    create?: XOR<WorkshopResourceCreateWithoutResourceInput, WorkshopResourceUncheckedCreateWithoutResourceInput> | WorkshopResourceCreateWithoutResourceInput[] | WorkshopResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: WorkshopResourceCreateOrConnectWithoutResourceInput | WorkshopResourceCreateOrConnectWithoutResourceInput[]
    upsert?: WorkshopResourceUpsertWithWhereUniqueWithoutResourceInput | WorkshopResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: WorkshopResourceCreateManyResourceInputEnvelope
    set?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    disconnect?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    delete?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    connect?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    update?: WorkshopResourceUpdateWithWhereUniqueWithoutResourceInput | WorkshopResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: WorkshopResourceUpdateManyWithWhereWithoutResourceInput | WorkshopResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: WorkshopResourceScalarWhereInput | WorkshopResourceScalarWhereInput[]
  }

  export type LearningPathResourceUpdateManyWithoutResourceNestedInput = {
    create?: XOR<LearningPathResourceCreateWithoutResourceInput, LearningPathResourceUncheckedCreateWithoutResourceInput> | LearningPathResourceCreateWithoutResourceInput[] | LearningPathResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LearningPathResourceCreateOrConnectWithoutResourceInput | LearningPathResourceCreateOrConnectWithoutResourceInput[]
    upsert?: LearningPathResourceUpsertWithWhereUniqueWithoutResourceInput | LearningPathResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: LearningPathResourceCreateManyResourceInputEnvelope
    set?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    disconnect?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    delete?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    connect?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    update?: LearningPathResourceUpdateWithWhereUniqueWithoutResourceInput | LearningPathResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: LearningPathResourceUpdateManyWithWhereWithoutResourceInput | LearningPathResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: LearningPathResourceScalarWhereInput | LearningPathResourceScalarWhereInput[]
  }

  export type LearningPathItemUpdateManyWithoutResourceNestedInput = {
    create?: XOR<LearningPathItemCreateWithoutResourceInput, LearningPathItemUncheckedCreateWithoutResourceInput> | LearningPathItemCreateWithoutResourceInput[] | LearningPathItemUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutResourceInput | LearningPathItemCreateOrConnectWithoutResourceInput[]
    upsert?: LearningPathItemUpsertWithWhereUniqueWithoutResourceInput | LearningPathItemUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: LearningPathItemCreateManyResourceInputEnvelope
    set?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    disconnect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    delete?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    update?: LearningPathItemUpdateWithWhereUniqueWithoutResourceInput | LearningPathItemUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: LearningPathItemUpdateManyWithWhereWithoutResourceInput | LearningPathItemUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
  }

  export type UserUpdateOneWithoutResourcesNestedInput = {
    create?: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourcesInput
    upsert?: UserUpsertWithoutResourcesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResourcesInput, UserUpdateWithoutResourcesInput>, UserUncheckedUpdateWithoutResourcesInput>
  }

  export type CourseResourceUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<CourseResourceCreateWithoutResourceInput, CourseResourceUncheckedCreateWithoutResourceInput> | CourseResourceCreateWithoutResourceInput[] | CourseResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: CourseResourceCreateOrConnectWithoutResourceInput | CourseResourceCreateOrConnectWithoutResourceInput[]
    upsert?: CourseResourceUpsertWithWhereUniqueWithoutResourceInput | CourseResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: CourseResourceCreateManyResourceInputEnvelope
    set?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    disconnect?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    delete?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    connect?: CourseResourceWhereUniqueInput | CourseResourceWhereUniqueInput[]
    update?: CourseResourceUpdateWithWhereUniqueWithoutResourceInput | CourseResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: CourseResourceUpdateManyWithWhereWithoutResourceInput | CourseResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: CourseResourceScalarWhereInput | CourseResourceScalarWhereInput[]
  }

  export type LessonResourceUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<LessonResourceCreateWithoutResourceInput, LessonResourceUncheckedCreateWithoutResourceInput> | LessonResourceCreateWithoutResourceInput[] | LessonResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LessonResourceCreateOrConnectWithoutResourceInput | LessonResourceCreateOrConnectWithoutResourceInput[]
    upsert?: LessonResourceUpsertWithWhereUniqueWithoutResourceInput | LessonResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: LessonResourceCreateManyResourceInputEnvelope
    set?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    disconnect?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    delete?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    connect?: LessonResourceWhereUniqueInput | LessonResourceWhereUniqueInput[]
    update?: LessonResourceUpdateWithWhereUniqueWithoutResourceInput | LessonResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: LessonResourceUpdateManyWithWhereWithoutResourceInput | LessonResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: LessonResourceScalarWhereInput | LessonResourceScalarWhereInput[]
  }

  export type WorkshopResourceUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<WorkshopResourceCreateWithoutResourceInput, WorkshopResourceUncheckedCreateWithoutResourceInput> | WorkshopResourceCreateWithoutResourceInput[] | WorkshopResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: WorkshopResourceCreateOrConnectWithoutResourceInput | WorkshopResourceCreateOrConnectWithoutResourceInput[]
    upsert?: WorkshopResourceUpsertWithWhereUniqueWithoutResourceInput | WorkshopResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: WorkshopResourceCreateManyResourceInputEnvelope
    set?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    disconnect?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    delete?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    connect?: WorkshopResourceWhereUniqueInput | WorkshopResourceWhereUniqueInput[]
    update?: WorkshopResourceUpdateWithWhereUniqueWithoutResourceInput | WorkshopResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: WorkshopResourceUpdateManyWithWhereWithoutResourceInput | WorkshopResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: WorkshopResourceScalarWhereInput | WorkshopResourceScalarWhereInput[]
  }

  export type LearningPathResourceUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<LearningPathResourceCreateWithoutResourceInput, LearningPathResourceUncheckedCreateWithoutResourceInput> | LearningPathResourceCreateWithoutResourceInput[] | LearningPathResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LearningPathResourceCreateOrConnectWithoutResourceInput | LearningPathResourceCreateOrConnectWithoutResourceInput[]
    upsert?: LearningPathResourceUpsertWithWhereUniqueWithoutResourceInput | LearningPathResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: LearningPathResourceCreateManyResourceInputEnvelope
    set?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    disconnect?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    delete?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    connect?: LearningPathResourceWhereUniqueInput | LearningPathResourceWhereUniqueInput[]
    update?: LearningPathResourceUpdateWithWhereUniqueWithoutResourceInput | LearningPathResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: LearningPathResourceUpdateManyWithWhereWithoutResourceInput | LearningPathResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: LearningPathResourceScalarWhereInput | LearningPathResourceScalarWhereInput[]
  }

  export type LearningPathItemUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<LearningPathItemCreateWithoutResourceInput, LearningPathItemUncheckedCreateWithoutResourceInput> | LearningPathItemCreateWithoutResourceInput[] | LearningPathItemUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutResourceInput | LearningPathItemCreateOrConnectWithoutResourceInput[]
    upsert?: LearningPathItemUpsertWithWhereUniqueWithoutResourceInput | LearningPathItemUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: LearningPathItemCreateManyResourceInputEnvelope
    set?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    disconnect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    delete?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    update?: LearningPathItemUpdateWithWhereUniqueWithoutResourceInput | LearningPathItemUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: LearningPathItemUpdateManyWithWhereWithoutResourceInput | LearningPathItemUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
  }

  export type LearningPathCreateNestedOneWithoutResourcesInput = {
    create?: XOR<LearningPathCreateWithoutResourcesInput, LearningPathUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutResourcesInput
    connect?: LearningPathWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutLearningPathResourcesInput = {
    create?: XOR<ResourceCreateWithoutLearningPathResourcesInput, ResourceUncheckedCreateWithoutLearningPathResourcesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutLearningPathResourcesInput
    connect?: ResourceWhereUniqueInput
  }

  export type LearningPathUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<LearningPathCreateWithoutResourcesInput, LearningPathUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutResourcesInput
    upsert?: LearningPathUpsertWithoutResourcesInput
    connect?: LearningPathWhereUniqueInput
    update?: XOR<XOR<LearningPathUpdateToOneWithWhereWithoutResourcesInput, LearningPathUpdateWithoutResourcesInput>, LearningPathUncheckedUpdateWithoutResourcesInput>
  }

  export type ResourceUpdateOneRequiredWithoutLearningPathResourcesNestedInput = {
    create?: XOR<ResourceCreateWithoutLearningPathResourcesInput, ResourceUncheckedCreateWithoutLearningPathResourcesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutLearningPathResourcesInput
    upsert?: ResourceUpsertWithoutLearningPathResourcesInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutLearningPathResourcesInput, ResourceUpdateWithoutLearningPathResourcesInput>, ResourceUncheckedUpdateWithoutLearningPathResourcesInput>
  }

  export type CourseCreateNestedOneWithoutResourcesInput = {
    create?: XOR<CourseCreateWithoutResourcesInput, CourseUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutResourcesInput
    connect?: CourseWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutCourseResourcesInput = {
    create?: XOR<ResourceCreateWithoutCourseResourcesInput, ResourceUncheckedCreateWithoutCourseResourcesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutCourseResourcesInput
    connect?: ResourceWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<CourseCreateWithoutResourcesInput, CourseUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutResourcesInput
    upsert?: CourseUpsertWithoutResourcesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutResourcesInput, CourseUpdateWithoutResourcesInput>, CourseUncheckedUpdateWithoutResourcesInput>
  }

  export type ResourceUpdateOneRequiredWithoutCourseResourcesNestedInput = {
    create?: XOR<ResourceCreateWithoutCourseResourcesInput, ResourceUncheckedCreateWithoutCourseResourcesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutCourseResourcesInput
    upsert?: ResourceUpsertWithoutCourseResourcesInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutCourseResourcesInput, ResourceUpdateWithoutCourseResourcesInput>, ResourceUncheckedUpdateWithoutCourseResourcesInput>
  }

  export type LessonCreateNestedOneWithoutResourcesInput = {
    create?: XOR<LessonCreateWithoutResourcesInput, LessonUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutResourcesInput
    connect?: LessonWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutLessonResourcesInput = {
    create?: XOR<ResourceCreateWithoutLessonResourcesInput, ResourceUncheckedCreateWithoutLessonResourcesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutLessonResourcesInput
    connect?: ResourceWhereUniqueInput
  }

  export type LessonUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<LessonCreateWithoutResourcesInput, LessonUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutResourcesInput
    upsert?: LessonUpsertWithoutResourcesInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutResourcesInput, LessonUpdateWithoutResourcesInput>, LessonUncheckedUpdateWithoutResourcesInput>
  }

  export type ResourceUpdateOneRequiredWithoutLessonResourcesNestedInput = {
    create?: XOR<ResourceCreateWithoutLessonResourcesInput, ResourceUncheckedCreateWithoutLessonResourcesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutLessonResourcesInput
    upsert?: ResourceUpsertWithoutLessonResourcesInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutLessonResourcesInput, ResourceUpdateWithoutLessonResourcesInput>, ResourceUncheckedUpdateWithoutLessonResourcesInput>
  }

  export type WorkshopCreateNestedOneWithoutResourcesInput = {
    create?: XOR<WorkshopCreateWithoutResourcesInput, WorkshopUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutResourcesInput
    connect?: WorkshopWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutWorkshopResourcesInput = {
    create?: XOR<ResourceCreateWithoutWorkshopResourcesInput, ResourceUncheckedCreateWithoutWorkshopResourcesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutWorkshopResourcesInput
    connect?: ResourceWhereUniqueInput
  }

  export type WorkshopUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<WorkshopCreateWithoutResourcesInput, WorkshopUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutResourcesInput
    upsert?: WorkshopUpsertWithoutResourcesInput
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutResourcesInput, WorkshopUpdateWithoutResourcesInput>, WorkshopUncheckedUpdateWithoutResourcesInput>
  }

  export type ResourceUpdateOneRequiredWithoutWorkshopResourcesNestedInput = {
    create?: XOR<ResourceCreateWithoutWorkshopResourcesInput, ResourceUncheckedCreateWithoutWorkshopResourcesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutWorkshopResourcesInput
    upsert?: ResourceUpsertWithoutWorkshopResourcesInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutWorkshopResourcesInput, ResourceUpdateWithoutWorkshopResourcesInput>, ResourceUncheckedUpdateWithoutWorkshopResourcesInput>
  }

  export type UserCreateNestedOneWithoutLessonProgressInput = {
    create?: XOR<UserCreateWithoutLessonProgressInput, UserUncheckedCreateWithoutLessonProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonProgressInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutLessonProgressInput = {
    create?: XOR<LessonCreateWithoutLessonProgressInput, LessonUncheckedCreateWithoutLessonProgressInput>
    connectOrCreate?: LessonCreateOrConnectWithoutLessonProgressInput
    connect?: LessonWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutLessonProgressNestedInput = {
    create?: XOR<UserCreateWithoutLessonProgressInput, UserUncheckedCreateWithoutLessonProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonProgressInput
    upsert?: UserUpsertWithoutLessonProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLessonProgressInput, UserUpdateWithoutLessonProgressInput>, UserUncheckedUpdateWithoutLessonProgressInput>
  }

  export type LessonUpdateOneRequiredWithoutLessonProgressNestedInput = {
    create?: XOR<LessonCreateWithoutLessonProgressInput, LessonUncheckedCreateWithoutLessonProgressInput>
    connectOrCreate?: LessonCreateOrConnectWithoutLessonProgressInput
    upsert?: LessonUpsertWithoutLessonProgressInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutLessonProgressInput, LessonUpdateWithoutLessonProgressInput>, LessonUncheckedUpdateWithoutLessonProgressInput>
  }

  export type CourseCreateNestedOneWithoutProgressInput = {
    create?: XOR<CourseCreateWithoutProgressInput, CourseUncheckedCreateWithoutProgressInput>
    connectOrCreate?: CourseCreateOrConnectWithoutProgressInput
    connect?: CourseWhereUniqueInput
  }

  export type WorkshopCreateNestedOneWithoutProgressInput = {
    create?: XOR<WorkshopCreateWithoutProgressInput, WorkshopUncheckedCreateWithoutProgressInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutProgressInput
    connect?: WorkshopWhereUniqueInput
  }

  export type LearningPathCreateNestedOneWithoutProgressInput = {
    create?: XOR<LearningPathCreateWithoutProgressInput, LearningPathUncheckedCreateWithoutProgressInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutProgressInput
    connect?: LearningPathWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseUpdateOneWithoutProgressNestedInput = {
    create?: XOR<CourseCreateWithoutProgressInput, CourseUncheckedCreateWithoutProgressInput>
    connectOrCreate?: CourseCreateOrConnectWithoutProgressInput
    upsert?: CourseUpsertWithoutProgressInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutProgressInput, CourseUpdateWithoutProgressInput>, CourseUncheckedUpdateWithoutProgressInput>
  }

  export type WorkshopUpdateOneWithoutProgressNestedInput = {
    create?: XOR<WorkshopCreateWithoutProgressInput, WorkshopUncheckedCreateWithoutProgressInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutProgressInput
    upsert?: WorkshopUpsertWithoutProgressInput
    disconnect?: WorkshopWhereInput | boolean
    delete?: WorkshopWhereInput | boolean
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutProgressInput, WorkshopUpdateWithoutProgressInput>, WorkshopUncheckedUpdateWithoutProgressInput>
  }

  export type LearningPathUpdateOneWithoutProgressNestedInput = {
    create?: XOR<LearningPathCreateWithoutProgressInput, LearningPathUncheckedCreateWithoutProgressInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutProgressInput
    upsert?: LearningPathUpsertWithoutProgressInput
    disconnect?: LearningPathWhereInput | boolean
    delete?: LearningPathWhereInput | boolean
    connect?: LearningPathWhereUniqueInput
    update?: XOR<XOR<LearningPathUpdateToOneWithWhereWithoutProgressInput, LearningPathUpdateWithoutProgressInput>, LearningPathUncheckedUpdateWithoutProgressInput>
  }

  export type CourseTagCreateNestedManyWithoutTagInput = {
    create?: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput> | CourseTagCreateWithoutTagInput[] | CourseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutTagInput | CourseTagCreateOrConnectWithoutTagInput[]
    createMany?: CourseTagCreateManyTagInputEnvelope
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
  }

  export type WorkshopTagCreateNestedManyWithoutTagInput = {
    create?: XOR<WorkshopTagCreateWithoutTagInput, WorkshopTagUncheckedCreateWithoutTagInput> | WorkshopTagCreateWithoutTagInput[] | WorkshopTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: WorkshopTagCreateOrConnectWithoutTagInput | WorkshopTagCreateOrConnectWithoutTagInput[]
    createMany?: WorkshopTagCreateManyTagInputEnvelope
    connect?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
  }

  export type LearningPathTagCreateNestedManyWithoutTagInput = {
    create?: XOR<LearningPathTagCreateWithoutTagInput, LearningPathTagUncheckedCreateWithoutTagInput> | LearningPathTagCreateWithoutTagInput[] | LearningPathTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: LearningPathTagCreateOrConnectWithoutTagInput | LearningPathTagCreateOrConnectWithoutTagInput[]
    createMany?: LearningPathTagCreateManyTagInputEnvelope
    connect?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
  }

  export type CourseTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput> | CourseTagCreateWithoutTagInput[] | CourseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutTagInput | CourseTagCreateOrConnectWithoutTagInput[]
    createMany?: CourseTagCreateManyTagInputEnvelope
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
  }

  export type WorkshopTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<WorkshopTagCreateWithoutTagInput, WorkshopTagUncheckedCreateWithoutTagInput> | WorkshopTagCreateWithoutTagInput[] | WorkshopTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: WorkshopTagCreateOrConnectWithoutTagInput | WorkshopTagCreateOrConnectWithoutTagInput[]
    createMany?: WorkshopTagCreateManyTagInputEnvelope
    connect?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
  }

  export type LearningPathTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<LearningPathTagCreateWithoutTagInput, LearningPathTagUncheckedCreateWithoutTagInput> | LearningPathTagCreateWithoutTagInput[] | LearningPathTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: LearningPathTagCreateOrConnectWithoutTagInput | LearningPathTagCreateOrConnectWithoutTagInput[]
    createMany?: LearningPathTagCreateManyTagInputEnvelope
    connect?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
  }

  export type CourseTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput> | CourseTagCreateWithoutTagInput[] | CourseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutTagInput | CourseTagCreateOrConnectWithoutTagInput[]
    upsert?: CourseTagUpsertWithWhereUniqueWithoutTagInput | CourseTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: CourseTagCreateManyTagInputEnvelope
    set?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    disconnect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    delete?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    update?: CourseTagUpdateWithWhereUniqueWithoutTagInput | CourseTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: CourseTagUpdateManyWithWhereWithoutTagInput | CourseTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
  }

  export type WorkshopTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<WorkshopTagCreateWithoutTagInput, WorkshopTagUncheckedCreateWithoutTagInput> | WorkshopTagCreateWithoutTagInput[] | WorkshopTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: WorkshopTagCreateOrConnectWithoutTagInput | WorkshopTagCreateOrConnectWithoutTagInput[]
    upsert?: WorkshopTagUpsertWithWhereUniqueWithoutTagInput | WorkshopTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: WorkshopTagCreateManyTagInputEnvelope
    set?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    disconnect?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    delete?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    connect?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    update?: WorkshopTagUpdateWithWhereUniqueWithoutTagInput | WorkshopTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: WorkshopTagUpdateManyWithWhereWithoutTagInput | WorkshopTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: WorkshopTagScalarWhereInput | WorkshopTagScalarWhereInput[]
  }

  export type LearningPathTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<LearningPathTagCreateWithoutTagInput, LearningPathTagUncheckedCreateWithoutTagInput> | LearningPathTagCreateWithoutTagInput[] | LearningPathTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: LearningPathTagCreateOrConnectWithoutTagInput | LearningPathTagCreateOrConnectWithoutTagInput[]
    upsert?: LearningPathTagUpsertWithWhereUniqueWithoutTagInput | LearningPathTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: LearningPathTagCreateManyTagInputEnvelope
    set?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    disconnect?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    delete?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    connect?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    update?: LearningPathTagUpdateWithWhereUniqueWithoutTagInput | LearningPathTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: LearningPathTagUpdateManyWithWhereWithoutTagInput | LearningPathTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: LearningPathTagScalarWhereInput | LearningPathTagScalarWhereInput[]
  }

  export type CourseTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput> | CourseTagCreateWithoutTagInput[] | CourseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutTagInput | CourseTagCreateOrConnectWithoutTagInput[]
    upsert?: CourseTagUpsertWithWhereUniqueWithoutTagInput | CourseTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: CourseTagCreateManyTagInputEnvelope
    set?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    disconnect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    delete?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    update?: CourseTagUpdateWithWhereUniqueWithoutTagInput | CourseTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: CourseTagUpdateManyWithWhereWithoutTagInput | CourseTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
  }

  export type WorkshopTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<WorkshopTagCreateWithoutTagInput, WorkshopTagUncheckedCreateWithoutTagInput> | WorkshopTagCreateWithoutTagInput[] | WorkshopTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: WorkshopTagCreateOrConnectWithoutTagInput | WorkshopTagCreateOrConnectWithoutTagInput[]
    upsert?: WorkshopTagUpsertWithWhereUniqueWithoutTagInput | WorkshopTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: WorkshopTagCreateManyTagInputEnvelope
    set?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    disconnect?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    delete?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    connect?: WorkshopTagWhereUniqueInput | WorkshopTagWhereUniqueInput[]
    update?: WorkshopTagUpdateWithWhereUniqueWithoutTagInput | WorkshopTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: WorkshopTagUpdateManyWithWhereWithoutTagInput | WorkshopTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: WorkshopTagScalarWhereInput | WorkshopTagScalarWhereInput[]
  }

  export type LearningPathTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<LearningPathTagCreateWithoutTagInput, LearningPathTagUncheckedCreateWithoutTagInput> | LearningPathTagCreateWithoutTagInput[] | LearningPathTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: LearningPathTagCreateOrConnectWithoutTagInput | LearningPathTagCreateOrConnectWithoutTagInput[]
    upsert?: LearningPathTagUpsertWithWhereUniqueWithoutTagInput | LearningPathTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: LearningPathTagCreateManyTagInputEnvelope
    set?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    disconnect?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    delete?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    connect?: LearningPathTagWhereUniqueInput | LearningPathTagWhereUniqueInput[]
    update?: LearningPathTagUpdateWithWhereUniqueWithoutTagInput | LearningPathTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: LearningPathTagUpdateManyWithWhereWithoutTagInput | LearningPathTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: LearningPathTagScalarWhereInput | LearningPathTagScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutTagsInput = {
    create?: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTagsInput
    connect?: CourseWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutCourseTagsInput = {
    create?: XOR<TagCreateWithoutCourseTagsInput, TagUncheckedCreateWithoutCourseTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutCourseTagsInput
    connect?: TagWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTagsInput
    upsert?: CourseUpsertWithoutTagsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutTagsInput, CourseUpdateWithoutTagsInput>, CourseUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutCourseTagsNestedInput = {
    create?: XOR<TagCreateWithoutCourseTagsInput, TagUncheckedCreateWithoutCourseTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutCourseTagsInput
    upsert?: TagUpsertWithoutCourseTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutCourseTagsInput, TagUpdateWithoutCourseTagsInput>, TagUncheckedUpdateWithoutCourseTagsInput>
  }

  export type WorkshopCreateNestedOneWithoutTagsInput = {
    create?: XOR<WorkshopCreateWithoutTagsInput, WorkshopUncheckedCreateWithoutTagsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutTagsInput
    connect?: WorkshopWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutWorkshopTagsInput = {
    create?: XOR<TagCreateWithoutWorkshopTagsInput, TagUncheckedCreateWithoutWorkshopTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutWorkshopTagsInput
    connect?: TagWhereUniqueInput
  }

  export type WorkshopUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<WorkshopCreateWithoutTagsInput, WorkshopUncheckedCreateWithoutTagsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutTagsInput
    upsert?: WorkshopUpsertWithoutTagsInput
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutTagsInput, WorkshopUpdateWithoutTagsInput>, WorkshopUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutWorkshopTagsNestedInput = {
    create?: XOR<TagCreateWithoutWorkshopTagsInput, TagUncheckedCreateWithoutWorkshopTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutWorkshopTagsInput
    upsert?: TagUpsertWithoutWorkshopTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutWorkshopTagsInput, TagUpdateWithoutWorkshopTagsInput>, TagUncheckedUpdateWithoutWorkshopTagsInput>
  }

  export type LearningPathCreateNestedOneWithoutTagsInput = {
    create?: XOR<LearningPathCreateWithoutTagsInput, LearningPathUncheckedCreateWithoutTagsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutTagsInput
    connect?: LearningPathWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutLearningPathTagsInput = {
    create?: XOR<TagCreateWithoutLearningPathTagsInput, TagUncheckedCreateWithoutLearningPathTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutLearningPathTagsInput
    connect?: TagWhereUniqueInput
  }

  export type LearningPathUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<LearningPathCreateWithoutTagsInput, LearningPathUncheckedCreateWithoutTagsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutTagsInput
    upsert?: LearningPathUpsertWithoutTagsInput
    connect?: LearningPathWhereUniqueInput
    update?: XOR<XOR<LearningPathUpdateToOneWithWhereWithoutTagsInput, LearningPathUpdateWithoutTagsInput>, LearningPathUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutLearningPathTagsNestedInput = {
    create?: XOR<TagCreateWithoutLearningPathTagsInput, TagUncheckedCreateWithoutLearningPathTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutLearningPathTagsInput
    upsert?: TagUpsertWithoutLearningPathTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutLearningPathTagsInput, TagUpdateWithoutLearningPathTagsInput>, TagUncheckedUpdateWithoutLearningPathTagsInput>
  }

  export type CourseCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<CourseCreateWithoutPromotionsInput, CourseUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPromotionsInput
    connect?: CourseWhereUniqueInput
  }

  export type WorkshopCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<WorkshopCreateWithoutPromotionsInput, WorkshopUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutPromotionsInput
    connect?: WorkshopWhereUniqueInput
  }

  export type LearningPathCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<LearningPathCreateWithoutPromotionsInput, LearningPathUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutPromotionsInput
    connect?: LearningPathWhereUniqueInput
  }

  export type CourseUpdateOneWithoutPromotionsNestedInput = {
    create?: XOR<CourseCreateWithoutPromotionsInput, CourseUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPromotionsInput
    upsert?: CourseUpsertWithoutPromotionsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutPromotionsInput, CourseUpdateWithoutPromotionsInput>, CourseUncheckedUpdateWithoutPromotionsInput>
  }

  export type WorkshopUpdateOneWithoutPromotionsNestedInput = {
    create?: XOR<WorkshopCreateWithoutPromotionsInput, WorkshopUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutPromotionsInput
    upsert?: WorkshopUpsertWithoutPromotionsInput
    disconnect?: WorkshopWhereInput | boolean
    delete?: WorkshopWhereInput | boolean
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutPromotionsInput, WorkshopUpdateWithoutPromotionsInput>, WorkshopUncheckedUpdateWithoutPromotionsInput>
  }

  export type LearningPathUpdateOneWithoutPromotionsNestedInput = {
    create?: XOR<LearningPathCreateWithoutPromotionsInput, LearningPathUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutPromotionsInput
    upsert?: LearningPathUpsertWithoutPromotionsInput
    disconnect?: LearningPathWhereInput | boolean
    delete?: LearningPathWhereInput | boolean
    connect?: LearningPathWhereUniqueInput
    update?: XOR<XOR<LearningPathUpdateToOneWithWhereWithoutPromotionsInput, LearningPathUpdateWithoutPromotionsInput>, LearningPathUncheckedUpdateWithoutPromotionsInput>
  }

  export type CourseCreateNestedManyWithoutPromoCodesInput = {
    create?: XOR<CourseCreateWithoutPromoCodesInput, CourseUncheckedCreateWithoutPromoCodesInput> | CourseCreateWithoutPromoCodesInput[] | CourseUncheckedCreateWithoutPromoCodesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutPromoCodesInput | CourseCreateOrConnectWithoutPromoCodesInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type WorkshopCreateNestedManyWithoutPromoCodesInput = {
    create?: XOR<WorkshopCreateWithoutPromoCodesInput, WorkshopUncheckedCreateWithoutPromoCodesInput> | WorkshopCreateWithoutPromoCodesInput[] | WorkshopUncheckedCreateWithoutPromoCodesInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutPromoCodesInput | WorkshopCreateOrConnectWithoutPromoCodesInput[]
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
  }

  export type LearningPathCreateNestedManyWithoutPromoCodesInput = {
    create?: XOR<LearningPathCreateWithoutPromoCodesInput, LearningPathUncheckedCreateWithoutPromoCodesInput> | LearningPathCreateWithoutPromoCodesInput[] | LearningPathUncheckedCreateWithoutPromoCodesInput[]
    connectOrCreate?: LearningPathCreateOrConnectWithoutPromoCodesInput | LearningPathCreateOrConnectWithoutPromoCodesInput[]
    connect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutPromoCodesInput = {
    create?: XOR<CourseCreateWithoutPromoCodesInput, CourseUncheckedCreateWithoutPromoCodesInput> | CourseCreateWithoutPromoCodesInput[] | CourseUncheckedCreateWithoutPromoCodesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutPromoCodesInput | CourseCreateOrConnectWithoutPromoCodesInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type WorkshopUncheckedCreateNestedManyWithoutPromoCodesInput = {
    create?: XOR<WorkshopCreateWithoutPromoCodesInput, WorkshopUncheckedCreateWithoutPromoCodesInput> | WorkshopCreateWithoutPromoCodesInput[] | WorkshopUncheckedCreateWithoutPromoCodesInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutPromoCodesInput | WorkshopCreateOrConnectWithoutPromoCodesInput[]
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
  }

  export type LearningPathUncheckedCreateNestedManyWithoutPromoCodesInput = {
    create?: XOR<LearningPathCreateWithoutPromoCodesInput, LearningPathUncheckedCreateWithoutPromoCodesInput> | LearningPathCreateWithoutPromoCodesInput[] | LearningPathUncheckedCreateWithoutPromoCodesInput[]
    connectOrCreate?: LearningPathCreateOrConnectWithoutPromoCodesInput | LearningPathCreateOrConnectWithoutPromoCodesInput[]
    connect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
  }

  export type CourseUpdateManyWithoutPromoCodesNestedInput = {
    create?: XOR<CourseCreateWithoutPromoCodesInput, CourseUncheckedCreateWithoutPromoCodesInput> | CourseCreateWithoutPromoCodesInput[] | CourseUncheckedCreateWithoutPromoCodesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutPromoCodesInput | CourseCreateOrConnectWithoutPromoCodesInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutPromoCodesInput | CourseUpsertWithWhereUniqueWithoutPromoCodesInput[]
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutPromoCodesInput | CourseUpdateWithWhereUniqueWithoutPromoCodesInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutPromoCodesInput | CourseUpdateManyWithWhereWithoutPromoCodesInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type WorkshopUpdateManyWithoutPromoCodesNestedInput = {
    create?: XOR<WorkshopCreateWithoutPromoCodesInput, WorkshopUncheckedCreateWithoutPromoCodesInput> | WorkshopCreateWithoutPromoCodesInput[] | WorkshopUncheckedCreateWithoutPromoCodesInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutPromoCodesInput | WorkshopCreateOrConnectWithoutPromoCodesInput[]
    upsert?: WorkshopUpsertWithWhereUniqueWithoutPromoCodesInput | WorkshopUpsertWithWhereUniqueWithoutPromoCodesInput[]
    set?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    disconnect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    delete?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    update?: WorkshopUpdateWithWhereUniqueWithoutPromoCodesInput | WorkshopUpdateWithWhereUniqueWithoutPromoCodesInput[]
    updateMany?: WorkshopUpdateManyWithWhereWithoutPromoCodesInput | WorkshopUpdateManyWithWhereWithoutPromoCodesInput[]
    deleteMany?: WorkshopScalarWhereInput | WorkshopScalarWhereInput[]
  }

  export type LearningPathUpdateManyWithoutPromoCodesNestedInput = {
    create?: XOR<LearningPathCreateWithoutPromoCodesInput, LearningPathUncheckedCreateWithoutPromoCodesInput> | LearningPathCreateWithoutPromoCodesInput[] | LearningPathUncheckedCreateWithoutPromoCodesInput[]
    connectOrCreate?: LearningPathCreateOrConnectWithoutPromoCodesInput | LearningPathCreateOrConnectWithoutPromoCodesInput[]
    upsert?: LearningPathUpsertWithWhereUniqueWithoutPromoCodesInput | LearningPathUpsertWithWhereUniqueWithoutPromoCodesInput[]
    set?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    disconnect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    delete?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    connect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    update?: LearningPathUpdateWithWhereUniqueWithoutPromoCodesInput | LearningPathUpdateWithWhereUniqueWithoutPromoCodesInput[]
    updateMany?: LearningPathUpdateManyWithWhereWithoutPromoCodesInput | LearningPathUpdateManyWithWhereWithoutPromoCodesInput[]
    deleteMany?: LearningPathScalarWhereInput | LearningPathScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutPromoCodesNestedInput = {
    create?: XOR<CourseCreateWithoutPromoCodesInput, CourseUncheckedCreateWithoutPromoCodesInput> | CourseCreateWithoutPromoCodesInput[] | CourseUncheckedCreateWithoutPromoCodesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutPromoCodesInput | CourseCreateOrConnectWithoutPromoCodesInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutPromoCodesInput | CourseUpsertWithWhereUniqueWithoutPromoCodesInput[]
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutPromoCodesInput | CourseUpdateWithWhereUniqueWithoutPromoCodesInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutPromoCodesInput | CourseUpdateManyWithWhereWithoutPromoCodesInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type WorkshopUncheckedUpdateManyWithoutPromoCodesNestedInput = {
    create?: XOR<WorkshopCreateWithoutPromoCodesInput, WorkshopUncheckedCreateWithoutPromoCodesInput> | WorkshopCreateWithoutPromoCodesInput[] | WorkshopUncheckedCreateWithoutPromoCodesInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutPromoCodesInput | WorkshopCreateOrConnectWithoutPromoCodesInput[]
    upsert?: WorkshopUpsertWithWhereUniqueWithoutPromoCodesInput | WorkshopUpsertWithWhereUniqueWithoutPromoCodesInput[]
    set?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    disconnect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    delete?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    update?: WorkshopUpdateWithWhereUniqueWithoutPromoCodesInput | WorkshopUpdateWithWhereUniqueWithoutPromoCodesInput[]
    updateMany?: WorkshopUpdateManyWithWhereWithoutPromoCodesInput | WorkshopUpdateManyWithWhereWithoutPromoCodesInput[]
    deleteMany?: WorkshopScalarWhereInput | WorkshopScalarWhereInput[]
  }

  export type LearningPathUncheckedUpdateManyWithoutPromoCodesNestedInput = {
    create?: XOR<LearningPathCreateWithoutPromoCodesInput, LearningPathUncheckedCreateWithoutPromoCodesInput> | LearningPathCreateWithoutPromoCodesInput[] | LearningPathUncheckedCreateWithoutPromoCodesInput[]
    connectOrCreate?: LearningPathCreateOrConnectWithoutPromoCodesInput | LearningPathCreateOrConnectWithoutPromoCodesInput[]
    upsert?: LearningPathUpsertWithWhereUniqueWithoutPromoCodesInput | LearningPathUpsertWithWhereUniqueWithoutPromoCodesInput[]
    set?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    disconnect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    delete?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    connect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    update?: LearningPathUpdateWithWhereUniqueWithoutPromoCodesInput | LearningPathUpdateWithWhereUniqueWithoutPromoCodesInput[]
    updateMany?: LearningPathUpdateManyWithWhereWithoutPromoCodesInput | LearningPathUpdateManyWithWhereWithoutPromoCodesInput[]
    deleteMany?: LearningPathScalarWhereInput | LearningPathScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
  }

  export type LearningPathCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<LearningPathCreateWithoutEnrollmentsInput, LearningPathUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutEnrollmentsInput
    connect?: LearningPathWhereUniqueInput
  }

  export type WorkshopCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<WorkshopCreateWithoutEnrollmentsInput, WorkshopUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutEnrollmentsInput
    connect?: WorkshopWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEnrollmentInput = {
    create?: XOR<UserCreateWithoutEnrollmentInput, UserUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutEnrollmentInput = {
    create?: XOR<PaymentCreateWithoutEnrollmentInput, PaymentUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutEnrollmentInput
    connect?: PaymentWhereUniqueInput
  }

  export type EnumenrollmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.enrollmentStatus
  }

  export type CourseUpdateOneWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseUpsertWithoutEnrollmentsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutEnrollmentsInput, CourseUpdateWithoutEnrollmentsInput>, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type LearningPathUpdateOneWithoutEnrollmentsNestedInput = {
    create?: XOR<LearningPathCreateWithoutEnrollmentsInput, LearningPathUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutEnrollmentsInput
    upsert?: LearningPathUpsertWithoutEnrollmentsInput
    disconnect?: LearningPathWhereInput | boolean
    delete?: LearningPathWhereInput | boolean
    connect?: LearningPathWhereUniqueInput
    update?: XOR<XOR<LearningPathUpdateToOneWithWhereWithoutEnrollmentsInput, LearningPathUpdateWithoutEnrollmentsInput>, LearningPathUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type WorkshopUpdateOneWithoutEnrollmentsNestedInput = {
    create?: XOR<WorkshopCreateWithoutEnrollmentsInput, WorkshopUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutEnrollmentsInput
    upsert?: WorkshopUpsertWithoutEnrollmentsInput
    disconnect?: WorkshopWhereInput | boolean
    delete?: WorkshopWhereInput | boolean
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutEnrollmentsInput, WorkshopUpdateWithoutEnrollmentsInput>, WorkshopUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserUpdateOneRequiredWithoutEnrollmentNestedInput = {
    create?: XOR<UserCreateWithoutEnrollmentInput, UserUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentInput
    upsert?: UserUpsertWithoutEnrollmentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnrollmentInput, UserUpdateWithoutEnrollmentInput>, UserUncheckedUpdateWithoutEnrollmentInput>
  }

  export type PaymentUpdateOneWithoutEnrollmentNestedInput = {
    create?: XOR<PaymentCreateWithoutEnrollmentInput, PaymentUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutEnrollmentInput
    upsert?: PaymentUpsertWithoutEnrollmentInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutEnrollmentInput, PaymentUpdateWithoutEnrollmentInput>, PaymentUncheckedUpdateWithoutEnrollmentInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CourseCreateWithoutPaymentsInput, CourseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPaymentsInput
    connect?: CourseWhereUniqueInput
  }

  export type LearningPathCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<LearningPathCreateWithoutPaymentsInput, LearningPathUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutPaymentsInput
    connect?: LearningPathWhereUniqueInput
  }

  export type WorkshopCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<WorkshopCreateWithoutPaymentsInput, WorkshopUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutPaymentsInput
    connect?: WorkshopWhereUniqueInput
  }

  export type EnrollmentCreateNestedOneWithoutPaymentInput = {
    create?: XOR<EnrollmentCreateWithoutPaymentInput, EnrollmentUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutPaymentInput
    connect?: EnrollmentWhereUniqueInput
  }

  export type EnrollmentUncheckedCreateNestedOneWithoutPaymentInput = {
    create?: XOR<EnrollmentCreateWithoutPaymentInput, EnrollmentUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutPaymentInput
    connect?: EnrollmentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type CourseUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<CourseCreateWithoutPaymentsInput, CourseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPaymentsInput
    upsert?: CourseUpsertWithoutPaymentsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutPaymentsInput, CourseUpdateWithoutPaymentsInput>, CourseUncheckedUpdateWithoutPaymentsInput>
  }

  export type LearningPathUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<LearningPathCreateWithoutPaymentsInput, LearningPathUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutPaymentsInput
    upsert?: LearningPathUpsertWithoutPaymentsInput
    disconnect?: LearningPathWhereInput | boolean
    delete?: LearningPathWhereInput | boolean
    connect?: LearningPathWhereUniqueInput
    update?: XOR<XOR<LearningPathUpdateToOneWithWhereWithoutPaymentsInput, LearningPathUpdateWithoutPaymentsInput>, LearningPathUncheckedUpdateWithoutPaymentsInput>
  }

  export type WorkshopUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<WorkshopCreateWithoutPaymentsInput, WorkshopUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutPaymentsInput
    upsert?: WorkshopUpsertWithoutPaymentsInput
    disconnect?: WorkshopWhereInput | boolean
    delete?: WorkshopWhereInput | boolean
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutPaymentsInput, WorkshopUpdateWithoutPaymentsInput>, WorkshopUncheckedUpdateWithoutPaymentsInput>
  }

  export type EnrollmentUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<EnrollmentCreateWithoutPaymentInput, EnrollmentUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutPaymentInput
    upsert?: EnrollmentUpsertWithoutPaymentInput
    disconnect?: EnrollmentWhereInput | boolean
    delete?: EnrollmentWhereInput | boolean
    connect?: EnrollmentWhereUniqueInput
    update?: XOR<XOR<EnrollmentUpdateToOneWithWhereWithoutPaymentInput, EnrollmentUpdateWithoutPaymentInput>, EnrollmentUncheckedUpdateWithoutPaymentInput>
  }

  export type EnrollmentUncheckedUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<EnrollmentCreateWithoutPaymentInput, EnrollmentUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutPaymentInput
    upsert?: EnrollmentUpsertWithoutPaymentInput
    disconnect?: EnrollmentWhereInput | boolean
    delete?: EnrollmentWhereInput | boolean
    connect?: EnrollmentWhereUniqueInput
    update?: XOR<XOR<EnrollmentUpdateToOneWithWhereWithoutPaymentInput, EnrollmentUpdateWithoutPaymentInput>, EnrollmentUncheckedUpdateWithoutPaymentInput>
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type CourseObjectiveCreateNestedManyWithoutObjectiveInput = {
    create?: XOR<CourseObjectiveCreateWithoutObjectiveInput, CourseObjectiveUncheckedCreateWithoutObjectiveInput> | CourseObjectiveCreateWithoutObjectiveInput[] | CourseObjectiveUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: CourseObjectiveCreateOrConnectWithoutObjectiveInput | CourseObjectiveCreateOrConnectWithoutObjectiveInput[]
    createMany?: CourseObjectiveCreateManyObjectiveInputEnvelope
    connect?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
  }

  export type WorkshopObjectiveCreateNestedManyWithoutObjectiveInput = {
    create?: XOR<WorkshopObjectiveCreateWithoutObjectiveInput, WorkshopObjectiveUncheckedCreateWithoutObjectiveInput> | WorkshopObjectiveCreateWithoutObjectiveInput[] | WorkshopObjectiveUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: WorkshopObjectiveCreateOrConnectWithoutObjectiveInput | WorkshopObjectiveCreateOrConnectWithoutObjectiveInput[]
    createMany?: WorkshopObjectiveCreateManyObjectiveInputEnvelope
    connect?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
  }

  export type LearningPathObjectiveCreateNestedManyWithoutObjectiveInput = {
    create?: XOR<LearningPathObjectiveCreateWithoutObjectiveInput, LearningPathObjectiveUncheckedCreateWithoutObjectiveInput> | LearningPathObjectiveCreateWithoutObjectiveInput[] | LearningPathObjectiveUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: LearningPathObjectiveCreateOrConnectWithoutObjectiveInput | LearningPathObjectiveCreateOrConnectWithoutObjectiveInput[]
    createMany?: LearningPathObjectiveCreateManyObjectiveInputEnvelope
    connect?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
  }

  export type CourseObjectiveUncheckedCreateNestedManyWithoutObjectiveInput = {
    create?: XOR<CourseObjectiveCreateWithoutObjectiveInput, CourseObjectiveUncheckedCreateWithoutObjectiveInput> | CourseObjectiveCreateWithoutObjectiveInput[] | CourseObjectiveUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: CourseObjectiveCreateOrConnectWithoutObjectiveInput | CourseObjectiveCreateOrConnectWithoutObjectiveInput[]
    createMany?: CourseObjectiveCreateManyObjectiveInputEnvelope
    connect?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
  }

  export type WorkshopObjectiveUncheckedCreateNestedManyWithoutObjectiveInput = {
    create?: XOR<WorkshopObjectiveCreateWithoutObjectiveInput, WorkshopObjectiveUncheckedCreateWithoutObjectiveInput> | WorkshopObjectiveCreateWithoutObjectiveInput[] | WorkshopObjectiveUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: WorkshopObjectiveCreateOrConnectWithoutObjectiveInput | WorkshopObjectiveCreateOrConnectWithoutObjectiveInput[]
    createMany?: WorkshopObjectiveCreateManyObjectiveInputEnvelope
    connect?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
  }

  export type LearningPathObjectiveUncheckedCreateNestedManyWithoutObjectiveInput = {
    create?: XOR<LearningPathObjectiveCreateWithoutObjectiveInput, LearningPathObjectiveUncheckedCreateWithoutObjectiveInput> | LearningPathObjectiveCreateWithoutObjectiveInput[] | LearningPathObjectiveUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: LearningPathObjectiveCreateOrConnectWithoutObjectiveInput | LearningPathObjectiveCreateOrConnectWithoutObjectiveInput[]
    createMany?: LearningPathObjectiveCreateManyObjectiveInputEnvelope
    connect?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
  }

  export type CourseObjectiveUpdateManyWithoutObjectiveNestedInput = {
    create?: XOR<CourseObjectiveCreateWithoutObjectiveInput, CourseObjectiveUncheckedCreateWithoutObjectiveInput> | CourseObjectiveCreateWithoutObjectiveInput[] | CourseObjectiveUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: CourseObjectiveCreateOrConnectWithoutObjectiveInput | CourseObjectiveCreateOrConnectWithoutObjectiveInput[]
    upsert?: CourseObjectiveUpsertWithWhereUniqueWithoutObjectiveInput | CourseObjectiveUpsertWithWhereUniqueWithoutObjectiveInput[]
    createMany?: CourseObjectiveCreateManyObjectiveInputEnvelope
    set?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    disconnect?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    delete?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    connect?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    update?: CourseObjectiveUpdateWithWhereUniqueWithoutObjectiveInput | CourseObjectiveUpdateWithWhereUniqueWithoutObjectiveInput[]
    updateMany?: CourseObjectiveUpdateManyWithWhereWithoutObjectiveInput | CourseObjectiveUpdateManyWithWhereWithoutObjectiveInput[]
    deleteMany?: CourseObjectiveScalarWhereInput | CourseObjectiveScalarWhereInput[]
  }

  export type WorkshopObjectiveUpdateManyWithoutObjectiveNestedInput = {
    create?: XOR<WorkshopObjectiveCreateWithoutObjectiveInput, WorkshopObjectiveUncheckedCreateWithoutObjectiveInput> | WorkshopObjectiveCreateWithoutObjectiveInput[] | WorkshopObjectiveUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: WorkshopObjectiveCreateOrConnectWithoutObjectiveInput | WorkshopObjectiveCreateOrConnectWithoutObjectiveInput[]
    upsert?: WorkshopObjectiveUpsertWithWhereUniqueWithoutObjectiveInput | WorkshopObjectiveUpsertWithWhereUniqueWithoutObjectiveInput[]
    createMany?: WorkshopObjectiveCreateManyObjectiveInputEnvelope
    set?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    disconnect?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    delete?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    connect?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    update?: WorkshopObjectiveUpdateWithWhereUniqueWithoutObjectiveInput | WorkshopObjectiveUpdateWithWhereUniqueWithoutObjectiveInput[]
    updateMany?: WorkshopObjectiveUpdateManyWithWhereWithoutObjectiveInput | WorkshopObjectiveUpdateManyWithWhereWithoutObjectiveInput[]
    deleteMany?: WorkshopObjectiveScalarWhereInput | WorkshopObjectiveScalarWhereInput[]
  }

  export type LearningPathObjectiveUpdateManyWithoutObjectiveNestedInput = {
    create?: XOR<LearningPathObjectiveCreateWithoutObjectiveInput, LearningPathObjectiveUncheckedCreateWithoutObjectiveInput> | LearningPathObjectiveCreateWithoutObjectiveInput[] | LearningPathObjectiveUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: LearningPathObjectiveCreateOrConnectWithoutObjectiveInput | LearningPathObjectiveCreateOrConnectWithoutObjectiveInput[]
    upsert?: LearningPathObjectiveUpsertWithWhereUniqueWithoutObjectiveInput | LearningPathObjectiveUpsertWithWhereUniqueWithoutObjectiveInput[]
    createMany?: LearningPathObjectiveCreateManyObjectiveInputEnvelope
    set?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    disconnect?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    delete?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    connect?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    update?: LearningPathObjectiveUpdateWithWhereUniqueWithoutObjectiveInput | LearningPathObjectiveUpdateWithWhereUniqueWithoutObjectiveInput[]
    updateMany?: LearningPathObjectiveUpdateManyWithWhereWithoutObjectiveInput | LearningPathObjectiveUpdateManyWithWhereWithoutObjectiveInput[]
    deleteMany?: LearningPathObjectiveScalarWhereInput | LearningPathObjectiveScalarWhereInput[]
  }

  export type CourseObjectiveUncheckedUpdateManyWithoutObjectiveNestedInput = {
    create?: XOR<CourseObjectiveCreateWithoutObjectiveInput, CourseObjectiveUncheckedCreateWithoutObjectiveInput> | CourseObjectiveCreateWithoutObjectiveInput[] | CourseObjectiveUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: CourseObjectiveCreateOrConnectWithoutObjectiveInput | CourseObjectiveCreateOrConnectWithoutObjectiveInput[]
    upsert?: CourseObjectiveUpsertWithWhereUniqueWithoutObjectiveInput | CourseObjectiveUpsertWithWhereUniqueWithoutObjectiveInput[]
    createMany?: CourseObjectiveCreateManyObjectiveInputEnvelope
    set?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    disconnect?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    delete?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    connect?: CourseObjectiveWhereUniqueInput | CourseObjectiveWhereUniqueInput[]
    update?: CourseObjectiveUpdateWithWhereUniqueWithoutObjectiveInput | CourseObjectiveUpdateWithWhereUniqueWithoutObjectiveInput[]
    updateMany?: CourseObjectiveUpdateManyWithWhereWithoutObjectiveInput | CourseObjectiveUpdateManyWithWhereWithoutObjectiveInput[]
    deleteMany?: CourseObjectiveScalarWhereInput | CourseObjectiveScalarWhereInput[]
  }

  export type WorkshopObjectiveUncheckedUpdateManyWithoutObjectiveNestedInput = {
    create?: XOR<WorkshopObjectiveCreateWithoutObjectiveInput, WorkshopObjectiveUncheckedCreateWithoutObjectiveInput> | WorkshopObjectiveCreateWithoutObjectiveInput[] | WorkshopObjectiveUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: WorkshopObjectiveCreateOrConnectWithoutObjectiveInput | WorkshopObjectiveCreateOrConnectWithoutObjectiveInput[]
    upsert?: WorkshopObjectiveUpsertWithWhereUniqueWithoutObjectiveInput | WorkshopObjectiveUpsertWithWhereUniqueWithoutObjectiveInput[]
    createMany?: WorkshopObjectiveCreateManyObjectiveInputEnvelope
    set?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    disconnect?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    delete?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    connect?: WorkshopObjectiveWhereUniqueInput | WorkshopObjectiveWhereUniqueInput[]
    update?: WorkshopObjectiveUpdateWithWhereUniqueWithoutObjectiveInput | WorkshopObjectiveUpdateWithWhereUniqueWithoutObjectiveInput[]
    updateMany?: WorkshopObjectiveUpdateManyWithWhereWithoutObjectiveInput | WorkshopObjectiveUpdateManyWithWhereWithoutObjectiveInput[]
    deleteMany?: WorkshopObjectiveScalarWhereInput | WorkshopObjectiveScalarWhereInput[]
  }

  export type LearningPathObjectiveUncheckedUpdateManyWithoutObjectiveNestedInput = {
    create?: XOR<LearningPathObjectiveCreateWithoutObjectiveInput, LearningPathObjectiveUncheckedCreateWithoutObjectiveInput> | LearningPathObjectiveCreateWithoutObjectiveInput[] | LearningPathObjectiveUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: LearningPathObjectiveCreateOrConnectWithoutObjectiveInput | LearningPathObjectiveCreateOrConnectWithoutObjectiveInput[]
    upsert?: LearningPathObjectiveUpsertWithWhereUniqueWithoutObjectiveInput | LearningPathObjectiveUpsertWithWhereUniqueWithoutObjectiveInput[]
    createMany?: LearningPathObjectiveCreateManyObjectiveInputEnvelope
    set?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    disconnect?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    delete?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    connect?: LearningPathObjectiveWhereUniqueInput | LearningPathObjectiveWhereUniqueInput[]
    update?: LearningPathObjectiveUpdateWithWhereUniqueWithoutObjectiveInput | LearningPathObjectiveUpdateWithWhereUniqueWithoutObjectiveInput[]
    updateMany?: LearningPathObjectiveUpdateManyWithWhereWithoutObjectiveInput | LearningPathObjectiveUpdateManyWithWhereWithoutObjectiveInput[]
    deleteMany?: LearningPathObjectiveScalarWhereInput | LearningPathObjectiveScalarWhereInput[]
  }

  export type CoursePrerequisiteCreateNestedManyWithoutPrerequisiteInput = {
    create?: XOR<CoursePrerequisiteCreateWithoutPrerequisiteInput, CoursePrerequisiteUncheckedCreateWithoutPrerequisiteInput> | CoursePrerequisiteCreateWithoutPrerequisiteInput[] | CoursePrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: CoursePrerequisiteCreateOrConnectWithoutPrerequisiteInput | CoursePrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    createMany?: CoursePrerequisiteCreateManyPrerequisiteInputEnvelope
    connect?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
  }

  export type WorkshopPrerequisiteCreateNestedManyWithoutPrerequisiteInput = {
    create?: XOR<WorkshopPrerequisiteCreateWithoutPrerequisiteInput, WorkshopPrerequisiteUncheckedCreateWithoutPrerequisiteInput> | WorkshopPrerequisiteCreateWithoutPrerequisiteInput[] | WorkshopPrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: WorkshopPrerequisiteCreateOrConnectWithoutPrerequisiteInput | WorkshopPrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    createMany?: WorkshopPrerequisiteCreateManyPrerequisiteInputEnvelope
    connect?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
  }

  export type LearningPathPrerequisiteCreateNestedManyWithoutPrerequisiteInput = {
    create?: XOR<LearningPathPrerequisiteCreateWithoutPrerequisiteInput, LearningPathPrerequisiteUncheckedCreateWithoutPrerequisiteInput> | LearningPathPrerequisiteCreateWithoutPrerequisiteInput[] | LearningPathPrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: LearningPathPrerequisiteCreateOrConnectWithoutPrerequisiteInput | LearningPathPrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    createMany?: LearningPathPrerequisiteCreateManyPrerequisiteInputEnvelope
    connect?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
  }

  export type CoursePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput = {
    create?: XOR<CoursePrerequisiteCreateWithoutPrerequisiteInput, CoursePrerequisiteUncheckedCreateWithoutPrerequisiteInput> | CoursePrerequisiteCreateWithoutPrerequisiteInput[] | CoursePrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: CoursePrerequisiteCreateOrConnectWithoutPrerequisiteInput | CoursePrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    createMany?: CoursePrerequisiteCreateManyPrerequisiteInputEnvelope
    connect?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
  }

  export type WorkshopPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput = {
    create?: XOR<WorkshopPrerequisiteCreateWithoutPrerequisiteInput, WorkshopPrerequisiteUncheckedCreateWithoutPrerequisiteInput> | WorkshopPrerequisiteCreateWithoutPrerequisiteInput[] | WorkshopPrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: WorkshopPrerequisiteCreateOrConnectWithoutPrerequisiteInput | WorkshopPrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    createMany?: WorkshopPrerequisiteCreateManyPrerequisiteInputEnvelope
    connect?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
  }

  export type LearningPathPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput = {
    create?: XOR<LearningPathPrerequisiteCreateWithoutPrerequisiteInput, LearningPathPrerequisiteUncheckedCreateWithoutPrerequisiteInput> | LearningPathPrerequisiteCreateWithoutPrerequisiteInput[] | LearningPathPrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: LearningPathPrerequisiteCreateOrConnectWithoutPrerequisiteInput | LearningPathPrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    createMany?: LearningPathPrerequisiteCreateManyPrerequisiteInputEnvelope
    connect?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
  }

  export type CoursePrerequisiteUpdateManyWithoutPrerequisiteNestedInput = {
    create?: XOR<CoursePrerequisiteCreateWithoutPrerequisiteInput, CoursePrerequisiteUncheckedCreateWithoutPrerequisiteInput> | CoursePrerequisiteCreateWithoutPrerequisiteInput[] | CoursePrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: CoursePrerequisiteCreateOrConnectWithoutPrerequisiteInput | CoursePrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    upsert?: CoursePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput | CoursePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput[]
    createMany?: CoursePrerequisiteCreateManyPrerequisiteInputEnvelope
    set?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    disconnect?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    delete?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    connect?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    update?: CoursePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput | CoursePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput[]
    updateMany?: CoursePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput | CoursePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput[]
    deleteMany?: CoursePrerequisiteScalarWhereInput | CoursePrerequisiteScalarWhereInput[]
  }

  export type WorkshopPrerequisiteUpdateManyWithoutPrerequisiteNestedInput = {
    create?: XOR<WorkshopPrerequisiteCreateWithoutPrerequisiteInput, WorkshopPrerequisiteUncheckedCreateWithoutPrerequisiteInput> | WorkshopPrerequisiteCreateWithoutPrerequisiteInput[] | WorkshopPrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: WorkshopPrerequisiteCreateOrConnectWithoutPrerequisiteInput | WorkshopPrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    upsert?: WorkshopPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput | WorkshopPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput[]
    createMany?: WorkshopPrerequisiteCreateManyPrerequisiteInputEnvelope
    set?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    disconnect?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    delete?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    connect?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    update?: WorkshopPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput | WorkshopPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput[]
    updateMany?: WorkshopPrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput | WorkshopPrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput[]
    deleteMany?: WorkshopPrerequisiteScalarWhereInput | WorkshopPrerequisiteScalarWhereInput[]
  }

  export type LearningPathPrerequisiteUpdateManyWithoutPrerequisiteNestedInput = {
    create?: XOR<LearningPathPrerequisiteCreateWithoutPrerequisiteInput, LearningPathPrerequisiteUncheckedCreateWithoutPrerequisiteInput> | LearningPathPrerequisiteCreateWithoutPrerequisiteInput[] | LearningPathPrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: LearningPathPrerequisiteCreateOrConnectWithoutPrerequisiteInput | LearningPathPrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    upsert?: LearningPathPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput | LearningPathPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput[]
    createMany?: LearningPathPrerequisiteCreateManyPrerequisiteInputEnvelope
    set?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    disconnect?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    delete?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    connect?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    update?: LearningPathPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput | LearningPathPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput[]
    updateMany?: LearningPathPrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput | LearningPathPrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput[]
    deleteMany?: LearningPathPrerequisiteScalarWhereInput | LearningPathPrerequisiteScalarWhereInput[]
  }

  export type CoursePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput = {
    create?: XOR<CoursePrerequisiteCreateWithoutPrerequisiteInput, CoursePrerequisiteUncheckedCreateWithoutPrerequisiteInput> | CoursePrerequisiteCreateWithoutPrerequisiteInput[] | CoursePrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: CoursePrerequisiteCreateOrConnectWithoutPrerequisiteInput | CoursePrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    upsert?: CoursePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput | CoursePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput[]
    createMany?: CoursePrerequisiteCreateManyPrerequisiteInputEnvelope
    set?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    disconnect?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    delete?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    connect?: CoursePrerequisiteWhereUniqueInput | CoursePrerequisiteWhereUniqueInput[]
    update?: CoursePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput | CoursePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput[]
    updateMany?: CoursePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput | CoursePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput[]
    deleteMany?: CoursePrerequisiteScalarWhereInput | CoursePrerequisiteScalarWhereInput[]
  }

  export type WorkshopPrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput = {
    create?: XOR<WorkshopPrerequisiteCreateWithoutPrerequisiteInput, WorkshopPrerequisiteUncheckedCreateWithoutPrerequisiteInput> | WorkshopPrerequisiteCreateWithoutPrerequisiteInput[] | WorkshopPrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: WorkshopPrerequisiteCreateOrConnectWithoutPrerequisiteInput | WorkshopPrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    upsert?: WorkshopPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput | WorkshopPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput[]
    createMany?: WorkshopPrerequisiteCreateManyPrerequisiteInputEnvelope
    set?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    disconnect?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    delete?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    connect?: WorkshopPrerequisiteWhereUniqueInput | WorkshopPrerequisiteWhereUniqueInput[]
    update?: WorkshopPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput | WorkshopPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput[]
    updateMany?: WorkshopPrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput | WorkshopPrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput[]
    deleteMany?: WorkshopPrerequisiteScalarWhereInput | WorkshopPrerequisiteScalarWhereInput[]
  }

  export type LearningPathPrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput = {
    create?: XOR<LearningPathPrerequisiteCreateWithoutPrerequisiteInput, LearningPathPrerequisiteUncheckedCreateWithoutPrerequisiteInput> | LearningPathPrerequisiteCreateWithoutPrerequisiteInput[] | LearningPathPrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: LearningPathPrerequisiteCreateOrConnectWithoutPrerequisiteInput | LearningPathPrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    upsert?: LearningPathPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput | LearningPathPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput[]
    createMany?: LearningPathPrerequisiteCreateManyPrerequisiteInputEnvelope
    set?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    disconnect?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    delete?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    connect?: LearningPathPrerequisiteWhereUniqueInput | LearningPathPrerequisiteWhereUniqueInput[]
    update?: LearningPathPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput | LearningPathPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput[]
    updateMany?: LearningPathPrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput | LearningPathPrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput[]
    deleteMany?: LearningPathPrerequisiteScalarWhereInput | LearningPathPrerequisiteScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutObjectivesInput = {
    create?: XOR<CourseCreateWithoutObjectivesInput, CourseUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutObjectivesInput
    connect?: CourseWhereUniqueInput
  }

  export type ObjectiveCreateNestedOneWithoutCoursesInput = {
    create?: XOR<ObjectiveCreateWithoutCoursesInput, ObjectiveUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutCoursesInput
    connect?: ObjectiveWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutObjectivesNestedInput = {
    create?: XOR<CourseCreateWithoutObjectivesInput, CourseUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutObjectivesInput
    upsert?: CourseUpsertWithoutObjectivesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutObjectivesInput, CourseUpdateWithoutObjectivesInput>, CourseUncheckedUpdateWithoutObjectivesInput>
  }

  export type ObjectiveUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<ObjectiveCreateWithoutCoursesInput, ObjectiveUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutCoursesInput
    upsert?: ObjectiveUpsertWithoutCoursesInput
    connect?: ObjectiveWhereUniqueInput
    update?: XOR<XOR<ObjectiveUpdateToOneWithWhereWithoutCoursesInput, ObjectiveUpdateWithoutCoursesInput>, ObjectiveUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseCreateNestedOneWithoutPrerequisitesInput = {
    create?: XOR<CourseCreateWithoutPrerequisitesInput, CourseUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPrerequisitesInput
    connect?: CourseWhereUniqueInput
  }

  export type PrerequisiteCreateNestedOneWithoutCoursesInput = {
    create?: XOR<PrerequisiteCreateWithoutCoursesInput, PrerequisiteUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutCoursesInput
    connect?: PrerequisiteWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutPrerequisitesNestedInput = {
    create?: XOR<CourseCreateWithoutPrerequisitesInput, CourseUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPrerequisitesInput
    upsert?: CourseUpsertWithoutPrerequisitesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutPrerequisitesInput, CourseUpdateWithoutPrerequisitesInput>, CourseUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type PrerequisiteUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<PrerequisiteCreateWithoutCoursesInput, PrerequisiteUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutCoursesInput
    upsert?: PrerequisiteUpsertWithoutCoursesInput
    connect?: PrerequisiteWhereUniqueInput
    update?: XOR<XOR<PrerequisiteUpdateToOneWithWhereWithoutCoursesInput, PrerequisiteUpdateWithoutCoursesInput>, PrerequisiteUncheckedUpdateWithoutCoursesInput>
  }

  export type WorkshopCreateNestedOneWithoutObjectivesInput = {
    create?: XOR<WorkshopCreateWithoutObjectivesInput, WorkshopUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutObjectivesInput
    connect?: WorkshopWhereUniqueInput
  }

  export type ObjectiveCreateNestedOneWithoutWorkshopsInput = {
    create?: XOR<ObjectiveCreateWithoutWorkshopsInput, ObjectiveUncheckedCreateWithoutWorkshopsInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutWorkshopsInput
    connect?: ObjectiveWhereUniqueInput
  }

  export type WorkshopUpdateOneRequiredWithoutObjectivesNestedInput = {
    create?: XOR<WorkshopCreateWithoutObjectivesInput, WorkshopUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutObjectivesInput
    upsert?: WorkshopUpsertWithoutObjectivesInput
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutObjectivesInput, WorkshopUpdateWithoutObjectivesInput>, WorkshopUncheckedUpdateWithoutObjectivesInput>
  }

  export type ObjectiveUpdateOneRequiredWithoutWorkshopsNestedInput = {
    create?: XOR<ObjectiveCreateWithoutWorkshopsInput, ObjectiveUncheckedCreateWithoutWorkshopsInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutWorkshopsInput
    upsert?: ObjectiveUpsertWithoutWorkshopsInput
    connect?: ObjectiveWhereUniqueInput
    update?: XOR<XOR<ObjectiveUpdateToOneWithWhereWithoutWorkshopsInput, ObjectiveUpdateWithoutWorkshopsInput>, ObjectiveUncheckedUpdateWithoutWorkshopsInput>
  }

  export type WorkshopCreateNestedOneWithoutPrerequisitesInput = {
    create?: XOR<WorkshopCreateWithoutPrerequisitesInput, WorkshopUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutPrerequisitesInput
    connect?: WorkshopWhereUniqueInput
  }

  export type PrerequisiteCreateNestedOneWithoutWorkshopsInput = {
    create?: XOR<PrerequisiteCreateWithoutWorkshopsInput, PrerequisiteUncheckedCreateWithoutWorkshopsInput>
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutWorkshopsInput
    connect?: PrerequisiteWhereUniqueInput
  }

  export type WorkshopUpdateOneRequiredWithoutPrerequisitesNestedInput = {
    create?: XOR<WorkshopCreateWithoutPrerequisitesInput, WorkshopUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutPrerequisitesInput
    upsert?: WorkshopUpsertWithoutPrerequisitesInput
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutPrerequisitesInput, WorkshopUpdateWithoutPrerequisitesInput>, WorkshopUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type PrerequisiteUpdateOneRequiredWithoutWorkshopsNestedInput = {
    create?: XOR<PrerequisiteCreateWithoutWorkshopsInput, PrerequisiteUncheckedCreateWithoutWorkshopsInput>
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutWorkshopsInput
    upsert?: PrerequisiteUpsertWithoutWorkshopsInput
    connect?: PrerequisiteWhereUniqueInput
    update?: XOR<XOR<PrerequisiteUpdateToOneWithWhereWithoutWorkshopsInput, PrerequisiteUpdateWithoutWorkshopsInput>, PrerequisiteUncheckedUpdateWithoutWorkshopsInput>
  }

  export type LearningPathCreateNestedOneWithoutObjectivesInput = {
    create?: XOR<LearningPathCreateWithoutObjectivesInput, LearningPathUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutObjectivesInput
    connect?: LearningPathWhereUniqueInput
  }

  export type ObjectiveCreateNestedOneWithoutLearningPathsInput = {
    create?: XOR<ObjectiveCreateWithoutLearningPathsInput, ObjectiveUncheckedCreateWithoutLearningPathsInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutLearningPathsInput
    connect?: ObjectiveWhereUniqueInput
  }

  export type LearningPathUpdateOneRequiredWithoutObjectivesNestedInput = {
    create?: XOR<LearningPathCreateWithoutObjectivesInput, LearningPathUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutObjectivesInput
    upsert?: LearningPathUpsertWithoutObjectivesInput
    connect?: LearningPathWhereUniqueInput
    update?: XOR<XOR<LearningPathUpdateToOneWithWhereWithoutObjectivesInput, LearningPathUpdateWithoutObjectivesInput>, LearningPathUncheckedUpdateWithoutObjectivesInput>
  }

  export type ObjectiveUpdateOneRequiredWithoutLearningPathsNestedInput = {
    create?: XOR<ObjectiveCreateWithoutLearningPathsInput, ObjectiveUncheckedCreateWithoutLearningPathsInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutLearningPathsInput
    upsert?: ObjectiveUpsertWithoutLearningPathsInput
    connect?: ObjectiveWhereUniqueInput
    update?: XOR<XOR<ObjectiveUpdateToOneWithWhereWithoutLearningPathsInput, ObjectiveUpdateWithoutLearningPathsInput>, ObjectiveUncheckedUpdateWithoutLearningPathsInput>
  }

  export type LearningPathCreateNestedOneWithoutPrerequisitesInput = {
    create?: XOR<LearningPathCreateWithoutPrerequisitesInput, LearningPathUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutPrerequisitesInput
    connect?: LearningPathWhereUniqueInput
  }

  export type PrerequisiteCreateNestedOneWithoutLearningPathsInput = {
    create?: XOR<PrerequisiteCreateWithoutLearningPathsInput, PrerequisiteUncheckedCreateWithoutLearningPathsInput>
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutLearningPathsInput
    connect?: PrerequisiteWhereUniqueInput
  }

  export type LearningPathUpdateOneRequiredWithoutPrerequisitesNestedInput = {
    create?: XOR<LearningPathCreateWithoutPrerequisitesInput, LearningPathUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutPrerequisitesInput
    upsert?: LearningPathUpsertWithoutPrerequisitesInput
    connect?: LearningPathWhereUniqueInput
    update?: XOR<XOR<LearningPathUpdateToOneWithWhereWithoutPrerequisitesInput, LearningPathUpdateWithoutPrerequisitesInput>, LearningPathUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type PrerequisiteUpdateOneRequiredWithoutLearningPathsNestedInput = {
    create?: XOR<PrerequisiteCreateWithoutLearningPathsInput, PrerequisiteUncheckedCreateWithoutLearningPathsInput>
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutLearningPathsInput
    upsert?: PrerequisiteUpsertWithoutLearningPathsInput
    connect?: PrerequisiteWhereUniqueInput
    update?: XOR<XOR<PrerequisiteUpdateToOneWithWhereWithoutLearningPathsInput, PrerequisiteUpdateWithoutLearningPathsInput>, PrerequisiteUncheckedUpdateWithoutLearningPathsInput>
  }

  export type CompanySocialLinkCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanySocialLinkCreateWithoutCompanyInput, CompanySocialLinkUncheckedCreateWithoutCompanyInput> | CompanySocialLinkCreateWithoutCompanyInput[] | CompanySocialLinkUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanySocialLinkCreateOrConnectWithoutCompanyInput | CompanySocialLinkCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanySocialLinkCreateManyCompanyInputEnvelope
    connect?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
  }

  export type CompanySocialLinkUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanySocialLinkCreateWithoutCompanyInput, CompanySocialLinkUncheckedCreateWithoutCompanyInput> | CompanySocialLinkCreateWithoutCompanyInput[] | CompanySocialLinkUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanySocialLinkCreateOrConnectWithoutCompanyInput | CompanySocialLinkCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanySocialLinkCreateManyCompanyInputEnvelope
    connect?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
  }

  export type CompanySocialLinkUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanySocialLinkCreateWithoutCompanyInput, CompanySocialLinkUncheckedCreateWithoutCompanyInput> | CompanySocialLinkCreateWithoutCompanyInput[] | CompanySocialLinkUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanySocialLinkCreateOrConnectWithoutCompanyInput | CompanySocialLinkCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanySocialLinkUpsertWithWhereUniqueWithoutCompanyInput | CompanySocialLinkUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanySocialLinkCreateManyCompanyInputEnvelope
    set?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    disconnect?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    delete?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    connect?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    update?: CompanySocialLinkUpdateWithWhereUniqueWithoutCompanyInput | CompanySocialLinkUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanySocialLinkUpdateManyWithWhereWithoutCompanyInput | CompanySocialLinkUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanySocialLinkScalarWhereInput | CompanySocialLinkScalarWhereInput[]
  }

  export type CompanySocialLinkUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanySocialLinkCreateWithoutCompanyInput, CompanySocialLinkUncheckedCreateWithoutCompanyInput> | CompanySocialLinkCreateWithoutCompanyInput[] | CompanySocialLinkUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanySocialLinkCreateOrConnectWithoutCompanyInput | CompanySocialLinkCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanySocialLinkUpsertWithWhereUniqueWithoutCompanyInput | CompanySocialLinkUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanySocialLinkCreateManyCompanyInputEnvelope
    set?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    disconnect?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    delete?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    connect?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    update?: CompanySocialLinkUpdateWithWhereUniqueWithoutCompanyInput | CompanySocialLinkUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanySocialLinkUpdateManyWithWhereWithoutCompanyInput | CompanySocialLinkUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanySocialLinkScalarWhereInput | CompanySocialLinkScalarWhereInput[]
  }

  export type CompanySocialLinkCreateNestedManyWithoutSocialLinkInput = {
    create?: XOR<CompanySocialLinkCreateWithoutSocialLinkInput, CompanySocialLinkUncheckedCreateWithoutSocialLinkInput> | CompanySocialLinkCreateWithoutSocialLinkInput[] | CompanySocialLinkUncheckedCreateWithoutSocialLinkInput[]
    connectOrCreate?: CompanySocialLinkCreateOrConnectWithoutSocialLinkInput | CompanySocialLinkCreateOrConnectWithoutSocialLinkInput[]
    createMany?: CompanySocialLinkCreateManySocialLinkInputEnvelope
    connect?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
  }

  export type CompanySocialLinkUncheckedCreateNestedManyWithoutSocialLinkInput = {
    create?: XOR<CompanySocialLinkCreateWithoutSocialLinkInput, CompanySocialLinkUncheckedCreateWithoutSocialLinkInput> | CompanySocialLinkCreateWithoutSocialLinkInput[] | CompanySocialLinkUncheckedCreateWithoutSocialLinkInput[]
    connectOrCreate?: CompanySocialLinkCreateOrConnectWithoutSocialLinkInput | CompanySocialLinkCreateOrConnectWithoutSocialLinkInput[]
    createMany?: CompanySocialLinkCreateManySocialLinkInputEnvelope
    connect?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
  }

  export type CompanySocialLinkUpdateManyWithoutSocialLinkNestedInput = {
    create?: XOR<CompanySocialLinkCreateWithoutSocialLinkInput, CompanySocialLinkUncheckedCreateWithoutSocialLinkInput> | CompanySocialLinkCreateWithoutSocialLinkInput[] | CompanySocialLinkUncheckedCreateWithoutSocialLinkInput[]
    connectOrCreate?: CompanySocialLinkCreateOrConnectWithoutSocialLinkInput | CompanySocialLinkCreateOrConnectWithoutSocialLinkInput[]
    upsert?: CompanySocialLinkUpsertWithWhereUniqueWithoutSocialLinkInput | CompanySocialLinkUpsertWithWhereUniqueWithoutSocialLinkInput[]
    createMany?: CompanySocialLinkCreateManySocialLinkInputEnvelope
    set?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    disconnect?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    delete?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    connect?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    update?: CompanySocialLinkUpdateWithWhereUniqueWithoutSocialLinkInput | CompanySocialLinkUpdateWithWhereUniqueWithoutSocialLinkInput[]
    updateMany?: CompanySocialLinkUpdateManyWithWhereWithoutSocialLinkInput | CompanySocialLinkUpdateManyWithWhereWithoutSocialLinkInput[]
    deleteMany?: CompanySocialLinkScalarWhereInput | CompanySocialLinkScalarWhereInput[]
  }

  export type CompanySocialLinkUncheckedUpdateManyWithoutSocialLinkNestedInput = {
    create?: XOR<CompanySocialLinkCreateWithoutSocialLinkInput, CompanySocialLinkUncheckedCreateWithoutSocialLinkInput> | CompanySocialLinkCreateWithoutSocialLinkInput[] | CompanySocialLinkUncheckedCreateWithoutSocialLinkInput[]
    connectOrCreate?: CompanySocialLinkCreateOrConnectWithoutSocialLinkInput | CompanySocialLinkCreateOrConnectWithoutSocialLinkInput[]
    upsert?: CompanySocialLinkUpsertWithWhereUniqueWithoutSocialLinkInput | CompanySocialLinkUpsertWithWhereUniqueWithoutSocialLinkInput[]
    createMany?: CompanySocialLinkCreateManySocialLinkInputEnvelope
    set?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    disconnect?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    delete?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    connect?: CompanySocialLinkWhereUniqueInput | CompanySocialLinkWhereUniqueInput[]
    update?: CompanySocialLinkUpdateWithWhereUniqueWithoutSocialLinkInput | CompanySocialLinkUpdateWithWhereUniqueWithoutSocialLinkInput[]
    updateMany?: CompanySocialLinkUpdateManyWithWhereWithoutSocialLinkInput | CompanySocialLinkUpdateManyWithWhereWithoutSocialLinkInput[]
    deleteMany?: CompanySocialLinkScalarWhereInput | CompanySocialLinkScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutCompanySocialLinkInput = {
    create?: XOR<CompanyCreateWithoutCompanySocialLinkInput, CompanyUncheckedCreateWithoutCompanySocialLinkInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanySocialLinkInput
    connect?: CompanyWhereUniqueInput
  }

  export type SocialLinkCreateNestedOneWithoutCompanySocialLinkInput = {
    create?: XOR<SocialLinkCreateWithoutCompanySocialLinkInput, SocialLinkUncheckedCreateWithoutCompanySocialLinkInput>
    connectOrCreate?: SocialLinkCreateOrConnectWithoutCompanySocialLinkInput
    connect?: SocialLinkWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutCompanySocialLinkNestedInput = {
    create?: XOR<CompanyCreateWithoutCompanySocialLinkInput, CompanyUncheckedCreateWithoutCompanySocialLinkInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanySocialLinkInput
    upsert?: CompanyUpsertWithoutCompanySocialLinkInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCompanySocialLinkInput, CompanyUpdateWithoutCompanySocialLinkInput>, CompanyUncheckedUpdateWithoutCompanySocialLinkInput>
  }

  export type SocialLinkUpdateOneRequiredWithoutCompanySocialLinkNestedInput = {
    create?: XOR<SocialLinkCreateWithoutCompanySocialLinkInput, SocialLinkUncheckedCreateWithoutCompanySocialLinkInput>
    connectOrCreate?: SocialLinkCreateOrConnectWithoutCompanySocialLinkInput
    upsert?: SocialLinkUpsertWithoutCompanySocialLinkInput
    connect?: SocialLinkWhereUniqueInput
    update?: XOR<XOR<SocialLinkUpdateToOneWithWhereWithoutCompanySocialLinkInput, SocialLinkUpdateWithoutCompanySocialLinkInput>, SocialLinkUncheckedUpdateWithoutCompanySocialLinkInput>
  }

  export type QuizQuestionCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutQuizInput = {
    create?: XOR<UserCreateWithoutQuizInput, UserUncheckedCreateWithoutQuizInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizInput
    connect?: UserWhereUniqueInput
  }

  export type QuizQuestionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizQuestionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type UserUpdateOneWithoutQuizNestedInput = {
    create?: XOR<UserCreateWithoutQuizInput, UserUncheckedCreateWithoutQuizInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizInput
    upsert?: UserUpsertWithoutQuizInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuizInput, UserUpdateWithoutQuizInput>, UserUncheckedUpdateWithoutQuizInput>
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
  }

  export type QuizOptionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizOptionCreateWithoutQuestionInput, QuizOptionUncheckedCreateWithoutQuestionInput> | QuizOptionCreateWithoutQuestionInput[] | QuizOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizOptionCreateOrConnectWithoutQuestionInput | QuizOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizOptionCreateManyQuestionInputEnvelope
    connect?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
  }

  export type QuizOptionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizOptionCreateWithoutQuestionInput, QuizOptionUncheckedCreateWithoutQuestionInput> | QuizOptionCreateWithoutQuestionInput[] | QuizOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizOptionCreateOrConnectWithoutQuestionInput | QuizOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizOptionCreateManyQuestionInputEnvelope
    connect?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
  }

  export type QuizUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    upsert?: QuizUpsertWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutQuestionsInput, QuizUpdateWithoutQuestionsInput>, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizOptionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizOptionCreateWithoutQuestionInput, QuizOptionUncheckedCreateWithoutQuestionInput> | QuizOptionCreateWithoutQuestionInput[] | QuizOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizOptionCreateOrConnectWithoutQuestionInput | QuizOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizOptionUpsertWithWhereUniqueWithoutQuestionInput | QuizOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizOptionCreateManyQuestionInputEnvelope
    set?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    disconnect?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    delete?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    connect?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    update?: QuizOptionUpdateWithWhereUniqueWithoutQuestionInput | QuizOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizOptionUpdateManyWithWhereWithoutQuestionInput | QuizOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizOptionScalarWhereInput | QuizOptionScalarWhereInput[]
  }

  export type QuizOptionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizOptionCreateWithoutQuestionInput, QuizOptionUncheckedCreateWithoutQuestionInput> | QuizOptionCreateWithoutQuestionInput[] | QuizOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizOptionCreateOrConnectWithoutQuestionInput | QuizOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizOptionUpsertWithWhereUniqueWithoutQuestionInput | QuizOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizOptionCreateManyQuestionInputEnvelope
    set?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    disconnect?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    delete?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    connect?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    update?: QuizOptionUpdateWithWhereUniqueWithoutQuestionInput | QuizOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizOptionUpdateManyWithWhereWithoutQuestionInput | QuizOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizOptionScalarWhereInput | QuizOptionScalarWhereInput[]
  }

  export type QuizQuestionCreateNestedOneWithoutOptionsInput = {
    create?: XOR<QuizQuestionCreateWithoutOptionsInput, QuizQuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutOptionsInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type QuizQuestionUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutOptionsInput, QuizQuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutOptionsInput
    upsert?: QuizQuestionUpsertWithoutOptionsInput
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<XOR<QuizQuestionUpdateToOneWithWhereWithoutOptionsInput, QuizQuestionUpdateWithoutOptionsInput>, QuizQuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumenrollmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.enrollmentStatus | EnumenrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.enrollmentStatus[] | ListEnumenrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.enrollmentStatus[] | ListEnumenrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumenrollmentStatusFilter<$PrismaModel> | $Enums.enrollmentStatus
  }

  export type NestedEnumenrollmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enrollmentStatus | EnumenrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.enrollmentStatus[] | ListEnumenrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.enrollmentStatus[] | ListEnumenrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumenrollmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.enrollmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenrollmentStatusFilter<$PrismaModel>
    _max?: NestedEnumenrollmentStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LessonProgressCreateWithoutUserInput = {
    id?: string
    completed?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    watchedSeconds?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lesson: LessonCreateNestedOneWithoutLessonProgressInput
  }

  export type LessonProgressUncheckedCreateWithoutUserInput = {
    id?: string
    completed?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    watchedSeconds?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lessonId: string
  }

  export type LessonProgressCreateOrConnectWithoutUserInput = {
    where: LessonProgressWhereUniqueInput
    create: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput>
  }

  export type LessonProgressCreateManyUserInputEnvelope = {
    data: LessonProgressCreateManyUserInput | LessonProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutUserInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    course?: CourseCreateNestedOneWithoutEnrollmentsInput
    learningPath?: LearningPathCreateNestedOneWithoutEnrollmentsInput
    workshop?: WorkshopCreateNestedOneWithoutEnrollmentsInput
    payment?: PaymentCreateNestedOneWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: string | null
    learningPathId?: string | null
    workshopId?: string | null
    paymentId?: string | null
    deletedAt?: Date | string | null
  }

  export type EnrollmentCreateOrConnectWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentCreateManyUserInputEnvelope = {
    data: EnrollmentCreateManyUserInput | EnrollmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    stripeId: string
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    course?: CourseCreateNestedOneWithoutPaymentsInput
    learningPath?: LearningPathCreateNestedOneWithoutPaymentsInput
    workshop?: WorkshopCreateNestedOneWithoutPaymentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    stripeId: string
    courseId?: string | null
    learningPathId?: string | null
    workshopId?: string | null
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    enrollment?: EnrollmentUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutUserInput = {
    id?: string
    number: string
    amount: number
    currency?: string
    pdfUrl?: string | null
    date?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutUserInput = {
    id?: string
    number: string
    amount: number
    currency?: string
    pdfUrl?: string | null
    date?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateManyUserInputEnvelope = {
    data: InvoiceCreateManyUserInput | InvoiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutUserInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    category: CategoryCreateNestedOneWithoutCoursesInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    promotions?: PromotionCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    progress?: UserProgressCreateNestedManyWithoutCourseInput
    resources?: CourseResourceCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId: string
    deletedAt?: Date | string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutCourseInput
    resources?: CourseResourceUncheckedCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutUserInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput>
  }

  export type CourseCreateManyUserInputEnvelope = {
    data: CourseCreateManyUserInput | CourseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tags?: LearningPathTagCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearningPathInput
    payments?: PaymentCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tags?: LearningPathTagUncheckedCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceUncheckedCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearningPathInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutUserInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutUserInput, LearningPathUncheckedCreateWithoutUserInput>
  }

  export type LearningPathCreateManyUserInputEnvelope = {
    data: LearningPathCreateManyUserInput | LearningPathCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkshopCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tags?: WorkshopTagCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentCreateNestedManyWithoutWorkshopInput
    payments?: PaymentCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tags?: WorkshopTagUncheckedCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceUncheckedCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveUncheckedCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutWorkshopInput
    payments?: PaymentUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutUserInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutUserInput, WorkshopUncheckedCreateWithoutUserInput>
  }

  export type WorkshopCreateManyUserInputEnvelope = {
    data: WorkshopCreateManyUserInput | WorkshopCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResourceCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    courseResources?: CourseResourceCreateNestedManyWithoutResourceInput
    lessonResources?: LessonResourceCreateNestedManyWithoutResourceInput
    workshopResources?: WorkshopResourceCreateNestedManyWithoutResourceInput
    learningPathResources?: LearningPathResourceCreateNestedManyWithoutResourceInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    courseResources?: CourseResourceUncheckedCreateNestedManyWithoutResourceInput
    lessonResources?: LessonResourceUncheckedCreateNestedManyWithoutResourceInput
    workshopResources?: WorkshopResourceUncheckedCreateNestedManyWithoutResourceInput
    learningPathResources?: LearningPathResourceUncheckedCreateNestedManyWithoutResourceInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutUserInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutUserInput, ResourceUncheckedCreateWithoutUserInput>
  }

  export type ResourceCreateManyUserInputEnvelope = {
    data: ResourceCreateManyUserInput | ResourceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuizCreateWithoutUserInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type?: string | null
    chapterId?: string | null
    courseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type?: string | null
    chapterId?: string | null
    courseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutUserInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutUserInput, QuizUncheckedCreateWithoutUserInput>
  }

  export type QuizCreateManyUserInputEnvelope = {
    data: QuizCreateManyUserInput | QuizCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type LessonProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: LessonProgressWhereUniqueInput
    update: XOR<LessonProgressUpdateWithoutUserInput, LessonProgressUncheckedUpdateWithoutUserInput>
    create: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput>
  }

  export type LessonProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: LessonProgressWhereUniqueInput
    data: XOR<LessonProgressUpdateWithoutUserInput, LessonProgressUncheckedUpdateWithoutUserInput>
  }

  export type LessonProgressUpdateManyWithWhereWithoutUserInput = {
    where: LessonProgressScalarWhereInput
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type LessonProgressScalarWhereInput = {
    AND?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
    OR?: LessonProgressScalarWhereInput[]
    NOT?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
    id?: StringFilter<"LessonProgress"> | string
    completed?: BoolFilter<"LessonProgress"> | boolean
    startTime?: DateTimeNullableFilter<"LessonProgress"> | Date | string | null
    endTime?: DateTimeNullableFilter<"LessonProgress"> | Date | string | null
    watchedSeconds?: IntNullableFilter<"LessonProgress"> | number | null
    createdAt?: DateTimeFilter<"LessonProgress"> | Date | string
    updatedAt?: DateTimeFilter<"LessonProgress"> | Date | string
    userId?: StringFilter<"LessonProgress"> | string
    lessonId?: StringFilter<"LessonProgress"> | string
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutUserInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutUserInput>
  }

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    OR?: EnrollmentScalarWhereInput[]
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    amount?: IntFilter<"Enrollment"> | number
    status?: EnumenrollmentStatusFilter<"Enrollment"> | $Enums.enrollmentStatus
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
    courseId?: StringNullableFilter<"Enrollment"> | string | null
    learningPathId?: StringNullableFilter<"Enrollment"> | string | null
    workshopId?: StringNullableFilter<"Enrollment"> | string | null
    userId?: StringFilter<"Enrollment"> | string
    paymentId?: StringNullableFilter<"Enrollment"> | string | null
    deletedAt?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    stripeId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    courseId?: StringNullableFilter<"Payment"> | string | null
    learningPathId?: StringNullableFilter<"Payment"> | string | null
    workshopId?: StringNullableFilter<"Payment"> | string | null
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    method?: StringNullableFilter<"Payment"> | string | null
    receiptUrl?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUserInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    number?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    amount?: IntFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    date?: DateTimeFilter<"Invoice"> | Date | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
  }

  export type CourseUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutUserInput, CourseUncheckedUpdateWithoutUserInput>
    create: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutUserInput, CourseUncheckedUpdateWithoutUserInput>
  }

  export type CourseUpdateManyWithWhereWithoutUserInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    slug?: StringFilter<"Course"> | string
    smallDescription?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    fileKey?: StringFilter<"Course"> | string
    price?: IntFilter<"Course"> | number
    currency?: StringFilter<"Course"> | string
    duration?: IntFilter<"Course"> | number
    status?: StringFilter<"Course"> | string
    level?: StringFilter<"Course"> | string
    stripePriceId?: StringFilter<"Course"> | string
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    userId?: StringFilter<"Course"> | string
    categoryId?: StringFilter<"Course"> | string
    deletedAt?: DateTimeNullableFilter<"Course"> | Date | string | null
  }

  export type LearningPathUpsertWithWhereUniqueWithoutUserInput = {
    where: LearningPathWhereUniqueInput
    update: XOR<LearningPathUpdateWithoutUserInput, LearningPathUncheckedUpdateWithoutUserInput>
    create: XOR<LearningPathCreateWithoutUserInput, LearningPathUncheckedCreateWithoutUserInput>
  }

  export type LearningPathUpdateWithWhereUniqueWithoutUserInput = {
    where: LearningPathWhereUniqueInput
    data: XOR<LearningPathUpdateWithoutUserInput, LearningPathUncheckedUpdateWithoutUserInput>
  }

  export type LearningPathUpdateManyWithWhereWithoutUserInput = {
    where: LearningPathScalarWhereInput
    data: XOR<LearningPathUpdateManyMutationInput, LearningPathUncheckedUpdateManyWithoutUserInput>
  }

  export type LearningPathScalarWhereInput = {
    AND?: LearningPathScalarWhereInput | LearningPathScalarWhereInput[]
    OR?: LearningPathScalarWhereInput[]
    NOT?: LearningPathScalarWhereInput | LearningPathScalarWhereInput[]
    id?: StringFilter<"LearningPath"> | string
    title?: StringFilter<"LearningPath"> | string
    description?: StringFilter<"LearningPath"> | string
    smallDescription?: StringFilter<"LearningPath"> | string
    fileKey?: StringFilter<"LearningPath"> | string
    price?: IntFilter<"LearningPath"> | number
    currency?: StringFilter<"LearningPath"> | string
    duration?: IntFilter<"LearningPath"> | number
    slug?: StringFilter<"LearningPath"> | string
    status?: StringFilter<"LearningPath"> | string
    level?: StringFilter<"LearningPath"> | string
    stripePriceId?: StringFilter<"LearningPath"> | string
    createdAt?: DateTimeFilter<"LearningPath"> | Date | string
    updatedAt?: DateTimeFilter<"LearningPath"> | Date | string
    userId?: StringFilter<"LearningPath"> | string
    deletedAt?: DateTimeNullableFilter<"LearningPath"> | Date | string | null
  }

  export type WorkshopUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkshopWhereUniqueInput
    update: XOR<WorkshopUpdateWithoutUserInput, WorkshopUncheckedUpdateWithoutUserInput>
    create: XOR<WorkshopCreateWithoutUserInput, WorkshopUncheckedCreateWithoutUserInput>
  }

  export type WorkshopUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkshopWhereUniqueInput
    data: XOR<WorkshopUpdateWithoutUserInput, WorkshopUncheckedUpdateWithoutUserInput>
  }

  export type WorkshopUpdateManyWithWhereWithoutUserInput = {
    where: WorkshopScalarWhereInput
    data: XOR<WorkshopUpdateManyMutationInput, WorkshopUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkshopScalarWhereInput = {
    AND?: WorkshopScalarWhereInput | WorkshopScalarWhereInput[]
    OR?: WorkshopScalarWhereInput[]
    NOT?: WorkshopScalarWhereInput | WorkshopScalarWhereInput[]
    id?: StringFilter<"Workshop"> | string
    title?: StringFilter<"Workshop"> | string
    description?: StringFilter<"Workshop"> | string
    slug?: StringFilter<"Workshop"> | string
    statement?: StringFilter<"Workshop"> | string
    fileKey?: StringFilter<"Workshop"> | string
    statementsStartFileKey?: StringNullableFilter<"Workshop"> | string | null
    statementsStartFileUrl?: StringNullableFilter<"Workshop"> | string | null
    statementVideoKey?: StringNullableFilter<"Workshop"> | string | null
    price?: IntFilter<"Workshop"> | number
    currency?: StringFilter<"Workshop"> | string
    duration?: IntFilter<"Workshop"> | number
    status?: StringFilter<"Workshop"> | string
    level?: StringFilter<"Workshop"> | string
    stripePriceId?: StringNullableFilter<"Workshop"> | string | null
    solution?: StringNullableFilter<"Workshop"> | string | null
    solutionFileKey?: StringNullableFilter<"Workshop"> | string | null
    solutionFileUrl?: StringNullableFilter<"Workshop"> | string | null
    solutionVideoKey?: StringNullableFilter<"Workshop"> | string | null
    createdAt?: DateTimeFilter<"Workshop"> | Date | string
    updatedAt?: DateTimeFilter<"Workshop"> | Date | string
    userId?: StringFilter<"Workshop"> | string
    deletedAt?: DateTimeNullableFilter<"Workshop"> | Date | string | null
  }

  export type ResourceUpsertWithWhereUniqueWithoutUserInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutUserInput, ResourceUncheckedUpdateWithoutUserInput>
    create: XOR<ResourceCreateWithoutUserInput, ResourceUncheckedCreateWithoutUserInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutUserInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutUserInput, ResourceUncheckedUpdateWithoutUserInput>
  }

  export type ResourceUpdateManyWithWhereWithoutUserInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutUserInput>
  }

  export type ResourceScalarWhereInput = {
    AND?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    OR?: ResourceScalarWhereInput[]
    NOT?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    id?: StringFilter<"Resource"> | string
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    fileKey?: StringNullableFilter<"Resource"> | string | null
    url?: StringFilter<"Resource"> | string
    type?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    userId?: StringFilter<"Resource"> | string
  }

  export type QuizUpsertWithWhereUniqueWithoutUserInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutUserInput, QuizUncheckedUpdateWithoutUserInput>
    create: XOR<QuizCreateWithoutUserInput, QuizUncheckedCreateWithoutUserInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutUserInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutUserInput, QuizUncheckedUpdateWithoutUserInput>
  }

  export type QuizUpdateManyWithWhereWithoutUserInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutUserInput>
  }

  export type QuizScalarWhereInput = {
    AND?: QuizScalarWhereInput | QuizScalarWhereInput[]
    OR?: QuizScalarWhereInput[]
    NOT?: QuizScalarWhereInput | QuizScalarWhereInput[]
    id?: StringFilter<"Quiz"> | string
    title?: StringFilter<"Quiz"> | string
    slug?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    type?: StringNullableFilter<"Quiz"> | string | null
    chapterId?: StringNullableFilter<"Quiz"> | string | null
    courseId?: StringNullableFilter<"Quiz"> | string | null
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    userId?: StringNullableFilter<"Quiz"> | string | null
  }

  export type UserCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    workshops?: WorkshopCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    quiz?: QuizCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    workshops?: WorkshopUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    quiz?: QuizUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    quiz?: QuizUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    quiz?: QuizUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    workshops?: WorkshopCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    quiz?: QuizCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    workshops?: WorkshopUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    quiz?: QuizUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    quiz?: QuizUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    quiz?: QuizUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CategoryCreateWithoutDomainInput = {
    id?: string
    title: string
    slug: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    courses?: CourseCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutDomainInput = {
    id?: string
    title: string
    slug: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    courses?: CourseUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutDomainInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutDomainInput, CategoryUncheckedCreateWithoutDomainInput>
  }

  export type CategoryCreateManyDomainInputEnvelope = {
    data: CategoryCreateManyDomainInput | CategoryCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithWhereUniqueWithoutDomainInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutDomainInput, CategoryUncheckedUpdateWithoutDomainInput>
    create: XOR<CategoryCreateWithoutDomainInput, CategoryUncheckedCreateWithoutDomainInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutDomainInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutDomainInput, CategoryUncheckedUpdateWithoutDomainInput>
  }

  export type CategoryUpdateManyWithWhereWithoutDomainInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutDomainInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    title?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    desc?: StringFilter<"Category"> | string
    color?: StringNullableFilter<"Category"> | string | null
    iconName?: StringNullableFilter<"Category"> | string | null
    iconLib?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    domainId?: StringFilter<"Category"> | string
    deletedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
  }

  export type CourseCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCoursesInput
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    promotions?: PromotionCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    progress?: UserProgressCreateNestedManyWithoutCourseInput
    resources?: CourseResourceCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutCourseInput
    resources?: CourseResourceUncheckedCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCategoryInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCategoryInput, CourseUncheckedCreateWithoutCategoryInput>
  }

  export type CourseCreateManyCategoryInputEnvelope = {
    data: CourseCreateManyCategoryInput | CourseCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type DomainCreateWithoutCategoriesInput = {
    id?: string
    title: string
    slug: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DomainUncheckedCreateWithoutCategoriesInput = {
    id?: string
    title: string
    slug: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DomainCreateOrConnectWithoutCategoriesInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutCategoriesInput, DomainUncheckedCreateWithoutCategoriesInput>
  }

  export type CourseUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCategoryInput, CourseUncheckedUpdateWithoutCategoryInput>
    create: XOR<CourseCreateWithoutCategoryInput, CourseUncheckedCreateWithoutCategoryInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCategoryInput, CourseUncheckedUpdateWithoutCategoryInput>
  }

  export type CourseUpdateManyWithWhereWithoutCategoryInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCategoryInput>
  }

  export type DomainUpsertWithoutCategoriesInput = {
    update: XOR<DomainUpdateWithoutCategoriesInput, DomainUncheckedUpdateWithoutCategoriesInput>
    create: XOR<DomainCreateWithoutCategoriesInput, DomainUncheckedCreateWithoutCategoriesInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutCategoriesInput, DomainUncheckedUpdateWithoutCategoriesInput>
  }

  export type DomainUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DomainUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutLearningPathsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    workshops?: WorkshopCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    quiz?: QuizCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLearningPathsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    workshops?: WorkshopUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    quiz?: QuizUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLearningPathsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLearningPathsInput, UserUncheckedCreateWithoutLearningPathsInput>
  }

  export type LearningPathTagCreateWithoutLearningPathInput = {
    tag: TagCreateNestedOneWithoutLearningPathTagsInput
  }

  export type LearningPathTagUncheckedCreateWithoutLearningPathInput = {
    tagId: string
  }

  export type LearningPathTagCreateOrConnectWithoutLearningPathInput = {
    where: LearningPathTagWhereUniqueInput
    create: XOR<LearningPathTagCreateWithoutLearningPathInput, LearningPathTagUncheckedCreateWithoutLearningPathInput>
  }

  export type LearningPathTagCreateManyLearningPathInputEnvelope = {
    data: LearningPathTagCreateManyLearningPathInput | LearningPathTagCreateManyLearningPathInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathItemCreateWithoutLearningPathInput = {
    id?: string
    type: string
    position: number
    course?: CourseCreateNestedOneWithoutLearningPathItemsInput
    workshop?: WorkshopCreateNestedOneWithoutLearningPathItemsInput
    resource?: ResourceCreateNestedOneWithoutLearningPathItemsInput
  }

  export type LearningPathItemUncheckedCreateWithoutLearningPathInput = {
    id?: string
    type: string
    position: number
    courseId?: string | null
    workshopId?: string | null
    resourceId?: string | null
  }

  export type LearningPathItemCreateOrConnectWithoutLearningPathInput = {
    where: LearningPathItemWhereUniqueInput
    create: XOR<LearningPathItemCreateWithoutLearningPathInput, LearningPathItemUncheckedCreateWithoutLearningPathInput>
  }

  export type LearningPathItemCreateManyLearningPathInputEnvelope = {
    data: LearningPathItemCreateManyLearningPathInput | LearningPathItemCreateManyLearningPathInput[]
    skipDuplicates?: boolean
  }

  export type UserProgressCreateWithoutPathInput = {
    id?: string
    userId: string
    type: string
    completed?: boolean
    updatedAt?: Date | string
    progressPercentage?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    timeSpent?: number | null
    course?: CourseCreateNestedOneWithoutProgressInput
    workshop?: WorkshopCreateNestedOneWithoutProgressInput
  }

  export type UserProgressUncheckedCreateWithoutPathInput = {
    id?: string
    userId: string
    type: string
    completed?: boolean
    updatedAt?: Date | string
    progressPercentage?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type UserProgressCreateOrConnectWithoutPathInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutPathInput, UserProgressUncheckedCreateWithoutPathInput>
  }

  export type UserProgressCreateManyPathInputEnvelope = {
    data: UserProgressCreateManyPathInput | UserProgressCreateManyPathInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathResourceCreateWithoutLearningPathInput = {
    resource: ResourceCreateNestedOneWithoutLearningPathResourcesInput
  }

  export type LearningPathResourceUncheckedCreateWithoutLearningPathInput = {
    resourceId: string
  }

  export type LearningPathResourceCreateOrConnectWithoutLearningPathInput = {
    where: LearningPathResourceWhereUniqueInput
    create: XOR<LearningPathResourceCreateWithoutLearningPathInput, LearningPathResourceUncheckedCreateWithoutLearningPathInput>
  }

  export type LearningPathResourceCreateManyLearningPathInputEnvelope = {
    data: LearningPathResourceCreateManyLearningPathInput | LearningPathResourceCreateManyLearningPathInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathObjectiveCreateWithoutLearningPathInput = {
    objective: ObjectiveCreateNestedOneWithoutLearningPathsInput
  }

  export type LearningPathObjectiveUncheckedCreateWithoutLearningPathInput = {
    objectiveId: string
  }

  export type LearningPathObjectiveCreateOrConnectWithoutLearningPathInput = {
    where: LearningPathObjectiveWhereUniqueInput
    create: XOR<LearningPathObjectiveCreateWithoutLearningPathInput, LearningPathObjectiveUncheckedCreateWithoutLearningPathInput>
  }

  export type LearningPathObjectiveCreateManyLearningPathInputEnvelope = {
    data: LearningPathObjectiveCreateManyLearningPathInput | LearningPathObjectiveCreateManyLearningPathInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathPrerequisiteCreateWithoutLearningPathInput = {
    prerequisite: PrerequisiteCreateNestedOneWithoutLearningPathsInput
  }

  export type LearningPathPrerequisiteUncheckedCreateWithoutLearningPathInput = {
    prerequisiteId: string
  }

  export type LearningPathPrerequisiteCreateOrConnectWithoutLearningPathInput = {
    where: LearningPathPrerequisiteWhereUniqueInput
    create: XOR<LearningPathPrerequisiteCreateWithoutLearningPathInput, LearningPathPrerequisiteUncheckedCreateWithoutLearningPathInput>
  }

  export type LearningPathPrerequisiteCreateManyLearningPathInputEnvelope = {
    data: LearningPathPrerequisiteCreateManyLearningPathInput | LearningPathPrerequisiteCreateManyLearningPathInput[]
    skipDuplicates?: boolean
  }

  export type PromoCodeCreateWithoutApplicableLearningPathsInput = {
    id?: string
    code: string
    description?: string | null
    discount: number
    type?: string
    usageLimit?: number | null
    usedCount?: number
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    applicableCourses?: CourseCreateNestedManyWithoutPromoCodesInput
    applicableWorkshops?: WorkshopCreateNestedManyWithoutPromoCodesInput
  }

  export type PromoCodeUncheckedCreateWithoutApplicableLearningPathsInput = {
    id?: string
    code: string
    description?: string | null
    discount: number
    type?: string
    usageLimit?: number | null
    usedCount?: number
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    applicableCourses?: CourseUncheckedCreateNestedManyWithoutPromoCodesInput
    applicableWorkshops?: WorkshopUncheckedCreateNestedManyWithoutPromoCodesInput
  }

  export type PromoCodeCreateOrConnectWithoutApplicableLearningPathsInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutApplicableLearningPathsInput, PromoCodeUncheckedCreateWithoutApplicableLearningPathsInput>
  }

  export type PromotionCreateWithoutLearningPathInput = {
    id?: string
    title: string
    description?: string | null
    discount: number
    type?: string
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    itemType: string
    course?: CourseCreateNestedOneWithoutPromotionsInput
    workshop?: WorkshopCreateNestedOneWithoutPromotionsInput
  }

  export type PromotionUncheckedCreateWithoutLearningPathInput = {
    id?: string
    title: string
    description?: string | null
    discount: number
    type?: string
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    itemType: string
    courseId?: string | null
    workshopId?: string | null
  }

  export type PromotionCreateOrConnectWithoutLearningPathInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutLearningPathInput, PromotionUncheckedCreateWithoutLearningPathInput>
  }

  export type PromotionCreateManyLearningPathInputEnvelope = {
    data: PromotionCreateManyLearningPathInput | PromotionCreateManyLearningPathInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutLearningPathInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    course?: CourseCreateNestedOneWithoutEnrollmentsInput
    workshop?: WorkshopCreateNestedOneWithoutEnrollmentsInput
    user: UserCreateNestedOneWithoutEnrollmentInput
    payment?: PaymentCreateNestedOneWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutLearningPathInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: string | null
    workshopId?: string | null
    userId: string
    paymentId?: string | null
    deletedAt?: Date | string | null
  }

  export type EnrollmentCreateOrConnectWithoutLearningPathInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutLearningPathInput, EnrollmentUncheckedCreateWithoutLearningPathInput>
  }

  export type EnrollmentCreateManyLearningPathInputEnvelope = {
    data: EnrollmentCreateManyLearningPathInput | EnrollmentCreateManyLearningPathInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutLearningPathInput = {
    id?: string
    stripeId: string
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPaymentsInput
    course?: CourseCreateNestedOneWithoutPaymentsInput
    workshop?: WorkshopCreateNestedOneWithoutPaymentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutLearningPathInput = {
    id?: string
    stripeId: string
    userId: string
    courseId?: string | null
    workshopId?: string | null
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    enrollment?: EnrollmentUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutLearningPathInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutLearningPathInput, PaymentUncheckedCreateWithoutLearningPathInput>
  }

  export type PaymentCreateManyLearningPathInputEnvelope = {
    data: PaymentCreateManyLearningPathInput | PaymentCreateManyLearningPathInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLearningPathsInput = {
    update: XOR<UserUpdateWithoutLearningPathsInput, UserUncheckedUpdateWithoutLearningPathsInput>
    create: XOR<UserCreateWithoutLearningPathsInput, UserUncheckedCreateWithoutLearningPathsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLearningPathsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLearningPathsInput, UserUncheckedUpdateWithoutLearningPathsInput>
  }

  export type UserUpdateWithoutLearningPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    quiz?: QuizUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLearningPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    quiz?: QuizUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LearningPathTagUpsertWithWhereUniqueWithoutLearningPathInput = {
    where: LearningPathTagWhereUniqueInput
    update: XOR<LearningPathTagUpdateWithoutLearningPathInput, LearningPathTagUncheckedUpdateWithoutLearningPathInput>
    create: XOR<LearningPathTagCreateWithoutLearningPathInput, LearningPathTagUncheckedCreateWithoutLearningPathInput>
  }

  export type LearningPathTagUpdateWithWhereUniqueWithoutLearningPathInput = {
    where: LearningPathTagWhereUniqueInput
    data: XOR<LearningPathTagUpdateWithoutLearningPathInput, LearningPathTagUncheckedUpdateWithoutLearningPathInput>
  }

  export type LearningPathTagUpdateManyWithWhereWithoutLearningPathInput = {
    where: LearningPathTagScalarWhereInput
    data: XOR<LearningPathTagUpdateManyMutationInput, LearningPathTagUncheckedUpdateManyWithoutLearningPathInput>
  }

  export type LearningPathTagScalarWhereInput = {
    AND?: LearningPathTagScalarWhereInput | LearningPathTagScalarWhereInput[]
    OR?: LearningPathTagScalarWhereInput[]
    NOT?: LearningPathTagScalarWhereInput | LearningPathTagScalarWhereInput[]
    learningPathId?: StringFilter<"LearningPathTag"> | string
    tagId?: StringFilter<"LearningPathTag"> | string
  }

  export type LearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput = {
    where: LearningPathItemWhereUniqueInput
    update: XOR<LearningPathItemUpdateWithoutLearningPathInput, LearningPathItemUncheckedUpdateWithoutLearningPathInput>
    create: XOR<LearningPathItemCreateWithoutLearningPathInput, LearningPathItemUncheckedCreateWithoutLearningPathInput>
  }

  export type LearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput = {
    where: LearningPathItemWhereUniqueInput
    data: XOR<LearningPathItemUpdateWithoutLearningPathInput, LearningPathItemUncheckedUpdateWithoutLearningPathInput>
  }

  export type LearningPathItemUpdateManyWithWhereWithoutLearningPathInput = {
    where: LearningPathItemScalarWhereInput
    data: XOR<LearningPathItemUpdateManyMutationInput, LearningPathItemUncheckedUpdateManyWithoutLearningPathInput>
  }

  export type LearningPathItemScalarWhereInput = {
    AND?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
    OR?: LearningPathItemScalarWhereInput[]
    NOT?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
    id?: StringFilter<"LearningPathItem"> | string
    type?: StringFilter<"LearningPathItem"> | string
    position?: IntFilter<"LearningPathItem"> | number
    learningPathId?: StringFilter<"LearningPathItem"> | string
    courseId?: StringNullableFilter<"LearningPathItem"> | string | null
    workshopId?: StringNullableFilter<"LearningPathItem"> | string | null
    resourceId?: StringNullableFilter<"LearningPathItem"> | string | null
  }

  export type UserProgressUpsertWithWhereUniqueWithoutPathInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutPathInput, UserProgressUncheckedUpdateWithoutPathInput>
    create: XOR<UserProgressCreateWithoutPathInput, UserProgressUncheckedCreateWithoutPathInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutPathInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutPathInput, UserProgressUncheckedUpdateWithoutPathInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutPathInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutPathInput>
  }

  export type UserProgressScalarWhereInput = {
    AND?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    OR?: UserProgressScalarWhereInput[]
    NOT?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    type?: StringFilter<"UserProgress"> | string
    itemId?: StringFilter<"UserProgress"> | string
    completed?: BoolFilter<"UserProgress"> | boolean
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
    progressPercentage?: FloatNullableFilter<"UserProgress"> | number | null
    startedAt?: DateTimeNullableFilter<"UserProgress"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"UserProgress"> | Date | string | null
    timeSpent?: IntNullableFilter<"UserProgress"> | number | null
  }

  export type LearningPathResourceUpsertWithWhereUniqueWithoutLearningPathInput = {
    where: LearningPathResourceWhereUniqueInput
    update: XOR<LearningPathResourceUpdateWithoutLearningPathInput, LearningPathResourceUncheckedUpdateWithoutLearningPathInput>
    create: XOR<LearningPathResourceCreateWithoutLearningPathInput, LearningPathResourceUncheckedCreateWithoutLearningPathInput>
  }

  export type LearningPathResourceUpdateWithWhereUniqueWithoutLearningPathInput = {
    where: LearningPathResourceWhereUniqueInput
    data: XOR<LearningPathResourceUpdateWithoutLearningPathInput, LearningPathResourceUncheckedUpdateWithoutLearningPathInput>
  }

  export type LearningPathResourceUpdateManyWithWhereWithoutLearningPathInput = {
    where: LearningPathResourceScalarWhereInput
    data: XOR<LearningPathResourceUpdateManyMutationInput, LearningPathResourceUncheckedUpdateManyWithoutLearningPathInput>
  }

  export type LearningPathResourceScalarWhereInput = {
    AND?: LearningPathResourceScalarWhereInput | LearningPathResourceScalarWhereInput[]
    OR?: LearningPathResourceScalarWhereInput[]
    NOT?: LearningPathResourceScalarWhereInput | LearningPathResourceScalarWhereInput[]
    learningPathId?: StringFilter<"LearningPathResource"> | string
    resourceId?: StringFilter<"LearningPathResource"> | string
  }

  export type LearningPathObjectiveUpsertWithWhereUniqueWithoutLearningPathInput = {
    where: LearningPathObjectiveWhereUniqueInput
    update: XOR<LearningPathObjectiveUpdateWithoutLearningPathInput, LearningPathObjectiveUncheckedUpdateWithoutLearningPathInput>
    create: XOR<LearningPathObjectiveCreateWithoutLearningPathInput, LearningPathObjectiveUncheckedCreateWithoutLearningPathInput>
  }

  export type LearningPathObjectiveUpdateWithWhereUniqueWithoutLearningPathInput = {
    where: LearningPathObjectiveWhereUniqueInput
    data: XOR<LearningPathObjectiveUpdateWithoutLearningPathInput, LearningPathObjectiveUncheckedUpdateWithoutLearningPathInput>
  }

  export type LearningPathObjectiveUpdateManyWithWhereWithoutLearningPathInput = {
    where: LearningPathObjectiveScalarWhereInput
    data: XOR<LearningPathObjectiveUpdateManyMutationInput, LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathInput>
  }

  export type LearningPathObjectiveScalarWhereInput = {
    AND?: LearningPathObjectiveScalarWhereInput | LearningPathObjectiveScalarWhereInput[]
    OR?: LearningPathObjectiveScalarWhereInput[]
    NOT?: LearningPathObjectiveScalarWhereInput | LearningPathObjectiveScalarWhereInput[]
    learningPathId?: StringFilter<"LearningPathObjective"> | string
    objectiveId?: StringFilter<"LearningPathObjective"> | string
  }

  export type LearningPathPrerequisiteUpsertWithWhereUniqueWithoutLearningPathInput = {
    where: LearningPathPrerequisiteWhereUniqueInput
    update: XOR<LearningPathPrerequisiteUpdateWithoutLearningPathInput, LearningPathPrerequisiteUncheckedUpdateWithoutLearningPathInput>
    create: XOR<LearningPathPrerequisiteCreateWithoutLearningPathInput, LearningPathPrerequisiteUncheckedCreateWithoutLearningPathInput>
  }

  export type LearningPathPrerequisiteUpdateWithWhereUniqueWithoutLearningPathInput = {
    where: LearningPathPrerequisiteWhereUniqueInput
    data: XOR<LearningPathPrerequisiteUpdateWithoutLearningPathInput, LearningPathPrerequisiteUncheckedUpdateWithoutLearningPathInput>
  }

  export type LearningPathPrerequisiteUpdateManyWithWhereWithoutLearningPathInput = {
    where: LearningPathPrerequisiteScalarWhereInput
    data: XOR<LearningPathPrerequisiteUpdateManyMutationInput, LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathInput>
  }

  export type LearningPathPrerequisiteScalarWhereInput = {
    AND?: LearningPathPrerequisiteScalarWhereInput | LearningPathPrerequisiteScalarWhereInput[]
    OR?: LearningPathPrerequisiteScalarWhereInput[]
    NOT?: LearningPathPrerequisiteScalarWhereInput | LearningPathPrerequisiteScalarWhereInput[]
    learningPathId?: StringFilter<"LearningPathPrerequisite"> | string
    prerequisiteId?: StringFilter<"LearningPathPrerequisite"> | string
  }

  export type PromoCodeUpsertWithWhereUniqueWithoutApplicableLearningPathsInput = {
    where: PromoCodeWhereUniqueInput
    update: XOR<PromoCodeUpdateWithoutApplicableLearningPathsInput, PromoCodeUncheckedUpdateWithoutApplicableLearningPathsInput>
    create: XOR<PromoCodeCreateWithoutApplicableLearningPathsInput, PromoCodeUncheckedCreateWithoutApplicableLearningPathsInput>
  }

  export type PromoCodeUpdateWithWhereUniqueWithoutApplicableLearningPathsInput = {
    where: PromoCodeWhereUniqueInput
    data: XOR<PromoCodeUpdateWithoutApplicableLearningPathsInput, PromoCodeUncheckedUpdateWithoutApplicableLearningPathsInput>
  }

  export type PromoCodeUpdateManyWithWhereWithoutApplicableLearningPathsInput = {
    where: PromoCodeScalarWhereInput
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsInput>
  }

  export type PromoCodeScalarWhereInput = {
    AND?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
    OR?: PromoCodeScalarWhereInput[]
    NOT?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
    id?: StringFilter<"PromoCode"> | string
    code?: StringFilter<"PromoCode"> | string
    description?: StringNullableFilter<"PromoCode"> | string | null
    discount?: IntFilter<"PromoCode"> | number
    type?: StringFilter<"PromoCode"> | string
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    usedCount?: IntFilter<"PromoCode"> | number
    startsAt?: DateTimeFilter<"PromoCode"> | Date | string
    endsAt?: DateTimeFilter<"PromoCode"> | Date | string
    active?: BoolFilter<"PromoCode"> | boolean
  }

  export type PromotionUpsertWithWhereUniqueWithoutLearningPathInput = {
    where: PromotionWhereUniqueInput
    update: XOR<PromotionUpdateWithoutLearningPathInput, PromotionUncheckedUpdateWithoutLearningPathInput>
    create: XOR<PromotionCreateWithoutLearningPathInput, PromotionUncheckedCreateWithoutLearningPathInput>
  }

  export type PromotionUpdateWithWhereUniqueWithoutLearningPathInput = {
    where: PromotionWhereUniqueInput
    data: XOR<PromotionUpdateWithoutLearningPathInput, PromotionUncheckedUpdateWithoutLearningPathInput>
  }

  export type PromotionUpdateManyWithWhereWithoutLearningPathInput = {
    where: PromotionScalarWhereInput
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyWithoutLearningPathInput>
  }

  export type PromotionScalarWhereInput = {
    AND?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    OR?: PromotionScalarWhereInput[]
    NOT?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    id?: StringFilter<"Promotion"> | string
    title?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    discount?: IntFilter<"Promotion"> | number
    type?: StringFilter<"Promotion"> | string
    startsAt?: DateTimeFilter<"Promotion"> | Date | string
    endsAt?: DateTimeFilter<"Promotion"> | Date | string
    active?: BoolFilter<"Promotion"> | boolean
    itemType?: StringFilter<"Promotion"> | string
    courseId?: StringNullableFilter<"Promotion"> | string | null
    workshopId?: StringNullableFilter<"Promotion"> | string | null
    learningPathId?: StringNullableFilter<"Promotion"> | string | null
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutLearningPathInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutLearningPathInput, EnrollmentUncheckedUpdateWithoutLearningPathInput>
    create: XOR<EnrollmentCreateWithoutLearningPathInput, EnrollmentUncheckedCreateWithoutLearningPathInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutLearningPathInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutLearningPathInput, EnrollmentUncheckedUpdateWithoutLearningPathInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutLearningPathInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutLearningPathInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutLearningPathInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutLearningPathInput, PaymentUncheckedUpdateWithoutLearningPathInput>
    create: XOR<PaymentCreateWithoutLearningPathInput, PaymentUncheckedCreateWithoutLearningPathInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutLearningPathInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutLearningPathInput, PaymentUncheckedUpdateWithoutLearningPathInput>
  }

  export type PaymentUpdateManyWithWhereWithoutLearningPathInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutLearningPathInput>
  }

  export type LearningPathCreateWithoutContentsInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLearningPathsInput
    tags?: LearningPathTagCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearningPathInput
    payments?: PaymentCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutContentsInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: LearningPathTagUncheckedCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceUncheckedCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearningPathInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutContentsInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutContentsInput, LearningPathUncheckedCreateWithoutContentsInput>
  }

  export type CourseCreateWithoutLearningPathItemsInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCoursesInput
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    category: CategoryCreateNestedOneWithoutCoursesInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    promotions?: PromotionCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    progress?: UserProgressCreateNestedManyWithoutCourseInput
    resources?: CourseResourceCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutLearningPathItemsInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    categoryId: string
    deletedAt?: Date | string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutCourseInput
    resources?: CourseResourceUncheckedCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutLearningPathItemsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutLearningPathItemsInput, CourseUncheckedCreateWithoutLearningPathItemsInput>
  }

  export type WorkshopCreateWithoutLearningPathItemsInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutWorkshopsInput
    tags?: WorkshopTagCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentCreateNestedManyWithoutWorkshopInput
    payments?: PaymentCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutLearningPathItemsInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: WorkshopTagUncheckedCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceUncheckedCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveUncheckedCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutWorkshopInput
    payments?: PaymentUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutLearningPathItemsInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutLearningPathItemsInput, WorkshopUncheckedCreateWithoutLearningPathItemsInput>
  }

  export type ResourceCreateWithoutLearningPathItemsInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    courseResources?: CourseResourceCreateNestedManyWithoutResourceInput
    lessonResources?: LessonResourceCreateNestedManyWithoutResourceInput
    workshopResources?: WorkshopResourceCreateNestedManyWithoutResourceInput
    learningPathResources?: LearningPathResourceCreateNestedManyWithoutResourceInput
    user?: UserCreateNestedOneWithoutResourcesInput
  }

  export type ResourceUncheckedCreateWithoutLearningPathItemsInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    userId: string
    courseResources?: CourseResourceUncheckedCreateNestedManyWithoutResourceInput
    lessonResources?: LessonResourceUncheckedCreateNestedManyWithoutResourceInput
    workshopResources?: WorkshopResourceUncheckedCreateNestedManyWithoutResourceInput
    learningPathResources?: LearningPathResourceUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutLearningPathItemsInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutLearningPathItemsInput, ResourceUncheckedCreateWithoutLearningPathItemsInput>
  }

  export type LearningPathUpsertWithoutContentsInput = {
    update: XOR<LearningPathUpdateWithoutContentsInput, LearningPathUncheckedUpdateWithoutContentsInput>
    create: XOR<LearningPathCreateWithoutContentsInput, LearningPathUncheckedCreateWithoutContentsInput>
    where?: LearningPathWhereInput
  }

  export type LearningPathUpdateToOneWithWhereWithoutContentsInput = {
    where?: LearningPathWhereInput
    data: XOR<LearningPathUpdateWithoutContentsInput, LearningPathUncheckedUpdateWithoutContentsInput>
  }

  export type LearningPathUpdateWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLearningPathsNestedInput
    tags?: LearningPathTagUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: LearningPathTagUncheckedUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUncheckedUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type CourseUpsertWithoutLearningPathItemsInput = {
    update: XOR<CourseUpdateWithoutLearningPathItemsInput, CourseUncheckedUpdateWithoutLearningPathItemsInput>
    create: XOR<CourseCreateWithoutLearningPathItemsInput, CourseUncheckedCreateWithoutLearningPathItemsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutLearningPathItemsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutLearningPathItemsInput, CourseUncheckedUpdateWithoutLearningPathItemsInput>
  }

  export type CourseUpdateWithoutLearningPathItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCoursesNestedInput
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutLearningPathItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUncheckedUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type WorkshopUpsertWithoutLearningPathItemsInput = {
    update: XOR<WorkshopUpdateWithoutLearningPathItemsInput, WorkshopUncheckedUpdateWithoutLearningPathItemsInput>
    create: XOR<WorkshopCreateWithoutLearningPathItemsInput, WorkshopUncheckedCreateWithoutLearningPathItemsInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutLearningPathItemsInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutLearningPathItemsInput, WorkshopUncheckedUpdateWithoutLearningPathItemsInput>
  }

  export type WorkshopUpdateWithoutLearningPathItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutWorkshopsNestedInput
    tags?: WorkshopTagUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutLearningPathItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: WorkshopTagUncheckedUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUncheckedUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type ResourceUpsertWithoutLearningPathItemsInput = {
    update: XOR<ResourceUpdateWithoutLearningPathItemsInput, ResourceUncheckedUpdateWithoutLearningPathItemsInput>
    create: XOR<ResourceCreateWithoutLearningPathItemsInput, ResourceUncheckedCreateWithoutLearningPathItemsInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutLearningPathItemsInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutLearningPathItemsInput, ResourceUncheckedUpdateWithoutLearningPathItemsInput>
  }

  export type ResourceUpdateWithoutLearningPathItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseResources?: CourseResourceUpdateManyWithoutResourceNestedInput
    lessonResources?: LessonResourceUpdateManyWithoutResourceNestedInput
    workshopResources?: WorkshopResourceUpdateManyWithoutResourceNestedInput
    learningPathResources?: LearningPathResourceUpdateManyWithoutResourceNestedInput
    user?: UserUpdateOneWithoutResourcesNestedInput
  }

  export type ResourceUncheckedUpdateWithoutLearningPathItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    courseResources?: CourseResourceUncheckedUpdateManyWithoutResourceNestedInput
    lessonResources?: LessonResourceUncheckedUpdateManyWithoutResourceNestedInput
    workshopResources?: WorkshopResourceUncheckedUpdateManyWithoutResourceNestedInput
    learningPathResources?: LearningPathResourceUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type UserCreateWithoutCoursesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    workshops?: WorkshopCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    quiz?: QuizCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoursesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    workshops?: WorkshopUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    quiz?: QuizUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
  }

  export type ChapterCreateWithoutCourseInput = {
    id?: string
    title: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: LessonCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: LessonUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutCourseInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutCourseInput, ChapterUncheckedCreateWithoutCourseInput>
  }

  export type ChapterCreateManyCourseInputEnvelope = {
    data: ChapterCreateManyCourseInput | ChapterCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutCourseInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    learningPath?: LearningPathCreateNestedOneWithoutEnrollmentsInput
    workshop?: WorkshopCreateNestedOneWithoutEnrollmentsInput
    user: UserCreateNestedOneWithoutEnrollmentInput
    payment?: PaymentCreateNestedOneWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutCourseInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    learningPathId?: string | null
    workshopId?: string | null
    userId: string
    paymentId?: string | null
    deletedAt?: Date | string | null
  }

  export type EnrollmentCreateOrConnectWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentCreateManyCourseInputEnvelope = {
    data: EnrollmentCreateManyCourseInput | EnrollmentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutCoursesInput = {
    id?: string
    title: string
    slug: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    domain: DomainCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutCoursesInput = {
    id?: string
    title: string
    slug: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domainId: string
    deletedAt?: Date | string | null
  }

  export type CategoryCreateOrConnectWithoutCoursesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutCoursesInput, CategoryUncheckedCreateWithoutCoursesInput>
  }

  export type PaymentCreateWithoutCourseInput = {
    id?: string
    stripeId: string
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPaymentsInput
    learningPath?: LearningPathCreateNestedOneWithoutPaymentsInput
    workshop?: WorkshopCreateNestedOneWithoutPaymentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutCourseInput = {
    id?: string
    stripeId: string
    userId: string
    learningPathId?: string | null
    workshopId?: string | null
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    enrollment?: EnrollmentUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutCourseInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCourseInput, PaymentUncheckedCreateWithoutCourseInput>
  }

  export type PaymentCreateManyCourseInputEnvelope = {
    data: PaymentCreateManyCourseInput | PaymentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type PromotionCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    discount: number
    type?: string
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    itemType: string
    workshop?: WorkshopCreateNestedOneWithoutPromotionsInput
    learningPath?: LearningPathCreateNestedOneWithoutPromotionsInput
  }

  export type PromotionUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    discount: number
    type?: string
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    itemType: string
    workshopId?: string | null
    learningPathId?: string | null
  }

  export type PromotionCreateOrConnectWithoutCourseInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutCourseInput, PromotionUncheckedCreateWithoutCourseInput>
  }

  export type PromotionCreateManyCourseInputEnvelope = {
    data: PromotionCreateManyCourseInput | PromotionCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type PromoCodeCreateWithoutApplicableCoursesInput = {
    id?: string
    code: string
    description?: string | null
    discount: number
    type?: string
    usageLimit?: number | null
    usedCount?: number
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    applicableWorkshops?: WorkshopCreateNestedManyWithoutPromoCodesInput
    applicableLearningPaths?: LearningPathCreateNestedManyWithoutPromoCodesInput
  }

  export type PromoCodeUncheckedCreateWithoutApplicableCoursesInput = {
    id?: string
    code: string
    description?: string | null
    discount: number
    type?: string
    usageLimit?: number | null
    usedCount?: number
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    applicableWorkshops?: WorkshopUncheckedCreateNestedManyWithoutPromoCodesInput
    applicableLearningPaths?: LearningPathUncheckedCreateNestedManyWithoutPromoCodesInput
  }

  export type PromoCodeCreateOrConnectWithoutApplicableCoursesInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutApplicableCoursesInput, PromoCodeUncheckedCreateWithoutApplicableCoursesInput>
  }

  export type CourseTagCreateWithoutCourseInput = {
    tag: TagCreateNestedOneWithoutCourseTagsInput
  }

  export type CourseTagUncheckedCreateWithoutCourseInput = {
    tagId: string
  }

  export type CourseTagCreateOrConnectWithoutCourseInput = {
    where: CourseTagWhereUniqueInput
    create: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput>
  }

  export type CourseTagCreateManyCourseInputEnvelope = {
    data: CourseTagCreateManyCourseInput | CourseTagCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserProgressCreateWithoutCourseInput = {
    id?: string
    userId: string
    type: string
    completed?: boolean
    updatedAt?: Date | string
    progressPercentage?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    timeSpent?: number | null
    workshop?: WorkshopCreateNestedOneWithoutProgressInput
    path?: LearningPathCreateNestedOneWithoutProgressInput
  }

  export type UserProgressUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    type: string
    completed?: boolean
    updatedAt?: Date | string
    progressPercentage?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type UserProgressCreateOrConnectWithoutCourseInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutCourseInput, UserProgressUncheckedCreateWithoutCourseInput>
  }

  export type UserProgressCreateManyCourseInputEnvelope = {
    data: UserProgressCreateManyCourseInput | UserProgressCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseResourceCreateWithoutCourseInput = {
    resource: ResourceCreateNestedOneWithoutCourseResourcesInput
  }

  export type CourseResourceUncheckedCreateWithoutCourseInput = {
    resourceId: string
  }

  export type CourseResourceCreateOrConnectWithoutCourseInput = {
    where: CourseResourceWhereUniqueInput
    create: XOR<CourseResourceCreateWithoutCourseInput, CourseResourceUncheckedCreateWithoutCourseInput>
  }

  export type CourseResourceCreateManyCourseInputEnvelope = {
    data: CourseResourceCreateManyCourseInput | CourseResourceCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathItemCreateWithoutCourseInput = {
    id?: string
    type: string
    position: number
    learningPath: LearningPathCreateNestedOneWithoutContentsInput
    workshop?: WorkshopCreateNestedOneWithoutLearningPathItemsInput
    resource?: ResourceCreateNestedOneWithoutLearningPathItemsInput
  }

  export type LearningPathItemUncheckedCreateWithoutCourseInput = {
    id?: string
    type: string
    position: number
    learningPathId: string
    workshopId?: string | null
    resourceId?: string | null
  }

  export type LearningPathItemCreateOrConnectWithoutCourseInput = {
    where: LearningPathItemWhereUniqueInput
    create: XOR<LearningPathItemCreateWithoutCourseInput, LearningPathItemUncheckedCreateWithoutCourseInput>
  }

  export type LearningPathItemCreateManyCourseInputEnvelope = {
    data: LearningPathItemCreateManyCourseInput | LearningPathItemCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseObjectiveCreateWithoutCourseInput = {
    objective: ObjectiveCreateNestedOneWithoutCoursesInput
  }

  export type CourseObjectiveUncheckedCreateWithoutCourseInput = {
    objectiveId: string
  }

  export type CourseObjectiveCreateOrConnectWithoutCourseInput = {
    where: CourseObjectiveWhereUniqueInput
    create: XOR<CourseObjectiveCreateWithoutCourseInput, CourseObjectiveUncheckedCreateWithoutCourseInput>
  }

  export type CourseObjectiveCreateManyCourseInputEnvelope = {
    data: CourseObjectiveCreateManyCourseInput | CourseObjectiveCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CoursePrerequisiteCreateWithoutCourseInput = {
    prerequisite: PrerequisiteCreateNestedOneWithoutCoursesInput
  }

  export type CoursePrerequisiteUncheckedCreateWithoutCourseInput = {
    prerequisiteId: string
  }

  export type CoursePrerequisiteCreateOrConnectWithoutCourseInput = {
    where: CoursePrerequisiteWhereUniqueInput
    create: XOR<CoursePrerequisiteCreateWithoutCourseInput, CoursePrerequisiteUncheckedCreateWithoutCourseInput>
  }

  export type CoursePrerequisiteCreateManyCourseInputEnvelope = {
    data: CoursePrerequisiteCreateManyCourseInput | CoursePrerequisiteCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCoursesInput = {
    update: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type UserUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    quiz?: QuizUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    quiz?: QuizUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChapterUpsertWithWhereUniqueWithoutCourseInput = {
    where: ChapterWhereUniqueInput
    update: XOR<ChapterUpdateWithoutCourseInput, ChapterUncheckedUpdateWithoutCourseInput>
    create: XOR<ChapterCreateWithoutCourseInput, ChapterUncheckedCreateWithoutCourseInput>
  }

  export type ChapterUpdateWithWhereUniqueWithoutCourseInput = {
    where: ChapterWhereUniqueInput
    data: XOR<ChapterUpdateWithoutCourseInput, ChapterUncheckedUpdateWithoutCourseInput>
  }

  export type ChapterUpdateManyWithWhereWithoutCourseInput = {
    where: ChapterScalarWhereInput
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyWithoutCourseInput>
  }

  export type ChapterScalarWhereInput = {
    AND?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    OR?: ChapterScalarWhereInput[]
    NOT?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    id?: StringFilter<"Chapter"> | string
    title?: StringFilter<"Chapter"> | string
    position?: IntFilter<"Chapter"> | number
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeFilter<"Chapter"> | Date | string
    courseId?: StringFilter<"Chapter"> | string
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutCourseInput>
  }

  export type CategoryUpsertWithoutCoursesInput = {
    update: XOR<CategoryUpdateWithoutCoursesInput, CategoryUncheckedUpdateWithoutCoursesInput>
    create: XOR<CategoryCreateWithoutCoursesInput, CategoryUncheckedCreateWithoutCoursesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutCoursesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutCoursesInput, CategoryUncheckedUpdateWithoutCoursesInput>
  }

  export type CategoryUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domain?: DomainUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutCourseInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCourseInput, PaymentUncheckedUpdateWithoutCourseInput>
    create: XOR<PaymentCreateWithoutCourseInput, PaymentUncheckedCreateWithoutCourseInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCourseInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCourseInput, PaymentUncheckedUpdateWithoutCourseInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCourseInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCourseInput>
  }

  export type PromotionUpsertWithWhereUniqueWithoutCourseInput = {
    where: PromotionWhereUniqueInput
    update: XOR<PromotionUpdateWithoutCourseInput, PromotionUncheckedUpdateWithoutCourseInput>
    create: XOR<PromotionCreateWithoutCourseInput, PromotionUncheckedCreateWithoutCourseInput>
  }

  export type PromotionUpdateWithWhereUniqueWithoutCourseInput = {
    where: PromotionWhereUniqueInput
    data: XOR<PromotionUpdateWithoutCourseInput, PromotionUncheckedUpdateWithoutCourseInput>
  }

  export type PromotionUpdateManyWithWhereWithoutCourseInput = {
    where: PromotionScalarWhereInput
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyWithoutCourseInput>
  }

  export type PromoCodeUpsertWithWhereUniqueWithoutApplicableCoursesInput = {
    where: PromoCodeWhereUniqueInput
    update: XOR<PromoCodeUpdateWithoutApplicableCoursesInput, PromoCodeUncheckedUpdateWithoutApplicableCoursesInput>
    create: XOR<PromoCodeCreateWithoutApplicableCoursesInput, PromoCodeUncheckedCreateWithoutApplicableCoursesInput>
  }

  export type PromoCodeUpdateWithWhereUniqueWithoutApplicableCoursesInput = {
    where: PromoCodeWhereUniqueInput
    data: XOR<PromoCodeUpdateWithoutApplicableCoursesInput, PromoCodeUncheckedUpdateWithoutApplicableCoursesInput>
  }

  export type PromoCodeUpdateManyWithWhereWithoutApplicableCoursesInput = {
    where: PromoCodeScalarWhereInput
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyWithoutApplicableCoursesInput>
  }

  export type CourseTagUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseTagWhereUniqueInput
    update: XOR<CourseTagUpdateWithoutCourseInput, CourseTagUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput>
  }

  export type CourseTagUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseTagWhereUniqueInput
    data: XOR<CourseTagUpdateWithoutCourseInput, CourseTagUncheckedUpdateWithoutCourseInput>
  }

  export type CourseTagUpdateManyWithWhereWithoutCourseInput = {
    where: CourseTagScalarWhereInput
    data: XOR<CourseTagUpdateManyMutationInput, CourseTagUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseTagScalarWhereInput = {
    AND?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
    OR?: CourseTagScalarWhereInput[]
    NOT?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
    courseId?: StringFilter<"CourseTag"> | string
    tagId?: StringFilter<"CourseTag"> | string
  }

  export type UserProgressUpsertWithWhereUniqueWithoutCourseInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutCourseInput, UserProgressUncheckedUpdateWithoutCourseInput>
    create: XOR<UserProgressCreateWithoutCourseInput, UserProgressUncheckedCreateWithoutCourseInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutCourseInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutCourseInput, UserProgressUncheckedUpdateWithoutCourseInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutCourseInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseResourceUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseResourceWhereUniqueInput
    update: XOR<CourseResourceUpdateWithoutCourseInput, CourseResourceUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseResourceCreateWithoutCourseInput, CourseResourceUncheckedCreateWithoutCourseInput>
  }

  export type CourseResourceUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseResourceWhereUniqueInput
    data: XOR<CourseResourceUpdateWithoutCourseInput, CourseResourceUncheckedUpdateWithoutCourseInput>
  }

  export type CourseResourceUpdateManyWithWhereWithoutCourseInput = {
    where: CourseResourceScalarWhereInput
    data: XOR<CourseResourceUpdateManyMutationInput, CourseResourceUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseResourceScalarWhereInput = {
    AND?: CourseResourceScalarWhereInput | CourseResourceScalarWhereInput[]
    OR?: CourseResourceScalarWhereInput[]
    NOT?: CourseResourceScalarWhereInput | CourseResourceScalarWhereInput[]
    courseId?: StringFilter<"CourseResource"> | string
    resourceId?: StringFilter<"CourseResource"> | string
  }

  export type LearningPathItemUpsertWithWhereUniqueWithoutCourseInput = {
    where: LearningPathItemWhereUniqueInput
    update: XOR<LearningPathItemUpdateWithoutCourseInput, LearningPathItemUncheckedUpdateWithoutCourseInput>
    create: XOR<LearningPathItemCreateWithoutCourseInput, LearningPathItemUncheckedCreateWithoutCourseInput>
  }

  export type LearningPathItemUpdateWithWhereUniqueWithoutCourseInput = {
    where: LearningPathItemWhereUniqueInput
    data: XOR<LearningPathItemUpdateWithoutCourseInput, LearningPathItemUncheckedUpdateWithoutCourseInput>
  }

  export type LearningPathItemUpdateManyWithWhereWithoutCourseInput = {
    where: LearningPathItemScalarWhereInput
    data: XOR<LearningPathItemUpdateManyMutationInput, LearningPathItemUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseObjectiveUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseObjectiveWhereUniqueInput
    update: XOR<CourseObjectiveUpdateWithoutCourseInput, CourseObjectiveUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseObjectiveCreateWithoutCourseInput, CourseObjectiveUncheckedCreateWithoutCourseInput>
  }

  export type CourseObjectiveUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseObjectiveWhereUniqueInput
    data: XOR<CourseObjectiveUpdateWithoutCourseInput, CourseObjectiveUncheckedUpdateWithoutCourseInput>
  }

  export type CourseObjectiveUpdateManyWithWhereWithoutCourseInput = {
    where: CourseObjectiveScalarWhereInput
    data: XOR<CourseObjectiveUpdateManyMutationInput, CourseObjectiveUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseObjectiveScalarWhereInput = {
    AND?: CourseObjectiveScalarWhereInput | CourseObjectiveScalarWhereInput[]
    OR?: CourseObjectiveScalarWhereInput[]
    NOT?: CourseObjectiveScalarWhereInput | CourseObjectiveScalarWhereInput[]
    courseId?: StringFilter<"CourseObjective"> | string
    objectiveId?: StringFilter<"CourseObjective"> | string
  }

  export type CoursePrerequisiteUpsertWithWhereUniqueWithoutCourseInput = {
    where: CoursePrerequisiteWhereUniqueInput
    update: XOR<CoursePrerequisiteUpdateWithoutCourseInput, CoursePrerequisiteUncheckedUpdateWithoutCourseInput>
    create: XOR<CoursePrerequisiteCreateWithoutCourseInput, CoursePrerequisiteUncheckedCreateWithoutCourseInput>
  }

  export type CoursePrerequisiteUpdateWithWhereUniqueWithoutCourseInput = {
    where: CoursePrerequisiteWhereUniqueInput
    data: XOR<CoursePrerequisiteUpdateWithoutCourseInput, CoursePrerequisiteUncheckedUpdateWithoutCourseInput>
  }

  export type CoursePrerequisiteUpdateManyWithWhereWithoutCourseInput = {
    where: CoursePrerequisiteScalarWhereInput
    data: XOR<CoursePrerequisiteUpdateManyMutationInput, CoursePrerequisiteUncheckedUpdateManyWithoutCourseInput>
  }

  export type CoursePrerequisiteScalarWhereInput = {
    AND?: CoursePrerequisiteScalarWhereInput | CoursePrerequisiteScalarWhereInput[]
    OR?: CoursePrerequisiteScalarWhereInput[]
    NOT?: CoursePrerequisiteScalarWhereInput | CoursePrerequisiteScalarWhereInput[]
    courseId?: StringFilter<"CoursePrerequisite"> | string
    prerequisiteId?: StringFilter<"CoursePrerequisite"> | string
  }

  export type CourseCreateWithoutChaptersInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCoursesInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    category: CategoryCreateNestedOneWithoutCoursesInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    promotions?: PromotionCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    progress?: UserProgressCreateNestedManyWithoutCourseInput
    resources?: CourseResourceCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutChaptersInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    categoryId: string
    deletedAt?: Date | string | null
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutCourseInput
    resources?: CourseResourceUncheckedCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutChaptersInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutChaptersInput, CourseUncheckedCreateWithoutChaptersInput>
  }

  export type LessonCreateWithoutChapterInput = {
    id?: string
    title: string
    description?: string | null
    thumbnailKey?: string | null
    videoKey?: string | null
    position: number
    duration?: number
    public?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lessonProgress?: LessonProgressCreateNestedManyWithoutLessonInput
    resources?: LessonResourceCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutChapterInput = {
    id?: string
    title: string
    description?: string | null
    thumbnailKey?: string | null
    videoKey?: string | null
    position: number
    duration?: number
    public?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
    resources?: LessonResourceUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutChapterInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutChapterInput, LessonUncheckedCreateWithoutChapterInput>
  }

  export type LessonCreateManyChapterInputEnvelope = {
    data: LessonCreateManyChapterInput | LessonCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutChaptersInput = {
    update: XOR<CourseUpdateWithoutChaptersInput, CourseUncheckedUpdateWithoutChaptersInput>
    create: XOR<CourseCreateWithoutChaptersInput, CourseUncheckedCreateWithoutChaptersInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutChaptersInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutChaptersInput, CourseUncheckedUpdateWithoutChaptersInput>
  }

  export type CourseUpdateWithoutChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCoursesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUncheckedUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type LessonUpsertWithWhereUniqueWithoutChapterInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutChapterInput, LessonUncheckedUpdateWithoutChapterInput>
    create: XOR<LessonCreateWithoutChapterInput, LessonUncheckedCreateWithoutChapterInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutChapterInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutChapterInput, LessonUncheckedUpdateWithoutChapterInput>
  }

  export type LessonUpdateManyWithWhereWithoutChapterInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutChapterInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    description?: StringNullableFilter<"Lesson"> | string | null
    thumbnailKey?: StringNullableFilter<"Lesson"> | string | null
    videoKey?: StringNullableFilter<"Lesson"> | string | null
    position?: IntFilter<"Lesson"> | number
    duration?: IntFilter<"Lesson"> | number
    public?: BoolFilter<"Lesson"> | boolean
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    chapterId?: StringFilter<"Lesson"> | string
  }

  export type ChapterCreateWithoutLessonsInput = {
    id?: string
    title: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutChaptersInput
  }

  export type ChapterUncheckedCreateWithoutLessonsInput = {
    id?: string
    title: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId: string
  }

  export type ChapterCreateOrConnectWithoutLessonsInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutLessonsInput, ChapterUncheckedCreateWithoutLessonsInput>
  }

  export type LessonProgressCreateWithoutLessonInput = {
    id?: string
    completed?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    watchedSeconds?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLessonProgressInput
  }

  export type LessonProgressUncheckedCreateWithoutLessonInput = {
    id?: string
    completed?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    watchedSeconds?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type LessonProgressCreateOrConnectWithoutLessonInput = {
    where: LessonProgressWhereUniqueInput
    create: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput>
  }

  export type LessonProgressCreateManyLessonInputEnvelope = {
    data: LessonProgressCreateManyLessonInput | LessonProgressCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type LessonResourceCreateWithoutLessonInput = {
    resource: ResourceCreateNestedOneWithoutLessonResourcesInput
  }

  export type LessonResourceUncheckedCreateWithoutLessonInput = {
    resourceId: string
  }

  export type LessonResourceCreateOrConnectWithoutLessonInput = {
    where: LessonResourceWhereUniqueInput
    create: XOR<LessonResourceCreateWithoutLessonInput, LessonResourceUncheckedCreateWithoutLessonInput>
  }

  export type LessonResourceCreateManyLessonInputEnvelope = {
    data: LessonResourceCreateManyLessonInput | LessonResourceCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type ChapterUpsertWithoutLessonsInput = {
    update: XOR<ChapterUpdateWithoutLessonsInput, ChapterUncheckedUpdateWithoutLessonsInput>
    create: XOR<ChapterCreateWithoutLessonsInput, ChapterUncheckedCreateWithoutLessonsInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutLessonsInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutLessonsInput, ChapterUncheckedUpdateWithoutLessonsInput>
  }

  export type ChapterUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutChaptersNestedInput
  }

  export type ChapterUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonProgressUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonProgressWhereUniqueInput
    update: XOR<LessonProgressUpdateWithoutLessonInput, LessonProgressUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput>
  }

  export type LessonProgressUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonProgressWhereUniqueInput
    data: XOR<LessonProgressUpdateWithoutLessonInput, LessonProgressUncheckedUpdateWithoutLessonInput>
  }

  export type LessonProgressUpdateManyWithWhereWithoutLessonInput = {
    where: LessonProgressScalarWhereInput
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyWithoutLessonInput>
  }

  export type LessonResourceUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonResourceWhereUniqueInput
    update: XOR<LessonResourceUpdateWithoutLessonInput, LessonResourceUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonResourceCreateWithoutLessonInput, LessonResourceUncheckedCreateWithoutLessonInput>
  }

  export type LessonResourceUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonResourceWhereUniqueInput
    data: XOR<LessonResourceUpdateWithoutLessonInput, LessonResourceUncheckedUpdateWithoutLessonInput>
  }

  export type LessonResourceUpdateManyWithWhereWithoutLessonInput = {
    where: LessonResourceScalarWhereInput
    data: XOR<LessonResourceUpdateManyMutationInput, LessonResourceUncheckedUpdateManyWithoutLessonInput>
  }

  export type LessonResourceScalarWhereInput = {
    AND?: LessonResourceScalarWhereInput | LessonResourceScalarWhereInput[]
    OR?: LessonResourceScalarWhereInput[]
    NOT?: LessonResourceScalarWhereInput | LessonResourceScalarWhereInput[]
    lessonId?: StringFilter<"LessonResource"> | string
    resourceId?: StringFilter<"LessonResource"> | string
  }

  export type UserCreateWithoutWorkshopsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    quiz?: QuizCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkshopsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    quiz?: QuizUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkshopsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkshopsInput, UserUncheckedCreateWithoutWorkshopsInput>
  }

  export type WorkshopTagCreateWithoutWorkshopInput = {
    tag: TagCreateNestedOneWithoutWorkshopTagsInput
  }

  export type WorkshopTagUncheckedCreateWithoutWorkshopInput = {
    tagId: string
  }

  export type WorkshopTagCreateOrConnectWithoutWorkshopInput = {
    where: WorkshopTagWhereUniqueInput
    create: XOR<WorkshopTagCreateWithoutWorkshopInput, WorkshopTagUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopTagCreateManyWorkshopInputEnvelope = {
    data: WorkshopTagCreateManyWorkshopInput | WorkshopTagCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type UserProgressCreateWithoutWorkshopInput = {
    id?: string
    userId: string
    type: string
    completed?: boolean
    updatedAt?: Date | string
    progressPercentage?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    timeSpent?: number | null
    course?: CourseCreateNestedOneWithoutProgressInput
    path?: LearningPathCreateNestedOneWithoutProgressInput
  }

  export type UserProgressUncheckedCreateWithoutWorkshopInput = {
    id?: string
    userId: string
    type: string
    completed?: boolean
    updatedAt?: Date | string
    progressPercentage?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type UserProgressCreateOrConnectWithoutWorkshopInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutWorkshopInput, UserProgressUncheckedCreateWithoutWorkshopInput>
  }

  export type UserProgressCreateManyWorkshopInputEnvelope = {
    data: UserProgressCreateManyWorkshopInput | UserProgressCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type WorkshopResourceCreateWithoutWorkshopInput = {
    resource: ResourceCreateNestedOneWithoutWorkshopResourcesInput
  }

  export type WorkshopResourceUncheckedCreateWithoutWorkshopInput = {
    resourceId: string
  }

  export type WorkshopResourceCreateOrConnectWithoutWorkshopInput = {
    where: WorkshopResourceWhereUniqueInput
    create: XOR<WorkshopResourceCreateWithoutWorkshopInput, WorkshopResourceUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopResourceCreateManyWorkshopInputEnvelope = {
    data: WorkshopResourceCreateManyWorkshopInput | WorkshopResourceCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathItemCreateWithoutWorkshopInput = {
    id?: string
    type: string
    position: number
    learningPath: LearningPathCreateNestedOneWithoutContentsInput
    course?: CourseCreateNestedOneWithoutLearningPathItemsInput
    resource?: ResourceCreateNestedOneWithoutLearningPathItemsInput
  }

  export type LearningPathItemUncheckedCreateWithoutWorkshopInput = {
    id?: string
    type: string
    position: number
    learningPathId: string
    courseId?: string | null
    resourceId?: string | null
  }

  export type LearningPathItemCreateOrConnectWithoutWorkshopInput = {
    where: LearningPathItemWhereUniqueInput
    create: XOR<LearningPathItemCreateWithoutWorkshopInput, LearningPathItemUncheckedCreateWithoutWorkshopInput>
  }

  export type LearningPathItemCreateManyWorkshopInputEnvelope = {
    data: LearningPathItemCreateManyWorkshopInput | LearningPathItemCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type WorkshopObjectiveCreateWithoutWorkshopInput = {
    objective: ObjectiveCreateNestedOneWithoutWorkshopsInput
  }

  export type WorkshopObjectiveUncheckedCreateWithoutWorkshopInput = {
    objectiveId: string
  }

  export type WorkshopObjectiveCreateOrConnectWithoutWorkshopInput = {
    where: WorkshopObjectiveWhereUniqueInput
    create: XOR<WorkshopObjectiveCreateWithoutWorkshopInput, WorkshopObjectiveUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopObjectiveCreateManyWorkshopInputEnvelope = {
    data: WorkshopObjectiveCreateManyWorkshopInput | WorkshopObjectiveCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type WorkshopPrerequisiteCreateWithoutWorkshopInput = {
    prerequisite: PrerequisiteCreateNestedOneWithoutWorkshopsInput
  }

  export type WorkshopPrerequisiteUncheckedCreateWithoutWorkshopInput = {
    prerequisiteId: string
  }

  export type WorkshopPrerequisiteCreateOrConnectWithoutWorkshopInput = {
    where: WorkshopPrerequisiteWhereUniqueInput
    create: XOR<WorkshopPrerequisiteCreateWithoutWorkshopInput, WorkshopPrerequisiteUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopPrerequisiteCreateManyWorkshopInputEnvelope = {
    data: WorkshopPrerequisiteCreateManyWorkshopInput | WorkshopPrerequisiteCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type PromoCodeCreateWithoutApplicableWorkshopsInput = {
    id?: string
    code: string
    description?: string | null
    discount: number
    type?: string
    usageLimit?: number | null
    usedCount?: number
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    applicableCourses?: CourseCreateNestedManyWithoutPromoCodesInput
    applicableLearningPaths?: LearningPathCreateNestedManyWithoutPromoCodesInput
  }

  export type PromoCodeUncheckedCreateWithoutApplicableWorkshopsInput = {
    id?: string
    code: string
    description?: string | null
    discount: number
    type?: string
    usageLimit?: number | null
    usedCount?: number
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    applicableCourses?: CourseUncheckedCreateNestedManyWithoutPromoCodesInput
    applicableLearningPaths?: LearningPathUncheckedCreateNestedManyWithoutPromoCodesInput
  }

  export type PromoCodeCreateOrConnectWithoutApplicableWorkshopsInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutApplicableWorkshopsInput, PromoCodeUncheckedCreateWithoutApplicableWorkshopsInput>
  }

  export type PromotionCreateWithoutWorkshopInput = {
    id?: string
    title: string
    description?: string | null
    discount: number
    type?: string
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    itemType: string
    course?: CourseCreateNestedOneWithoutPromotionsInput
    learningPath?: LearningPathCreateNestedOneWithoutPromotionsInput
  }

  export type PromotionUncheckedCreateWithoutWorkshopInput = {
    id?: string
    title: string
    description?: string | null
    discount: number
    type?: string
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    itemType: string
    courseId?: string | null
    learningPathId?: string | null
  }

  export type PromotionCreateOrConnectWithoutWorkshopInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutWorkshopInput, PromotionUncheckedCreateWithoutWorkshopInput>
  }

  export type PromotionCreateManyWorkshopInputEnvelope = {
    data: PromotionCreateManyWorkshopInput | PromotionCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutWorkshopInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    course?: CourseCreateNestedOneWithoutEnrollmentsInput
    learningPath?: LearningPathCreateNestedOneWithoutEnrollmentsInput
    user: UserCreateNestedOneWithoutEnrollmentInput
    payment?: PaymentCreateNestedOneWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutWorkshopInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: string | null
    learningPathId?: string | null
    userId: string
    paymentId?: string | null
    deletedAt?: Date | string | null
  }

  export type EnrollmentCreateOrConnectWithoutWorkshopInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutWorkshopInput, EnrollmentUncheckedCreateWithoutWorkshopInput>
  }

  export type EnrollmentCreateManyWorkshopInputEnvelope = {
    data: EnrollmentCreateManyWorkshopInput | EnrollmentCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutWorkshopInput = {
    id?: string
    stripeId: string
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPaymentsInput
    course?: CourseCreateNestedOneWithoutPaymentsInput
    learningPath?: LearningPathCreateNestedOneWithoutPaymentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutWorkshopInput = {
    id?: string
    stripeId: string
    userId: string
    courseId?: string | null
    learningPathId?: string | null
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    enrollment?: EnrollmentUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutWorkshopInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutWorkshopInput, PaymentUncheckedCreateWithoutWorkshopInput>
  }

  export type PaymentCreateManyWorkshopInputEnvelope = {
    data: PaymentCreateManyWorkshopInput | PaymentCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWorkshopsInput = {
    update: XOR<UserUpdateWithoutWorkshopsInput, UserUncheckedUpdateWithoutWorkshopsInput>
    create: XOR<UserCreateWithoutWorkshopsInput, UserUncheckedCreateWithoutWorkshopsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkshopsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkshopsInput, UserUncheckedUpdateWithoutWorkshopsInput>
  }

  export type UserUpdateWithoutWorkshopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    quiz?: QuizUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkshopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    quiz?: QuizUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkshopTagUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopTagWhereUniqueInput
    update: XOR<WorkshopTagUpdateWithoutWorkshopInput, WorkshopTagUncheckedUpdateWithoutWorkshopInput>
    create: XOR<WorkshopTagCreateWithoutWorkshopInput, WorkshopTagUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopTagUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopTagWhereUniqueInput
    data: XOR<WorkshopTagUpdateWithoutWorkshopInput, WorkshopTagUncheckedUpdateWithoutWorkshopInput>
  }

  export type WorkshopTagUpdateManyWithWhereWithoutWorkshopInput = {
    where: WorkshopTagScalarWhereInput
    data: XOR<WorkshopTagUpdateManyMutationInput, WorkshopTagUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type WorkshopTagScalarWhereInput = {
    AND?: WorkshopTagScalarWhereInput | WorkshopTagScalarWhereInput[]
    OR?: WorkshopTagScalarWhereInput[]
    NOT?: WorkshopTagScalarWhereInput | WorkshopTagScalarWhereInput[]
    workshopId?: StringFilter<"WorkshopTag"> | string
    tagId?: StringFilter<"WorkshopTag"> | string
  }

  export type UserProgressUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutWorkshopInput, UserProgressUncheckedUpdateWithoutWorkshopInput>
    create: XOR<UserProgressCreateWithoutWorkshopInput, UserProgressUncheckedCreateWithoutWorkshopInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutWorkshopInput, UserProgressUncheckedUpdateWithoutWorkshopInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutWorkshopInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type WorkshopResourceUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopResourceWhereUniqueInput
    update: XOR<WorkshopResourceUpdateWithoutWorkshopInput, WorkshopResourceUncheckedUpdateWithoutWorkshopInput>
    create: XOR<WorkshopResourceCreateWithoutWorkshopInput, WorkshopResourceUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopResourceUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopResourceWhereUniqueInput
    data: XOR<WorkshopResourceUpdateWithoutWorkshopInput, WorkshopResourceUncheckedUpdateWithoutWorkshopInput>
  }

  export type WorkshopResourceUpdateManyWithWhereWithoutWorkshopInput = {
    where: WorkshopResourceScalarWhereInput
    data: XOR<WorkshopResourceUpdateManyMutationInput, WorkshopResourceUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type WorkshopResourceScalarWhereInput = {
    AND?: WorkshopResourceScalarWhereInput | WorkshopResourceScalarWhereInput[]
    OR?: WorkshopResourceScalarWhereInput[]
    NOT?: WorkshopResourceScalarWhereInput | WorkshopResourceScalarWhereInput[]
    workshopId?: StringFilter<"WorkshopResource"> | string
    resourceId?: StringFilter<"WorkshopResource"> | string
  }

  export type LearningPathItemUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: LearningPathItemWhereUniqueInput
    update: XOR<LearningPathItemUpdateWithoutWorkshopInput, LearningPathItemUncheckedUpdateWithoutWorkshopInput>
    create: XOR<LearningPathItemCreateWithoutWorkshopInput, LearningPathItemUncheckedCreateWithoutWorkshopInput>
  }

  export type LearningPathItemUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: LearningPathItemWhereUniqueInput
    data: XOR<LearningPathItemUpdateWithoutWorkshopInput, LearningPathItemUncheckedUpdateWithoutWorkshopInput>
  }

  export type LearningPathItemUpdateManyWithWhereWithoutWorkshopInput = {
    where: LearningPathItemScalarWhereInput
    data: XOR<LearningPathItemUpdateManyMutationInput, LearningPathItemUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type WorkshopObjectiveUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopObjectiveWhereUniqueInput
    update: XOR<WorkshopObjectiveUpdateWithoutWorkshopInput, WorkshopObjectiveUncheckedUpdateWithoutWorkshopInput>
    create: XOR<WorkshopObjectiveCreateWithoutWorkshopInput, WorkshopObjectiveUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopObjectiveUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopObjectiveWhereUniqueInput
    data: XOR<WorkshopObjectiveUpdateWithoutWorkshopInput, WorkshopObjectiveUncheckedUpdateWithoutWorkshopInput>
  }

  export type WorkshopObjectiveUpdateManyWithWhereWithoutWorkshopInput = {
    where: WorkshopObjectiveScalarWhereInput
    data: XOR<WorkshopObjectiveUpdateManyMutationInput, WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type WorkshopObjectiveScalarWhereInput = {
    AND?: WorkshopObjectiveScalarWhereInput | WorkshopObjectiveScalarWhereInput[]
    OR?: WorkshopObjectiveScalarWhereInput[]
    NOT?: WorkshopObjectiveScalarWhereInput | WorkshopObjectiveScalarWhereInput[]
    workshopId?: StringFilter<"WorkshopObjective"> | string
    objectiveId?: StringFilter<"WorkshopObjective"> | string
  }

  export type WorkshopPrerequisiteUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopPrerequisiteWhereUniqueInput
    update: XOR<WorkshopPrerequisiteUpdateWithoutWorkshopInput, WorkshopPrerequisiteUncheckedUpdateWithoutWorkshopInput>
    create: XOR<WorkshopPrerequisiteCreateWithoutWorkshopInput, WorkshopPrerequisiteUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopPrerequisiteUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopPrerequisiteWhereUniqueInput
    data: XOR<WorkshopPrerequisiteUpdateWithoutWorkshopInput, WorkshopPrerequisiteUncheckedUpdateWithoutWorkshopInput>
  }

  export type WorkshopPrerequisiteUpdateManyWithWhereWithoutWorkshopInput = {
    where: WorkshopPrerequisiteScalarWhereInput
    data: XOR<WorkshopPrerequisiteUpdateManyMutationInput, WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type WorkshopPrerequisiteScalarWhereInput = {
    AND?: WorkshopPrerequisiteScalarWhereInput | WorkshopPrerequisiteScalarWhereInput[]
    OR?: WorkshopPrerequisiteScalarWhereInput[]
    NOT?: WorkshopPrerequisiteScalarWhereInput | WorkshopPrerequisiteScalarWhereInput[]
    workshopId?: StringFilter<"WorkshopPrerequisite"> | string
    prerequisiteId?: StringFilter<"WorkshopPrerequisite"> | string
  }

  export type PromoCodeUpsertWithWhereUniqueWithoutApplicableWorkshopsInput = {
    where: PromoCodeWhereUniqueInput
    update: XOR<PromoCodeUpdateWithoutApplicableWorkshopsInput, PromoCodeUncheckedUpdateWithoutApplicableWorkshopsInput>
    create: XOR<PromoCodeCreateWithoutApplicableWorkshopsInput, PromoCodeUncheckedCreateWithoutApplicableWorkshopsInput>
  }

  export type PromoCodeUpdateWithWhereUniqueWithoutApplicableWorkshopsInput = {
    where: PromoCodeWhereUniqueInput
    data: XOR<PromoCodeUpdateWithoutApplicableWorkshopsInput, PromoCodeUncheckedUpdateWithoutApplicableWorkshopsInput>
  }

  export type PromoCodeUpdateManyWithWhereWithoutApplicableWorkshopsInput = {
    where: PromoCodeScalarWhereInput
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsInput>
  }

  export type PromotionUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: PromotionWhereUniqueInput
    update: XOR<PromotionUpdateWithoutWorkshopInput, PromotionUncheckedUpdateWithoutWorkshopInput>
    create: XOR<PromotionCreateWithoutWorkshopInput, PromotionUncheckedCreateWithoutWorkshopInput>
  }

  export type PromotionUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: PromotionWhereUniqueInput
    data: XOR<PromotionUpdateWithoutWorkshopInput, PromotionUncheckedUpdateWithoutWorkshopInput>
  }

  export type PromotionUpdateManyWithWhereWithoutWorkshopInput = {
    where: PromotionScalarWhereInput
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutWorkshopInput, EnrollmentUncheckedUpdateWithoutWorkshopInput>
    create: XOR<EnrollmentCreateWithoutWorkshopInput, EnrollmentUncheckedCreateWithoutWorkshopInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutWorkshopInput, EnrollmentUncheckedUpdateWithoutWorkshopInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutWorkshopInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutWorkshopInput, PaymentUncheckedUpdateWithoutWorkshopInput>
    create: XOR<PaymentCreateWithoutWorkshopInput, PaymentUncheckedCreateWithoutWorkshopInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutWorkshopInput, PaymentUncheckedUpdateWithoutWorkshopInput>
  }

  export type PaymentUpdateManyWithWhereWithoutWorkshopInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type CourseResourceCreateWithoutResourceInput = {
    course: CourseCreateNestedOneWithoutResourcesInput
  }

  export type CourseResourceUncheckedCreateWithoutResourceInput = {
    courseId: string
  }

  export type CourseResourceCreateOrConnectWithoutResourceInput = {
    where: CourseResourceWhereUniqueInput
    create: XOR<CourseResourceCreateWithoutResourceInput, CourseResourceUncheckedCreateWithoutResourceInput>
  }

  export type CourseResourceCreateManyResourceInputEnvelope = {
    data: CourseResourceCreateManyResourceInput | CourseResourceCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type LessonResourceCreateWithoutResourceInput = {
    lesson: LessonCreateNestedOneWithoutResourcesInput
  }

  export type LessonResourceUncheckedCreateWithoutResourceInput = {
    lessonId: string
  }

  export type LessonResourceCreateOrConnectWithoutResourceInput = {
    where: LessonResourceWhereUniqueInput
    create: XOR<LessonResourceCreateWithoutResourceInput, LessonResourceUncheckedCreateWithoutResourceInput>
  }

  export type LessonResourceCreateManyResourceInputEnvelope = {
    data: LessonResourceCreateManyResourceInput | LessonResourceCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type WorkshopResourceCreateWithoutResourceInput = {
    workshop: WorkshopCreateNestedOneWithoutResourcesInput
  }

  export type WorkshopResourceUncheckedCreateWithoutResourceInput = {
    workshopId: string
  }

  export type WorkshopResourceCreateOrConnectWithoutResourceInput = {
    where: WorkshopResourceWhereUniqueInput
    create: XOR<WorkshopResourceCreateWithoutResourceInput, WorkshopResourceUncheckedCreateWithoutResourceInput>
  }

  export type WorkshopResourceCreateManyResourceInputEnvelope = {
    data: WorkshopResourceCreateManyResourceInput | WorkshopResourceCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathResourceCreateWithoutResourceInput = {
    learningPath: LearningPathCreateNestedOneWithoutResourcesInput
  }

  export type LearningPathResourceUncheckedCreateWithoutResourceInput = {
    learningPathId: string
  }

  export type LearningPathResourceCreateOrConnectWithoutResourceInput = {
    where: LearningPathResourceWhereUniqueInput
    create: XOR<LearningPathResourceCreateWithoutResourceInput, LearningPathResourceUncheckedCreateWithoutResourceInput>
  }

  export type LearningPathResourceCreateManyResourceInputEnvelope = {
    data: LearningPathResourceCreateManyResourceInput | LearningPathResourceCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathItemCreateWithoutResourceInput = {
    id?: string
    type: string
    position: number
    learningPath: LearningPathCreateNestedOneWithoutContentsInput
    course?: CourseCreateNestedOneWithoutLearningPathItemsInput
    workshop?: WorkshopCreateNestedOneWithoutLearningPathItemsInput
  }

  export type LearningPathItemUncheckedCreateWithoutResourceInput = {
    id?: string
    type: string
    position: number
    learningPathId: string
    courseId?: string | null
    workshopId?: string | null
  }

  export type LearningPathItemCreateOrConnectWithoutResourceInput = {
    where: LearningPathItemWhereUniqueInput
    create: XOR<LearningPathItemCreateWithoutResourceInput, LearningPathItemUncheckedCreateWithoutResourceInput>
  }

  export type LearningPathItemCreateManyResourceInputEnvelope = {
    data: LearningPathItemCreateManyResourceInput | LearningPathItemCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutResourcesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    workshops?: WorkshopCreateNestedManyWithoutUserInput
    quiz?: QuizCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResourcesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    workshops?: WorkshopUncheckedCreateNestedManyWithoutUserInput
    quiz?: QuizUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResourcesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
  }

  export type CourseResourceUpsertWithWhereUniqueWithoutResourceInput = {
    where: CourseResourceWhereUniqueInput
    update: XOR<CourseResourceUpdateWithoutResourceInput, CourseResourceUncheckedUpdateWithoutResourceInput>
    create: XOR<CourseResourceCreateWithoutResourceInput, CourseResourceUncheckedCreateWithoutResourceInput>
  }

  export type CourseResourceUpdateWithWhereUniqueWithoutResourceInput = {
    where: CourseResourceWhereUniqueInput
    data: XOR<CourseResourceUpdateWithoutResourceInput, CourseResourceUncheckedUpdateWithoutResourceInput>
  }

  export type CourseResourceUpdateManyWithWhereWithoutResourceInput = {
    where: CourseResourceScalarWhereInput
    data: XOR<CourseResourceUpdateManyMutationInput, CourseResourceUncheckedUpdateManyWithoutResourceInput>
  }

  export type LessonResourceUpsertWithWhereUniqueWithoutResourceInput = {
    where: LessonResourceWhereUniqueInput
    update: XOR<LessonResourceUpdateWithoutResourceInput, LessonResourceUncheckedUpdateWithoutResourceInput>
    create: XOR<LessonResourceCreateWithoutResourceInput, LessonResourceUncheckedCreateWithoutResourceInput>
  }

  export type LessonResourceUpdateWithWhereUniqueWithoutResourceInput = {
    where: LessonResourceWhereUniqueInput
    data: XOR<LessonResourceUpdateWithoutResourceInput, LessonResourceUncheckedUpdateWithoutResourceInput>
  }

  export type LessonResourceUpdateManyWithWhereWithoutResourceInput = {
    where: LessonResourceScalarWhereInput
    data: XOR<LessonResourceUpdateManyMutationInput, LessonResourceUncheckedUpdateManyWithoutResourceInput>
  }

  export type WorkshopResourceUpsertWithWhereUniqueWithoutResourceInput = {
    where: WorkshopResourceWhereUniqueInput
    update: XOR<WorkshopResourceUpdateWithoutResourceInput, WorkshopResourceUncheckedUpdateWithoutResourceInput>
    create: XOR<WorkshopResourceCreateWithoutResourceInput, WorkshopResourceUncheckedCreateWithoutResourceInput>
  }

  export type WorkshopResourceUpdateWithWhereUniqueWithoutResourceInput = {
    where: WorkshopResourceWhereUniqueInput
    data: XOR<WorkshopResourceUpdateWithoutResourceInput, WorkshopResourceUncheckedUpdateWithoutResourceInput>
  }

  export type WorkshopResourceUpdateManyWithWhereWithoutResourceInput = {
    where: WorkshopResourceScalarWhereInput
    data: XOR<WorkshopResourceUpdateManyMutationInput, WorkshopResourceUncheckedUpdateManyWithoutResourceInput>
  }

  export type LearningPathResourceUpsertWithWhereUniqueWithoutResourceInput = {
    where: LearningPathResourceWhereUniqueInput
    update: XOR<LearningPathResourceUpdateWithoutResourceInput, LearningPathResourceUncheckedUpdateWithoutResourceInput>
    create: XOR<LearningPathResourceCreateWithoutResourceInput, LearningPathResourceUncheckedCreateWithoutResourceInput>
  }

  export type LearningPathResourceUpdateWithWhereUniqueWithoutResourceInput = {
    where: LearningPathResourceWhereUniqueInput
    data: XOR<LearningPathResourceUpdateWithoutResourceInput, LearningPathResourceUncheckedUpdateWithoutResourceInput>
  }

  export type LearningPathResourceUpdateManyWithWhereWithoutResourceInput = {
    where: LearningPathResourceScalarWhereInput
    data: XOR<LearningPathResourceUpdateManyMutationInput, LearningPathResourceUncheckedUpdateManyWithoutResourceInput>
  }

  export type LearningPathItemUpsertWithWhereUniqueWithoutResourceInput = {
    where: LearningPathItemWhereUniqueInput
    update: XOR<LearningPathItemUpdateWithoutResourceInput, LearningPathItemUncheckedUpdateWithoutResourceInput>
    create: XOR<LearningPathItemCreateWithoutResourceInput, LearningPathItemUncheckedCreateWithoutResourceInput>
  }

  export type LearningPathItemUpdateWithWhereUniqueWithoutResourceInput = {
    where: LearningPathItemWhereUniqueInput
    data: XOR<LearningPathItemUpdateWithoutResourceInput, LearningPathItemUncheckedUpdateWithoutResourceInput>
  }

  export type LearningPathItemUpdateManyWithWhereWithoutResourceInput = {
    where: LearningPathItemScalarWhereInput
    data: XOR<LearningPathItemUpdateManyMutationInput, LearningPathItemUncheckedUpdateManyWithoutResourceInput>
  }

  export type UserUpsertWithoutResourcesInput = {
    update: XOR<UserUpdateWithoutResourcesInput, UserUncheckedUpdateWithoutResourcesInput>
    create: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResourcesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResourcesInput, UserUncheckedUpdateWithoutResourcesInput>
  }

  export type UserUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUpdateManyWithoutUserNestedInput
    quiz?: QuizUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUncheckedUpdateManyWithoutUserNestedInput
    quiz?: QuizUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LearningPathCreateWithoutResourcesInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLearningPathsInput
    tags?: LearningPathTagCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressCreateNestedManyWithoutPathInput
    objectives?: LearningPathObjectiveCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearningPathInput
    payments?: PaymentCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutResourcesInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: LearningPathTagUncheckedCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutPathInput
    objectives?: LearningPathObjectiveUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearningPathInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutResourcesInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutResourcesInput, LearningPathUncheckedCreateWithoutResourcesInput>
  }

  export type ResourceCreateWithoutLearningPathResourcesInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    courseResources?: CourseResourceCreateNestedManyWithoutResourceInput
    lessonResources?: LessonResourceCreateNestedManyWithoutResourceInput
    workshopResources?: WorkshopResourceCreateNestedManyWithoutResourceInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutResourceInput
    user?: UserCreateNestedOneWithoutResourcesInput
  }

  export type ResourceUncheckedCreateWithoutLearningPathResourcesInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    userId: string
    courseResources?: CourseResourceUncheckedCreateNestedManyWithoutResourceInput
    lessonResources?: LessonResourceUncheckedCreateNestedManyWithoutResourceInput
    workshopResources?: WorkshopResourceUncheckedCreateNestedManyWithoutResourceInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutLearningPathResourcesInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutLearningPathResourcesInput, ResourceUncheckedCreateWithoutLearningPathResourcesInput>
  }

  export type LearningPathUpsertWithoutResourcesInput = {
    update: XOR<LearningPathUpdateWithoutResourcesInput, LearningPathUncheckedUpdateWithoutResourcesInput>
    create: XOR<LearningPathCreateWithoutResourcesInput, LearningPathUncheckedCreateWithoutResourcesInput>
    where?: LearningPathWhereInput
  }

  export type LearningPathUpdateToOneWithWhereWithoutResourcesInput = {
    where?: LearningPathWhereInput
    data: XOR<LearningPathUpdateWithoutResourcesInput, LearningPathUncheckedUpdateWithoutResourcesInput>
  }

  export type LearningPathUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLearningPathsNestedInput
    tags?: LearningPathTagUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUpdateManyWithoutPathNestedInput
    objectives?: LearningPathObjectiveUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: LearningPathTagUncheckedUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutPathNestedInput
    objectives?: LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type ResourceUpsertWithoutLearningPathResourcesInput = {
    update: XOR<ResourceUpdateWithoutLearningPathResourcesInput, ResourceUncheckedUpdateWithoutLearningPathResourcesInput>
    create: XOR<ResourceCreateWithoutLearningPathResourcesInput, ResourceUncheckedCreateWithoutLearningPathResourcesInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutLearningPathResourcesInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutLearningPathResourcesInput, ResourceUncheckedUpdateWithoutLearningPathResourcesInput>
  }

  export type ResourceUpdateWithoutLearningPathResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseResources?: CourseResourceUpdateManyWithoutResourceNestedInput
    lessonResources?: LessonResourceUpdateManyWithoutResourceNestedInput
    workshopResources?: WorkshopResourceUpdateManyWithoutResourceNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutResourceNestedInput
    user?: UserUpdateOneWithoutResourcesNestedInput
  }

  export type ResourceUncheckedUpdateWithoutLearningPathResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    courseResources?: CourseResourceUncheckedUpdateManyWithoutResourceNestedInput
    lessonResources?: LessonResourceUncheckedUpdateManyWithoutResourceNestedInput
    workshopResources?: WorkshopResourceUncheckedUpdateManyWithoutResourceNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type CourseCreateWithoutResourcesInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCoursesInput
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    category: CategoryCreateNestedOneWithoutCoursesInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    promotions?: PromotionCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    progress?: UserProgressCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutResourcesInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    categoryId: string
    deletedAt?: Date | string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutResourcesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutResourcesInput, CourseUncheckedCreateWithoutResourcesInput>
  }

  export type ResourceCreateWithoutCourseResourcesInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    lessonResources?: LessonResourceCreateNestedManyWithoutResourceInput
    workshopResources?: WorkshopResourceCreateNestedManyWithoutResourceInput
    learningPathResources?: LearningPathResourceCreateNestedManyWithoutResourceInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutResourceInput
    user?: UserCreateNestedOneWithoutResourcesInput
  }

  export type ResourceUncheckedCreateWithoutCourseResourcesInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    userId: string
    lessonResources?: LessonResourceUncheckedCreateNestedManyWithoutResourceInput
    workshopResources?: WorkshopResourceUncheckedCreateNestedManyWithoutResourceInput
    learningPathResources?: LearningPathResourceUncheckedCreateNestedManyWithoutResourceInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutCourseResourcesInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutCourseResourcesInput, ResourceUncheckedCreateWithoutCourseResourcesInput>
  }

  export type CourseUpsertWithoutResourcesInput = {
    update: XOR<CourseUpdateWithoutResourcesInput, CourseUncheckedUpdateWithoutResourcesInput>
    create: XOR<CourseCreateWithoutResourcesInput, CourseUncheckedCreateWithoutResourcesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutResourcesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutResourcesInput, CourseUncheckedUpdateWithoutResourcesInput>
  }

  export type CourseUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCoursesNestedInput
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ResourceUpsertWithoutCourseResourcesInput = {
    update: XOR<ResourceUpdateWithoutCourseResourcesInput, ResourceUncheckedUpdateWithoutCourseResourcesInput>
    create: XOR<ResourceCreateWithoutCourseResourcesInput, ResourceUncheckedCreateWithoutCourseResourcesInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutCourseResourcesInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutCourseResourcesInput, ResourceUncheckedUpdateWithoutCourseResourcesInput>
  }

  export type ResourceUpdateWithoutCourseResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonResources?: LessonResourceUpdateManyWithoutResourceNestedInput
    workshopResources?: WorkshopResourceUpdateManyWithoutResourceNestedInput
    learningPathResources?: LearningPathResourceUpdateManyWithoutResourceNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutResourceNestedInput
    user?: UserUpdateOneWithoutResourcesNestedInput
  }

  export type ResourceUncheckedUpdateWithoutCourseResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    lessonResources?: LessonResourceUncheckedUpdateManyWithoutResourceNestedInput
    workshopResources?: WorkshopResourceUncheckedUpdateManyWithoutResourceNestedInput
    learningPathResources?: LearningPathResourceUncheckedUpdateManyWithoutResourceNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type LessonCreateWithoutResourcesInput = {
    id?: string
    title: string
    description?: string | null
    thumbnailKey?: string | null
    videoKey?: string | null
    position: number
    duration?: number
    public?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutLessonsInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutResourcesInput = {
    id?: string
    title: string
    description?: string | null
    thumbnailKey?: string | null
    videoKey?: string | null
    position: number
    duration?: number
    public?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chapterId: string
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutResourcesInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutResourcesInput, LessonUncheckedCreateWithoutResourcesInput>
  }

  export type ResourceCreateWithoutLessonResourcesInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    courseResources?: CourseResourceCreateNestedManyWithoutResourceInput
    workshopResources?: WorkshopResourceCreateNestedManyWithoutResourceInput
    learningPathResources?: LearningPathResourceCreateNestedManyWithoutResourceInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutResourceInput
    user?: UserCreateNestedOneWithoutResourcesInput
  }

  export type ResourceUncheckedCreateWithoutLessonResourcesInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    userId: string
    courseResources?: CourseResourceUncheckedCreateNestedManyWithoutResourceInput
    workshopResources?: WorkshopResourceUncheckedCreateNestedManyWithoutResourceInput
    learningPathResources?: LearningPathResourceUncheckedCreateNestedManyWithoutResourceInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutLessonResourcesInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutLessonResourcesInput, ResourceUncheckedCreateWithoutLessonResourcesInput>
  }

  export type LessonUpsertWithoutResourcesInput = {
    update: XOR<LessonUpdateWithoutResourcesInput, LessonUncheckedUpdateWithoutResourcesInput>
    create: XOR<LessonCreateWithoutResourcesInput, LessonUncheckedCreateWithoutResourcesInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutResourcesInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutResourcesInput, LessonUncheckedUpdateWithoutResourcesInput>
  }

  export type LessonUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailKey?: NullableStringFieldUpdateOperationsInput | string | null
    videoKey?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutLessonsNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailKey?: NullableStringFieldUpdateOperationsInput | string | null
    videoKey?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapterId?: StringFieldUpdateOperationsInput | string
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type ResourceUpsertWithoutLessonResourcesInput = {
    update: XOR<ResourceUpdateWithoutLessonResourcesInput, ResourceUncheckedUpdateWithoutLessonResourcesInput>
    create: XOR<ResourceCreateWithoutLessonResourcesInput, ResourceUncheckedCreateWithoutLessonResourcesInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutLessonResourcesInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutLessonResourcesInput, ResourceUncheckedUpdateWithoutLessonResourcesInput>
  }

  export type ResourceUpdateWithoutLessonResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseResources?: CourseResourceUpdateManyWithoutResourceNestedInput
    workshopResources?: WorkshopResourceUpdateManyWithoutResourceNestedInput
    learningPathResources?: LearningPathResourceUpdateManyWithoutResourceNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutResourceNestedInput
    user?: UserUpdateOneWithoutResourcesNestedInput
  }

  export type ResourceUncheckedUpdateWithoutLessonResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    courseResources?: CourseResourceUncheckedUpdateManyWithoutResourceNestedInput
    workshopResources?: WorkshopResourceUncheckedUpdateManyWithoutResourceNestedInput
    learningPathResources?: LearningPathResourceUncheckedUpdateManyWithoutResourceNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type WorkshopCreateWithoutResourcesInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutWorkshopsInput
    tags?: WorkshopTagCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentCreateNestedManyWithoutWorkshopInput
    payments?: PaymentCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutResourcesInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: WorkshopTagUncheckedCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveUncheckedCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutWorkshopInput
    payments?: PaymentUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutResourcesInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutResourcesInput, WorkshopUncheckedCreateWithoutResourcesInput>
  }

  export type ResourceCreateWithoutWorkshopResourcesInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    courseResources?: CourseResourceCreateNestedManyWithoutResourceInput
    lessonResources?: LessonResourceCreateNestedManyWithoutResourceInput
    learningPathResources?: LearningPathResourceCreateNestedManyWithoutResourceInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutResourceInput
    user?: UserCreateNestedOneWithoutResourcesInput
  }

  export type ResourceUncheckedCreateWithoutWorkshopResourcesInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
    userId: string
    courseResources?: CourseResourceUncheckedCreateNestedManyWithoutResourceInput
    lessonResources?: LessonResourceUncheckedCreateNestedManyWithoutResourceInput
    learningPathResources?: LearningPathResourceUncheckedCreateNestedManyWithoutResourceInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutWorkshopResourcesInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutWorkshopResourcesInput, ResourceUncheckedCreateWithoutWorkshopResourcesInput>
  }

  export type WorkshopUpsertWithoutResourcesInput = {
    update: XOR<WorkshopUpdateWithoutResourcesInput, WorkshopUncheckedUpdateWithoutResourcesInput>
    create: XOR<WorkshopCreateWithoutResourcesInput, WorkshopUncheckedCreateWithoutResourcesInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutResourcesInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutResourcesInput, WorkshopUncheckedUpdateWithoutResourcesInput>
  }

  export type WorkshopUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutWorkshopsNestedInput
    tags?: WorkshopTagUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: WorkshopTagUncheckedUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type ResourceUpsertWithoutWorkshopResourcesInput = {
    update: XOR<ResourceUpdateWithoutWorkshopResourcesInput, ResourceUncheckedUpdateWithoutWorkshopResourcesInput>
    create: XOR<ResourceCreateWithoutWorkshopResourcesInput, ResourceUncheckedCreateWithoutWorkshopResourcesInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutWorkshopResourcesInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutWorkshopResourcesInput, ResourceUncheckedUpdateWithoutWorkshopResourcesInput>
  }

  export type ResourceUpdateWithoutWorkshopResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseResources?: CourseResourceUpdateManyWithoutResourceNestedInput
    lessonResources?: LessonResourceUpdateManyWithoutResourceNestedInput
    learningPathResources?: LearningPathResourceUpdateManyWithoutResourceNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutResourceNestedInput
    user?: UserUpdateOneWithoutResourcesNestedInput
  }

  export type ResourceUncheckedUpdateWithoutWorkshopResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    courseResources?: CourseResourceUncheckedUpdateManyWithoutResourceNestedInput
    lessonResources?: LessonResourceUncheckedUpdateManyWithoutResourceNestedInput
    learningPathResources?: LearningPathResourceUncheckedUpdateManyWithoutResourceNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type UserCreateWithoutLessonProgressInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    workshops?: WorkshopCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    quiz?: QuizCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLessonProgressInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    workshops?: WorkshopUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    quiz?: QuizUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLessonProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonProgressInput, UserUncheckedCreateWithoutLessonProgressInput>
  }

  export type LessonCreateWithoutLessonProgressInput = {
    id?: string
    title: string
    description?: string | null
    thumbnailKey?: string | null
    videoKey?: string | null
    position: number
    duration?: number
    public?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutLessonsInput
    resources?: LessonResourceCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutLessonProgressInput = {
    id?: string
    title: string
    description?: string | null
    thumbnailKey?: string | null
    videoKey?: string | null
    position: number
    duration?: number
    public?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chapterId: string
    resources?: LessonResourceUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutLessonProgressInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutLessonProgressInput, LessonUncheckedCreateWithoutLessonProgressInput>
  }

  export type UserUpsertWithoutLessonProgressInput = {
    update: XOR<UserUpdateWithoutLessonProgressInput, UserUncheckedUpdateWithoutLessonProgressInput>
    create: XOR<UserCreateWithoutLessonProgressInput, UserUncheckedCreateWithoutLessonProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLessonProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLessonProgressInput, UserUncheckedUpdateWithoutLessonProgressInput>
  }

  export type UserUpdateWithoutLessonProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    quiz?: QuizUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    quiz?: QuizUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LessonUpsertWithoutLessonProgressInput = {
    update: XOR<LessonUpdateWithoutLessonProgressInput, LessonUncheckedUpdateWithoutLessonProgressInput>
    create: XOR<LessonCreateWithoutLessonProgressInput, LessonUncheckedCreateWithoutLessonProgressInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutLessonProgressInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutLessonProgressInput, LessonUncheckedUpdateWithoutLessonProgressInput>
  }

  export type LessonUpdateWithoutLessonProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailKey?: NullableStringFieldUpdateOperationsInput | string | null
    videoKey?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutLessonsNestedInput
    resources?: LessonResourceUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutLessonProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailKey?: NullableStringFieldUpdateOperationsInput | string | null
    videoKey?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapterId?: StringFieldUpdateOperationsInput | string
    resources?: LessonResourceUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type CourseCreateWithoutProgressInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCoursesInput
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    category: CategoryCreateNestedOneWithoutCoursesInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    promotions?: PromotionCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    resources?: CourseResourceCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutProgressInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    categoryId: string
    deletedAt?: Date | string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    resources?: CourseResourceUncheckedCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutProgressInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutProgressInput, CourseUncheckedCreateWithoutProgressInput>
  }

  export type WorkshopCreateWithoutProgressInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutWorkshopsInput
    tags?: WorkshopTagCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentCreateNestedManyWithoutWorkshopInput
    payments?: PaymentCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutProgressInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: WorkshopTagUncheckedCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceUncheckedCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveUncheckedCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutWorkshopInput
    payments?: PaymentUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutProgressInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutProgressInput, WorkshopUncheckedCreateWithoutProgressInput>
  }

  export type LearningPathCreateWithoutProgressInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLearningPathsInput
    tags?: LearningPathTagCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    resources?: LearningPathResourceCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearningPathInput
    payments?: PaymentCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutProgressInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: LearningPathTagUncheckedCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    resources?: LearningPathResourceUncheckedCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearningPathInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutProgressInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutProgressInput, LearningPathUncheckedCreateWithoutProgressInput>
  }

  export type CourseUpsertWithoutProgressInput = {
    update: XOR<CourseUpdateWithoutProgressInput, CourseUncheckedUpdateWithoutProgressInput>
    create: XOR<CourseCreateWithoutProgressInput, CourseUncheckedCreateWithoutProgressInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutProgressInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutProgressInput, CourseUncheckedUpdateWithoutProgressInput>
  }

  export type CourseUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCoursesNestedInput
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUncheckedUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type WorkshopUpsertWithoutProgressInput = {
    update: XOR<WorkshopUpdateWithoutProgressInput, WorkshopUncheckedUpdateWithoutProgressInput>
    create: XOR<WorkshopCreateWithoutProgressInput, WorkshopUncheckedCreateWithoutProgressInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutProgressInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutProgressInput, WorkshopUncheckedUpdateWithoutProgressInput>
  }

  export type WorkshopUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutWorkshopsNestedInput
    tags?: WorkshopTagUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: WorkshopTagUncheckedUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUncheckedUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type LearningPathUpsertWithoutProgressInput = {
    update: XOR<LearningPathUpdateWithoutProgressInput, LearningPathUncheckedUpdateWithoutProgressInput>
    create: XOR<LearningPathCreateWithoutProgressInput, LearningPathUncheckedCreateWithoutProgressInput>
    where?: LearningPathWhereInput
  }

  export type LearningPathUpdateToOneWithWhereWithoutProgressInput = {
    where?: LearningPathWhereInput
    data: XOR<LearningPathUpdateWithoutProgressInput, LearningPathUncheckedUpdateWithoutProgressInput>
  }

  export type LearningPathUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLearningPathsNestedInput
    tags?: LearningPathTagUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    resources?: LearningPathResourceUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: LearningPathTagUncheckedUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    resources?: LearningPathResourceUncheckedUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type CourseTagCreateWithoutTagInput = {
    course: CourseCreateNestedOneWithoutTagsInput
  }

  export type CourseTagUncheckedCreateWithoutTagInput = {
    courseId: string
  }

  export type CourseTagCreateOrConnectWithoutTagInput = {
    where: CourseTagWhereUniqueInput
    create: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput>
  }

  export type CourseTagCreateManyTagInputEnvelope = {
    data: CourseTagCreateManyTagInput | CourseTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type WorkshopTagCreateWithoutTagInput = {
    workshop: WorkshopCreateNestedOneWithoutTagsInput
  }

  export type WorkshopTagUncheckedCreateWithoutTagInput = {
    workshopId: string
  }

  export type WorkshopTagCreateOrConnectWithoutTagInput = {
    where: WorkshopTagWhereUniqueInput
    create: XOR<WorkshopTagCreateWithoutTagInput, WorkshopTagUncheckedCreateWithoutTagInput>
  }

  export type WorkshopTagCreateManyTagInputEnvelope = {
    data: WorkshopTagCreateManyTagInput | WorkshopTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathTagCreateWithoutTagInput = {
    learningPath: LearningPathCreateNestedOneWithoutTagsInput
  }

  export type LearningPathTagUncheckedCreateWithoutTagInput = {
    learningPathId: string
  }

  export type LearningPathTagCreateOrConnectWithoutTagInput = {
    where: LearningPathTagWhereUniqueInput
    create: XOR<LearningPathTagCreateWithoutTagInput, LearningPathTagUncheckedCreateWithoutTagInput>
  }

  export type LearningPathTagCreateManyTagInputEnvelope = {
    data: LearningPathTagCreateManyTagInput | LearningPathTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type CourseTagUpsertWithWhereUniqueWithoutTagInput = {
    where: CourseTagWhereUniqueInput
    update: XOR<CourseTagUpdateWithoutTagInput, CourseTagUncheckedUpdateWithoutTagInput>
    create: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput>
  }

  export type CourseTagUpdateWithWhereUniqueWithoutTagInput = {
    where: CourseTagWhereUniqueInput
    data: XOR<CourseTagUpdateWithoutTagInput, CourseTagUncheckedUpdateWithoutTagInput>
  }

  export type CourseTagUpdateManyWithWhereWithoutTagInput = {
    where: CourseTagScalarWhereInput
    data: XOR<CourseTagUpdateManyMutationInput, CourseTagUncheckedUpdateManyWithoutTagInput>
  }

  export type WorkshopTagUpsertWithWhereUniqueWithoutTagInput = {
    where: WorkshopTagWhereUniqueInput
    update: XOR<WorkshopTagUpdateWithoutTagInput, WorkshopTagUncheckedUpdateWithoutTagInput>
    create: XOR<WorkshopTagCreateWithoutTagInput, WorkshopTagUncheckedCreateWithoutTagInput>
  }

  export type WorkshopTagUpdateWithWhereUniqueWithoutTagInput = {
    where: WorkshopTagWhereUniqueInput
    data: XOR<WorkshopTagUpdateWithoutTagInput, WorkshopTagUncheckedUpdateWithoutTagInput>
  }

  export type WorkshopTagUpdateManyWithWhereWithoutTagInput = {
    where: WorkshopTagScalarWhereInput
    data: XOR<WorkshopTagUpdateManyMutationInput, WorkshopTagUncheckedUpdateManyWithoutTagInput>
  }

  export type LearningPathTagUpsertWithWhereUniqueWithoutTagInput = {
    where: LearningPathTagWhereUniqueInput
    update: XOR<LearningPathTagUpdateWithoutTagInput, LearningPathTagUncheckedUpdateWithoutTagInput>
    create: XOR<LearningPathTagCreateWithoutTagInput, LearningPathTagUncheckedCreateWithoutTagInput>
  }

  export type LearningPathTagUpdateWithWhereUniqueWithoutTagInput = {
    where: LearningPathTagWhereUniqueInput
    data: XOR<LearningPathTagUpdateWithoutTagInput, LearningPathTagUncheckedUpdateWithoutTagInput>
  }

  export type LearningPathTagUpdateManyWithWhereWithoutTagInput = {
    where: LearningPathTagScalarWhereInput
    data: XOR<LearningPathTagUpdateManyMutationInput, LearningPathTagUncheckedUpdateManyWithoutTagInput>
  }

  export type CourseCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCoursesInput
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    category: CategoryCreateNestedOneWithoutCoursesInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    promotions?: PromotionCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableCoursesInput
    progress?: UserProgressCreateNestedManyWithoutCourseInput
    resources?: CourseResourceCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    categoryId: string
    deletedAt?: Date | string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutCourseInput
    resources?: CourseResourceUncheckedCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutTagsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutCourseTagsInput = {
    id?: string
    title: string
    slug: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workshopTags?: WorkshopTagCreateNestedManyWithoutTagInput
    learningPathTags?: LearningPathTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutCourseTagsInput = {
    id?: string
    title: string
    slug: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workshopTags?: WorkshopTagUncheckedCreateNestedManyWithoutTagInput
    learningPathTags?: LearningPathTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutCourseTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutCourseTagsInput, TagUncheckedCreateWithoutCourseTagsInput>
  }

  export type CourseUpsertWithoutTagsInput = {
    update: XOR<CourseUpdateWithoutTagsInput, CourseUncheckedUpdateWithoutTagsInput>
    create: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutTagsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutTagsInput, CourseUncheckedUpdateWithoutTagsInput>
  }

  export type CourseUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCoursesNestedInput
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableCoursesNestedInput
    progress?: UserProgressUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUncheckedUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type TagUpsertWithoutCourseTagsInput = {
    update: XOR<TagUpdateWithoutCourseTagsInput, TagUncheckedUpdateWithoutCourseTagsInput>
    create: XOR<TagCreateWithoutCourseTagsInput, TagUncheckedCreateWithoutCourseTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutCourseTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutCourseTagsInput, TagUncheckedUpdateWithoutCourseTagsInput>
  }

  export type TagUpdateWithoutCourseTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workshopTags?: WorkshopTagUpdateManyWithoutTagNestedInput
    learningPathTags?: LearningPathTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutCourseTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workshopTags?: WorkshopTagUncheckedUpdateManyWithoutTagNestedInput
    learningPathTags?: LearningPathTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type WorkshopCreateWithoutTagsInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutWorkshopsInput
    progress?: UserProgressCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentCreateNestedManyWithoutWorkshopInput
    payments?: PaymentCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    progress?: UserProgressUncheckedCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceUncheckedCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveUncheckedCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutWorkshopInput
    payments?: PaymentUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutTagsInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutTagsInput, WorkshopUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutWorkshopTagsInput = {
    id?: string
    title: string
    slug: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseTags?: CourseTagCreateNestedManyWithoutTagInput
    learningPathTags?: LearningPathTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutWorkshopTagsInput = {
    id?: string
    title: string
    slug: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseTags?: CourseTagUncheckedCreateNestedManyWithoutTagInput
    learningPathTags?: LearningPathTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutWorkshopTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutWorkshopTagsInput, TagUncheckedCreateWithoutWorkshopTagsInput>
  }

  export type WorkshopUpsertWithoutTagsInput = {
    update: XOR<WorkshopUpdateWithoutTagsInput, WorkshopUncheckedUpdateWithoutTagsInput>
    create: XOR<WorkshopCreateWithoutTagsInput, WorkshopUncheckedCreateWithoutTagsInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutTagsInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutTagsInput, WorkshopUncheckedUpdateWithoutTagsInput>
  }

  export type WorkshopUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutWorkshopsNestedInput
    progress?: UserProgressUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: UserProgressUncheckedUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUncheckedUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type TagUpsertWithoutWorkshopTagsInput = {
    update: XOR<TagUpdateWithoutWorkshopTagsInput, TagUncheckedUpdateWithoutWorkshopTagsInput>
    create: XOR<TagCreateWithoutWorkshopTagsInput, TagUncheckedCreateWithoutWorkshopTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutWorkshopTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutWorkshopTagsInput, TagUncheckedUpdateWithoutWorkshopTagsInput>
  }

  export type TagUpdateWithoutWorkshopTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseTags?: CourseTagUpdateManyWithoutTagNestedInput
    learningPathTags?: LearningPathTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutWorkshopTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseTags?: CourseTagUncheckedUpdateManyWithoutTagNestedInput
    learningPathTags?: LearningPathTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type LearningPathCreateWithoutTagsInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLearningPathsInput
    contents?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearningPathInput
    payments?: PaymentCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    contents?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceUncheckedCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearningPathInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutTagsInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutTagsInput, LearningPathUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutLearningPathTagsInput = {
    id?: string
    title: string
    slug: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseTags?: CourseTagCreateNestedManyWithoutTagInput
    workshopTags?: WorkshopTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutLearningPathTagsInput = {
    id?: string
    title: string
    slug: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseTags?: CourseTagUncheckedCreateNestedManyWithoutTagInput
    workshopTags?: WorkshopTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutLearningPathTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutLearningPathTagsInput, TagUncheckedCreateWithoutLearningPathTagsInput>
  }

  export type LearningPathUpsertWithoutTagsInput = {
    update: XOR<LearningPathUpdateWithoutTagsInput, LearningPathUncheckedUpdateWithoutTagsInput>
    create: XOR<LearningPathCreateWithoutTagsInput, LearningPathUncheckedCreateWithoutTagsInput>
    where?: LearningPathWhereInput
  }

  export type LearningPathUpdateToOneWithWhereWithoutTagsInput = {
    where?: LearningPathWhereInput
    data: XOR<LearningPathUpdateWithoutTagsInput, LearningPathUncheckedUpdateWithoutTagsInput>
  }

  export type LearningPathUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLearningPathsNestedInput
    contents?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contents?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUncheckedUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type TagUpsertWithoutLearningPathTagsInput = {
    update: XOR<TagUpdateWithoutLearningPathTagsInput, TagUncheckedUpdateWithoutLearningPathTagsInput>
    create: XOR<TagCreateWithoutLearningPathTagsInput, TagUncheckedCreateWithoutLearningPathTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutLearningPathTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutLearningPathTagsInput, TagUncheckedUpdateWithoutLearningPathTagsInput>
  }

  export type TagUpdateWithoutLearningPathTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseTags?: CourseTagUpdateManyWithoutTagNestedInput
    workshopTags?: WorkshopTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutLearningPathTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseTags?: CourseTagUncheckedUpdateManyWithoutTagNestedInput
    workshopTags?: WorkshopTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type CourseCreateWithoutPromotionsInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCoursesInput
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    category: CategoryCreateNestedOneWithoutCoursesInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    progress?: UserProgressCreateNestedManyWithoutCourseInput
    resources?: CourseResourceCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPromotionsInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    categoryId: string
    deletedAt?: Date | string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutCourseInput
    resources?: CourseResourceUncheckedCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPromotionsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPromotionsInput, CourseUncheckedCreateWithoutPromotionsInput>
  }

  export type WorkshopCreateWithoutPromotionsInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutWorkshopsInput
    tags?: WorkshopTagCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableWorkshopsInput
    enrollments?: EnrollmentCreateNestedManyWithoutWorkshopInput
    payments?: PaymentCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutPromotionsInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: WorkshopTagUncheckedCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceUncheckedCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveUncheckedCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableWorkshopsInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutWorkshopInput
    payments?: PaymentUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutPromotionsInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutPromotionsInput, WorkshopUncheckedCreateWithoutPromotionsInput>
  }

  export type LearningPathCreateWithoutPromotionsInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLearningPathsInput
    tags?: LearningPathTagCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableLearningPathsInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearningPathInput
    payments?: PaymentCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutPromotionsInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: LearningPathTagUncheckedCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceUncheckedCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableLearningPathsInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearningPathInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutPromotionsInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutPromotionsInput, LearningPathUncheckedCreateWithoutPromotionsInput>
  }

  export type CourseUpsertWithoutPromotionsInput = {
    update: XOR<CourseUpdateWithoutPromotionsInput, CourseUncheckedUpdateWithoutPromotionsInput>
    create: XOR<CourseCreateWithoutPromotionsInput, CourseUncheckedCreateWithoutPromotionsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutPromotionsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutPromotionsInput, CourseUncheckedUpdateWithoutPromotionsInput>
  }

  export type CourseUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCoursesNestedInput
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUncheckedUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type WorkshopUpsertWithoutPromotionsInput = {
    update: XOR<WorkshopUpdateWithoutPromotionsInput, WorkshopUncheckedUpdateWithoutPromotionsInput>
    create: XOR<WorkshopCreateWithoutPromotionsInput, WorkshopUncheckedCreateWithoutPromotionsInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutPromotionsInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutPromotionsInput, WorkshopUncheckedUpdateWithoutPromotionsInput>
  }

  export type WorkshopUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutWorkshopsNestedInput
    tags?: WorkshopTagUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableWorkshopsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: WorkshopTagUncheckedUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUncheckedUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type LearningPathUpsertWithoutPromotionsInput = {
    update: XOR<LearningPathUpdateWithoutPromotionsInput, LearningPathUncheckedUpdateWithoutPromotionsInput>
    create: XOR<LearningPathCreateWithoutPromotionsInput, LearningPathUncheckedCreateWithoutPromotionsInput>
    where?: LearningPathWhereInput
  }

  export type LearningPathUpdateToOneWithWhereWithoutPromotionsInput = {
    where?: LearningPathWhereInput
    data: XOR<LearningPathUpdateWithoutPromotionsInput, LearningPathUncheckedUpdateWithoutPromotionsInput>
  }

  export type LearningPathUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLearningPathsNestedInput
    tags?: LearningPathTagUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableLearningPathsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: LearningPathTagUncheckedUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUncheckedUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type CourseCreateWithoutPromoCodesInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCoursesInput
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    category: CategoryCreateNestedOneWithoutCoursesInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    promotions?: PromotionCreateNestedManyWithoutCourseInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    progress?: UserProgressCreateNestedManyWithoutCourseInput
    resources?: CourseResourceCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPromoCodesInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    categoryId: string
    deletedAt?: Date | string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutCourseInput
    resources?: CourseResourceUncheckedCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPromoCodesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPromoCodesInput, CourseUncheckedCreateWithoutPromoCodesInput>
  }

  export type WorkshopCreateWithoutPromoCodesInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutWorkshopsInput
    tags?: WorkshopTagCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteCreateNestedManyWithoutWorkshopInput
    promotions?: PromotionCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentCreateNestedManyWithoutWorkshopInput
    payments?: PaymentCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutPromoCodesInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: WorkshopTagUncheckedCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceUncheckedCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveUncheckedCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutWorkshopInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutWorkshopInput
    payments?: PaymentUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutPromoCodesInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutPromoCodesInput, WorkshopUncheckedCreateWithoutPromoCodesInput>
  }

  export type LearningPathCreateWithoutPromoCodesInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLearningPathsInput
    tags?: LearningPathTagCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteCreateNestedManyWithoutLearningPathInput
    promotions?: PromotionCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearningPathInput
    payments?: PaymentCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutPromoCodesInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: LearningPathTagUncheckedCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceUncheckedCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearningPathInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutPromoCodesInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutPromoCodesInput, LearningPathUncheckedCreateWithoutPromoCodesInput>
  }

  export type CourseUpsertWithWhereUniqueWithoutPromoCodesInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutPromoCodesInput, CourseUncheckedUpdateWithoutPromoCodesInput>
    create: XOR<CourseCreateWithoutPromoCodesInput, CourseUncheckedCreateWithoutPromoCodesInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutPromoCodesInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutPromoCodesInput, CourseUncheckedUpdateWithoutPromoCodesInput>
  }

  export type CourseUpdateManyWithWhereWithoutPromoCodesInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutPromoCodesInput>
  }

  export type WorkshopUpsertWithWhereUniqueWithoutPromoCodesInput = {
    where: WorkshopWhereUniqueInput
    update: XOR<WorkshopUpdateWithoutPromoCodesInput, WorkshopUncheckedUpdateWithoutPromoCodesInput>
    create: XOR<WorkshopCreateWithoutPromoCodesInput, WorkshopUncheckedCreateWithoutPromoCodesInput>
  }

  export type WorkshopUpdateWithWhereUniqueWithoutPromoCodesInput = {
    where: WorkshopWhereUniqueInput
    data: XOR<WorkshopUpdateWithoutPromoCodesInput, WorkshopUncheckedUpdateWithoutPromoCodesInput>
  }

  export type WorkshopUpdateManyWithWhereWithoutPromoCodesInput = {
    where: WorkshopScalarWhereInput
    data: XOR<WorkshopUpdateManyMutationInput, WorkshopUncheckedUpdateManyWithoutPromoCodesInput>
  }

  export type LearningPathUpsertWithWhereUniqueWithoutPromoCodesInput = {
    where: LearningPathWhereUniqueInput
    update: XOR<LearningPathUpdateWithoutPromoCodesInput, LearningPathUncheckedUpdateWithoutPromoCodesInput>
    create: XOR<LearningPathCreateWithoutPromoCodesInput, LearningPathUncheckedCreateWithoutPromoCodesInput>
  }

  export type LearningPathUpdateWithWhereUniqueWithoutPromoCodesInput = {
    where: LearningPathWhereUniqueInput
    data: XOR<LearningPathUpdateWithoutPromoCodesInput, LearningPathUncheckedUpdateWithoutPromoCodesInput>
  }

  export type LearningPathUpdateManyWithWhereWithoutPromoCodesInput = {
    where: LearningPathScalarWhereInput
    data: XOR<LearningPathUpdateManyMutationInput, LearningPathUncheckedUpdateManyWithoutPromoCodesInput>
  }

  export type CourseCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCoursesInput
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    category: CategoryCreateNestedOneWithoutCoursesInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    promotions?: PromotionCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    progress?: UserProgressCreateNestedManyWithoutCourseInput
    resources?: CourseResourceCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    categoryId: string
    deletedAt?: Date | string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutCourseInput
    resources?: CourseResourceUncheckedCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
  }

  export type LearningPathCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLearningPathsInput
    tags?: LearningPathTagCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionCreateNestedManyWithoutLearningPathInput
    payments?: PaymentCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: LearningPathTagUncheckedCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceUncheckedCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutLearningPathInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutEnrollmentsInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutEnrollmentsInput, LearningPathUncheckedCreateWithoutEnrollmentsInput>
  }

  export type WorkshopCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutWorkshopsInput
    tags?: WorkshopTagCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionCreateNestedManyWithoutWorkshopInput
    payments?: PaymentCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: WorkshopTagUncheckedCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceUncheckedCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveUncheckedCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutWorkshopInput
    payments?: PaymentUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutEnrollmentsInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutEnrollmentsInput, WorkshopUncheckedCreateWithoutEnrollmentsInput>
  }

  export type UserCreateWithoutEnrollmentInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    workshops?: WorkshopCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    quiz?: QuizCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEnrollmentInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    workshops?: WorkshopUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    quiz?: QuizUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEnrollmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnrollmentInput, UserUncheckedCreateWithoutEnrollmentInput>
  }

  export type PaymentCreateWithoutEnrollmentInput = {
    id?: string
    stripeId: string
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPaymentsInput
    course?: CourseCreateNestedOneWithoutPaymentsInput
    learningPath?: LearningPathCreateNestedOneWithoutPaymentsInput
    workshop?: WorkshopCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutEnrollmentInput = {
    id?: string
    stripeId: string
    userId: string
    courseId?: string | null
    learningPathId?: string | null
    workshopId?: string | null
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PaymentCreateOrConnectWithoutEnrollmentInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutEnrollmentInput, PaymentUncheckedCreateWithoutEnrollmentInput>
  }

  export type CourseUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCoursesNestedInput
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUncheckedUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type LearningPathUpsertWithoutEnrollmentsInput = {
    update: XOR<LearningPathUpdateWithoutEnrollmentsInput, LearningPathUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<LearningPathCreateWithoutEnrollmentsInput, LearningPathUncheckedCreateWithoutEnrollmentsInput>
    where?: LearningPathWhereInput
  }

  export type LearningPathUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: LearningPathWhereInput
    data: XOR<LearningPathUpdateWithoutEnrollmentsInput, LearningPathUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type LearningPathUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLearningPathsNestedInput
    tags?: LearningPathTagUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: LearningPathTagUncheckedUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUncheckedUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type WorkshopUpsertWithoutEnrollmentsInput = {
    update: XOR<WorkshopUpdateWithoutEnrollmentsInput, WorkshopUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<WorkshopCreateWithoutEnrollmentsInput, WorkshopUncheckedCreateWithoutEnrollmentsInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutEnrollmentsInput, WorkshopUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type WorkshopUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutWorkshopsNestedInput
    tags?: WorkshopTagUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: WorkshopTagUncheckedUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUncheckedUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type UserUpsertWithoutEnrollmentInput = {
    update: XOR<UserUpdateWithoutEnrollmentInput, UserUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<UserCreateWithoutEnrollmentInput, UserUncheckedCreateWithoutEnrollmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnrollmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnrollmentInput, UserUncheckedUpdateWithoutEnrollmentInput>
  }

  export type UserUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    quiz?: QuizUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    quiz?: QuizUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentUpsertWithoutEnrollmentInput = {
    update: XOR<PaymentUpdateWithoutEnrollmentInput, PaymentUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<PaymentCreateWithoutEnrollmentInput, PaymentUncheckedCreateWithoutEnrollmentInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutEnrollmentInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutEnrollmentInput, PaymentUncheckedUpdateWithoutEnrollmentInput>
  }

  export type PaymentUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    course?: CourseUpdateOneWithoutPaymentsNestedInput
    learningPath?: LearningPathUpdateOneWithoutPaymentsNestedInput
    workshop?: WorkshopUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutPaymentsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    workshops?: WorkshopCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    quiz?: QuizCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    workshops?: WorkshopUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    quiz?: QuizUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type CourseCreateWithoutPaymentsInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCoursesInput
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    category: CategoryCreateNestedOneWithoutCoursesInput
    promotions?: PromotionCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    progress?: UserProgressCreateNestedManyWithoutCourseInput
    resources?: CourseResourceCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPaymentsInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    categoryId: string
    deletedAt?: Date | string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutCourseInput
    resources?: CourseResourceUncheckedCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPaymentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPaymentsInput, CourseUncheckedCreateWithoutPaymentsInput>
  }

  export type LearningPathCreateWithoutPaymentsInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLearningPathsInput
    tags?: LearningPathTagCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutPaymentsInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: LearningPathTagUncheckedCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceUncheckedCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutPaymentsInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutPaymentsInput, LearningPathUncheckedCreateWithoutPaymentsInput>
  }

  export type WorkshopCreateWithoutPaymentsInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutWorkshopsInput
    tags?: WorkshopTagCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutPaymentsInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: WorkshopTagUncheckedCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceUncheckedCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveUncheckedCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutPaymentsInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutPaymentsInput, WorkshopUncheckedCreateWithoutPaymentsInput>
  }

  export type EnrollmentCreateWithoutPaymentInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    course?: CourseCreateNestedOneWithoutEnrollmentsInput
    learningPath?: LearningPathCreateNestedOneWithoutEnrollmentsInput
    workshop?: WorkshopCreateNestedOneWithoutEnrollmentsInput
    user: UserCreateNestedOneWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutPaymentInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: string | null
    learningPathId?: string | null
    workshopId?: string | null
    userId: string
    deletedAt?: Date | string | null
  }

  export type EnrollmentCreateOrConnectWithoutPaymentInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutPaymentInput, EnrollmentUncheckedCreateWithoutPaymentInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    quiz?: QuizUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    quiz?: QuizUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutPaymentsInput = {
    update: XOR<CourseUpdateWithoutPaymentsInput, CourseUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CourseCreateWithoutPaymentsInput, CourseUncheckedCreateWithoutPaymentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutPaymentsInput, CourseUncheckedUpdateWithoutPaymentsInput>
  }

  export type CourseUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCoursesNestedInput
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
    promotions?: PromotionUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUncheckedUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type LearningPathUpsertWithoutPaymentsInput = {
    update: XOR<LearningPathUpdateWithoutPaymentsInput, LearningPathUncheckedUpdateWithoutPaymentsInput>
    create: XOR<LearningPathCreateWithoutPaymentsInput, LearningPathUncheckedCreateWithoutPaymentsInput>
    where?: LearningPathWhereInput
  }

  export type LearningPathUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: LearningPathWhereInput
    data: XOR<LearningPathUpdateWithoutPaymentsInput, LearningPathUncheckedUpdateWithoutPaymentsInput>
  }

  export type LearningPathUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLearningPathsNestedInput
    tags?: LearningPathTagUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: LearningPathTagUncheckedUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUncheckedUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type WorkshopUpsertWithoutPaymentsInput = {
    update: XOR<WorkshopUpdateWithoutPaymentsInput, WorkshopUncheckedUpdateWithoutPaymentsInput>
    create: XOR<WorkshopCreateWithoutPaymentsInput, WorkshopUncheckedCreateWithoutPaymentsInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutPaymentsInput, WorkshopUncheckedUpdateWithoutPaymentsInput>
  }

  export type WorkshopUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutWorkshopsNestedInput
    tags?: WorkshopTagUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: WorkshopTagUncheckedUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUncheckedUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type EnrollmentUpsertWithoutPaymentInput = {
    update: XOR<EnrollmentUpdateWithoutPaymentInput, EnrollmentUncheckedUpdateWithoutPaymentInput>
    create: XOR<EnrollmentCreateWithoutPaymentInput, EnrollmentUncheckedCreateWithoutPaymentInput>
    where?: EnrollmentWhereInput
  }

  export type EnrollmentUpdateToOneWithWhereWithoutPaymentInput = {
    where?: EnrollmentWhereInput
    data: XOR<EnrollmentUpdateWithoutPaymentInput, EnrollmentUncheckedUpdateWithoutPaymentInput>
  }

  export type EnrollmentUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneWithoutEnrollmentsNestedInput
    learningPath?: LearningPathUpdateOneWithoutEnrollmentsNestedInput
    workshop?: WorkshopUpdateOneWithoutEnrollmentsNestedInput
    user?: UserUpdateOneRequiredWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutInvoicesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    workshops?: WorkshopCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    quiz?: QuizCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    workshops?: WorkshopUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    quiz?: QuizUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    title: string
    type: string
    referenceId: string
    quantity?: number
    unitPrice: number
    total: number
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    title: string
    type: string
    referenceId: string
    quantity?: number
    unitPrice: number
    total: number
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    quiz?: QuizUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    quiz?: QuizUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    title?: StringFilter<"InvoiceItem"> | string
    type?: StringFilter<"InvoiceItem"> | string
    referenceId?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: IntFilter<"InvoiceItem"> | number
    total?: IntFilter<"InvoiceItem"> | number
  }

  export type InvoiceCreateWithoutItemsInput = {
    id?: string
    number: string
    amount: number
    currency?: string
    pdfUrl?: string | null
    date?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    number: string
    userId: string
    amount: number
    currency?: string
    pdfUrl?: string | null
    date?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseObjectiveCreateWithoutObjectiveInput = {
    course: CourseCreateNestedOneWithoutObjectivesInput
  }

  export type CourseObjectiveUncheckedCreateWithoutObjectiveInput = {
    courseId: string
  }

  export type CourseObjectiveCreateOrConnectWithoutObjectiveInput = {
    where: CourseObjectiveWhereUniqueInput
    create: XOR<CourseObjectiveCreateWithoutObjectiveInput, CourseObjectiveUncheckedCreateWithoutObjectiveInput>
  }

  export type CourseObjectiveCreateManyObjectiveInputEnvelope = {
    data: CourseObjectiveCreateManyObjectiveInput | CourseObjectiveCreateManyObjectiveInput[]
    skipDuplicates?: boolean
  }

  export type WorkshopObjectiveCreateWithoutObjectiveInput = {
    workshop: WorkshopCreateNestedOneWithoutObjectivesInput
  }

  export type WorkshopObjectiveUncheckedCreateWithoutObjectiveInput = {
    workshopId: string
  }

  export type WorkshopObjectiveCreateOrConnectWithoutObjectiveInput = {
    where: WorkshopObjectiveWhereUniqueInput
    create: XOR<WorkshopObjectiveCreateWithoutObjectiveInput, WorkshopObjectiveUncheckedCreateWithoutObjectiveInput>
  }

  export type WorkshopObjectiveCreateManyObjectiveInputEnvelope = {
    data: WorkshopObjectiveCreateManyObjectiveInput | WorkshopObjectiveCreateManyObjectiveInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathObjectiveCreateWithoutObjectiveInput = {
    learningPath: LearningPathCreateNestedOneWithoutObjectivesInput
  }

  export type LearningPathObjectiveUncheckedCreateWithoutObjectiveInput = {
    learningPathId: string
  }

  export type LearningPathObjectiveCreateOrConnectWithoutObjectiveInput = {
    where: LearningPathObjectiveWhereUniqueInput
    create: XOR<LearningPathObjectiveCreateWithoutObjectiveInput, LearningPathObjectiveUncheckedCreateWithoutObjectiveInput>
  }

  export type LearningPathObjectiveCreateManyObjectiveInputEnvelope = {
    data: LearningPathObjectiveCreateManyObjectiveInput | LearningPathObjectiveCreateManyObjectiveInput[]
    skipDuplicates?: boolean
  }

  export type CourseObjectiveUpsertWithWhereUniqueWithoutObjectiveInput = {
    where: CourseObjectiveWhereUniqueInput
    update: XOR<CourseObjectiveUpdateWithoutObjectiveInput, CourseObjectiveUncheckedUpdateWithoutObjectiveInput>
    create: XOR<CourseObjectiveCreateWithoutObjectiveInput, CourseObjectiveUncheckedCreateWithoutObjectiveInput>
  }

  export type CourseObjectiveUpdateWithWhereUniqueWithoutObjectiveInput = {
    where: CourseObjectiveWhereUniqueInput
    data: XOR<CourseObjectiveUpdateWithoutObjectiveInput, CourseObjectiveUncheckedUpdateWithoutObjectiveInput>
  }

  export type CourseObjectiveUpdateManyWithWhereWithoutObjectiveInput = {
    where: CourseObjectiveScalarWhereInput
    data: XOR<CourseObjectiveUpdateManyMutationInput, CourseObjectiveUncheckedUpdateManyWithoutObjectiveInput>
  }

  export type WorkshopObjectiveUpsertWithWhereUniqueWithoutObjectiveInput = {
    where: WorkshopObjectiveWhereUniqueInput
    update: XOR<WorkshopObjectiveUpdateWithoutObjectiveInput, WorkshopObjectiveUncheckedUpdateWithoutObjectiveInput>
    create: XOR<WorkshopObjectiveCreateWithoutObjectiveInput, WorkshopObjectiveUncheckedCreateWithoutObjectiveInput>
  }

  export type WorkshopObjectiveUpdateWithWhereUniqueWithoutObjectiveInput = {
    where: WorkshopObjectiveWhereUniqueInput
    data: XOR<WorkshopObjectiveUpdateWithoutObjectiveInput, WorkshopObjectiveUncheckedUpdateWithoutObjectiveInput>
  }

  export type WorkshopObjectiveUpdateManyWithWhereWithoutObjectiveInput = {
    where: WorkshopObjectiveScalarWhereInput
    data: XOR<WorkshopObjectiveUpdateManyMutationInput, WorkshopObjectiveUncheckedUpdateManyWithoutObjectiveInput>
  }

  export type LearningPathObjectiveUpsertWithWhereUniqueWithoutObjectiveInput = {
    where: LearningPathObjectiveWhereUniqueInput
    update: XOR<LearningPathObjectiveUpdateWithoutObjectiveInput, LearningPathObjectiveUncheckedUpdateWithoutObjectiveInput>
    create: XOR<LearningPathObjectiveCreateWithoutObjectiveInput, LearningPathObjectiveUncheckedCreateWithoutObjectiveInput>
  }

  export type LearningPathObjectiveUpdateWithWhereUniqueWithoutObjectiveInput = {
    where: LearningPathObjectiveWhereUniqueInput
    data: XOR<LearningPathObjectiveUpdateWithoutObjectiveInput, LearningPathObjectiveUncheckedUpdateWithoutObjectiveInput>
  }

  export type LearningPathObjectiveUpdateManyWithWhereWithoutObjectiveInput = {
    where: LearningPathObjectiveScalarWhereInput
    data: XOR<LearningPathObjectiveUpdateManyMutationInput, LearningPathObjectiveUncheckedUpdateManyWithoutObjectiveInput>
  }

  export type CoursePrerequisiteCreateWithoutPrerequisiteInput = {
    course: CourseCreateNestedOneWithoutPrerequisitesInput
  }

  export type CoursePrerequisiteUncheckedCreateWithoutPrerequisiteInput = {
    courseId: string
  }

  export type CoursePrerequisiteCreateOrConnectWithoutPrerequisiteInput = {
    where: CoursePrerequisiteWhereUniqueInput
    create: XOR<CoursePrerequisiteCreateWithoutPrerequisiteInput, CoursePrerequisiteUncheckedCreateWithoutPrerequisiteInput>
  }

  export type CoursePrerequisiteCreateManyPrerequisiteInputEnvelope = {
    data: CoursePrerequisiteCreateManyPrerequisiteInput | CoursePrerequisiteCreateManyPrerequisiteInput[]
    skipDuplicates?: boolean
  }

  export type WorkshopPrerequisiteCreateWithoutPrerequisiteInput = {
    workshop: WorkshopCreateNestedOneWithoutPrerequisitesInput
  }

  export type WorkshopPrerequisiteUncheckedCreateWithoutPrerequisiteInput = {
    workshopId: string
  }

  export type WorkshopPrerequisiteCreateOrConnectWithoutPrerequisiteInput = {
    where: WorkshopPrerequisiteWhereUniqueInput
    create: XOR<WorkshopPrerequisiteCreateWithoutPrerequisiteInput, WorkshopPrerequisiteUncheckedCreateWithoutPrerequisiteInput>
  }

  export type WorkshopPrerequisiteCreateManyPrerequisiteInputEnvelope = {
    data: WorkshopPrerequisiteCreateManyPrerequisiteInput | WorkshopPrerequisiteCreateManyPrerequisiteInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathPrerequisiteCreateWithoutPrerequisiteInput = {
    learningPath: LearningPathCreateNestedOneWithoutPrerequisitesInput
  }

  export type LearningPathPrerequisiteUncheckedCreateWithoutPrerequisiteInput = {
    learningPathId: string
  }

  export type LearningPathPrerequisiteCreateOrConnectWithoutPrerequisiteInput = {
    where: LearningPathPrerequisiteWhereUniqueInput
    create: XOR<LearningPathPrerequisiteCreateWithoutPrerequisiteInput, LearningPathPrerequisiteUncheckedCreateWithoutPrerequisiteInput>
  }

  export type LearningPathPrerequisiteCreateManyPrerequisiteInputEnvelope = {
    data: LearningPathPrerequisiteCreateManyPrerequisiteInput | LearningPathPrerequisiteCreateManyPrerequisiteInput[]
    skipDuplicates?: boolean
  }

  export type CoursePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput = {
    where: CoursePrerequisiteWhereUniqueInput
    update: XOR<CoursePrerequisiteUpdateWithoutPrerequisiteInput, CoursePrerequisiteUncheckedUpdateWithoutPrerequisiteInput>
    create: XOR<CoursePrerequisiteCreateWithoutPrerequisiteInput, CoursePrerequisiteUncheckedCreateWithoutPrerequisiteInput>
  }

  export type CoursePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput = {
    where: CoursePrerequisiteWhereUniqueInput
    data: XOR<CoursePrerequisiteUpdateWithoutPrerequisiteInput, CoursePrerequisiteUncheckedUpdateWithoutPrerequisiteInput>
  }

  export type CoursePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput = {
    where: CoursePrerequisiteScalarWhereInput
    data: XOR<CoursePrerequisiteUpdateManyMutationInput, CoursePrerequisiteUncheckedUpdateManyWithoutPrerequisiteInput>
  }

  export type WorkshopPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput = {
    where: WorkshopPrerequisiteWhereUniqueInput
    update: XOR<WorkshopPrerequisiteUpdateWithoutPrerequisiteInput, WorkshopPrerequisiteUncheckedUpdateWithoutPrerequisiteInput>
    create: XOR<WorkshopPrerequisiteCreateWithoutPrerequisiteInput, WorkshopPrerequisiteUncheckedCreateWithoutPrerequisiteInput>
  }

  export type WorkshopPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput = {
    where: WorkshopPrerequisiteWhereUniqueInput
    data: XOR<WorkshopPrerequisiteUpdateWithoutPrerequisiteInput, WorkshopPrerequisiteUncheckedUpdateWithoutPrerequisiteInput>
  }

  export type WorkshopPrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput = {
    where: WorkshopPrerequisiteScalarWhereInput
    data: XOR<WorkshopPrerequisiteUpdateManyMutationInput, WorkshopPrerequisiteUncheckedUpdateManyWithoutPrerequisiteInput>
  }

  export type LearningPathPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput = {
    where: LearningPathPrerequisiteWhereUniqueInput
    update: XOR<LearningPathPrerequisiteUpdateWithoutPrerequisiteInput, LearningPathPrerequisiteUncheckedUpdateWithoutPrerequisiteInput>
    create: XOR<LearningPathPrerequisiteCreateWithoutPrerequisiteInput, LearningPathPrerequisiteUncheckedCreateWithoutPrerequisiteInput>
  }

  export type LearningPathPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput = {
    where: LearningPathPrerequisiteWhereUniqueInput
    data: XOR<LearningPathPrerequisiteUpdateWithoutPrerequisiteInput, LearningPathPrerequisiteUncheckedUpdateWithoutPrerequisiteInput>
  }

  export type LearningPathPrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput = {
    where: LearningPathPrerequisiteScalarWhereInput
    data: XOR<LearningPathPrerequisiteUpdateManyMutationInput, LearningPathPrerequisiteUncheckedUpdateManyWithoutPrerequisiteInput>
  }

  export type CourseCreateWithoutObjectivesInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCoursesInput
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    category: CategoryCreateNestedOneWithoutCoursesInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    promotions?: PromotionCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    progress?: UserProgressCreateNestedManyWithoutCourseInput
    resources?: CourseResourceCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutObjectivesInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    categoryId: string
    deletedAt?: Date | string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutCourseInput
    resources?: CourseResourceUncheckedCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutCourseInput
    prerequisites?: CoursePrerequisiteUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutObjectivesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutObjectivesInput, CourseUncheckedCreateWithoutObjectivesInput>
  }

  export type ObjectiveCreateWithoutCoursesInput = {
    id?: string
    content: string
    createdAt?: Date | string
    workshops?: WorkshopObjectiveCreateNestedManyWithoutObjectiveInput
    learningPaths?: LearningPathObjectiveCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutCoursesInput = {
    id?: string
    content: string
    createdAt?: Date | string
    workshops?: WorkshopObjectiveUncheckedCreateNestedManyWithoutObjectiveInput
    learningPaths?: LearningPathObjectiveUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutCoursesInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutCoursesInput, ObjectiveUncheckedCreateWithoutCoursesInput>
  }

  export type CourseUpsertWithoutObjectivesInput = {
    update: XOR<CourseUpdateWithoutObjectivesInput, CourseUncheckedUpdateWithoutObjectivesInput>
    create: XOR<CourseCreateWithoutObjectivesInput, CourseUncheckedCreateWithoutObjectivesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutObjectivesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutObjectivesInput, CourseUncheckedUpdateWithoutObjectivesInput>
  }

  export type CourseUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCoursesNestedInput
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUncheckedUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ObjectiveUpsertWithoutCoursesInput = {
    update: XOR<ObjectiveUpdateWithoutCoursesInput, ObjectiveUncheckedUpdateWithoutCoursesInput>
    create: XOR<ObjectiveCreateWithoutCoursesInput, ObjectiveUncheckedCreateWithoutCoursesInput>
    where?: ObjectiveWhereInput
  }

  export type ObjectiveUpdateToOneWithWhereWithoutCoursesInput = {
    where?: ObjectiveWhereInput
    data: XOR<ObjectiveUpdateWithoutCoursesInput, ObjectiveUncheckedUpdateWithoutCoursesInput>
  }

  export type ObjectiveUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workshops?: WorkshopObjectiveUpdateManyWithoutObjectiveNestedInput
    learningPaths?: LearningPathObjectiveUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workshops?: WorkshopObjectiveUncheckedUpdateManyWithoutObjectiveNestedInput
    learningPaths?: LearningPathObjectiveUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type CourseCreateWithoutPrerequisitesInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCoursesInput
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    category: CategoryCreateNestedOneWithoutCoursesInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    promotions?: PromotionCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    progress?: UserProgressCreateNestedManyWithoutCourseInput
    resources?: CourseResourceCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPrerequisitesInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    categoryId: string
    deletedAt?: Date | string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCourseInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableCoursesInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutCourseInput
    resources?: CourseResourceUncheckedCreateNestedManyWithoutCourseInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutCourseInput
    objectives?: CourseObjectiveUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPrerequisitesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPrerequisitesInput, CourseUncheckedCreateWithoutPrerequisitesInput>
  }

  export type PrerequisiteCreateWithoutCoursesInput = {
    id?: string
    content: string
    createdAt?: Date | string
    workshops?: WorkshopPrerequisiteCreateNestedManyWithoutPrerequisiteInput
    learningPaths?: LearningPathPrerequisiteCreateNestedManyWithoutPrerequisiteInput
  }

  export type PrerequisiteUncheckedCreateWithoutCoursesInput = {
    id?: string
    content: string
    createdAt?: Date | string
    workshops?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    learningPaths?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
  }

  export type PrerequisiteCreateOrConnectWithoutCoursesInput = {
    where: PrerequisiteWhereUniqueInput
    create: XOR<PrerequisiteCreateWithoutCoursesInput, PrerequisiteUncheckedCreateWithoutCoursesInput>
  }

  export type CourseUpsertWithoutPrerequisitesInput = {
    update: XOR<CourseUpdateWithoutPrerequisitesInput, CourseUncheckedUpdateWithoutPrerequisitesInput>
    create: XOR<CourseCreateWithoutPrerequisitesInput, CourseUncheckedCreateWithoutPrerequisitesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutPrerequisitesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutPrerequisitesInput, CourseUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type CourseUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCoursesNestedInput
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUncheckedUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type PrerequisiteUpsertWithoutCoursesInput = {
    update: XOR<PrerequisiteUpdateWithoutCoursesInput, PrerequisiteUncheckedUpdateWithoutCoursesInput>
    create: XOR<PrerequisiteCreateWithoutCoursesInput, PrerequisiteUncheckedCreateWithoutCoursesInput>
    where?: PrerequisiteWhereInput
  }

  export type PrerequisiteUpdateToOneWithWhereWithoutCoursesInput = {
    where?: PrerequisiteWhereInput
    data: XOR<PrerequisiteUpdateWithoutCoursesInput, PrerequisiteUncheckedUpdateWithoutCoursesInput>
  }

  export type PrerequisiteUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workshops?: WorkshopPrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    learningPaths?: LearningPathPrerequisiteUpdateManyWithoutPrerequisiteNestedInput
  }

  export type PrerequisiteUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workshops?: WorkshopPrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    learningPaths?: LearningPathPrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
  }

  export type WorkshopCreateWithoutObjectivesInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutWorkshopsInput
    tags?: WorkshopTagCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentCreateNestedManyWithoutWorkshopInput
    payments?: PaymentCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutObjectivesInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: WorkshopTagUncheckedCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceUncheckedCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutWorkshopInput
    prerequisites?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutWorkshopInput
    payments?: PaymentUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutObjectivesInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutObjectivesInput, WorkshopUncheckedCreateWithoutObjectivesInput>
  }

  export type ObjectiveCreateWithoutWorkshopsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    courses?: CourseObjectiveCreateNestedManyWithoutObjectiveInput
    learningPaths?: LearningPathObjectiveCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutWorkshopsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    courses?: CourseObjectiveUncheckedCreateNestedManyWithoutObjectiveInput
    learningPaths?: LearningPathObjectiveUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutWorkshopsInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutWorkshopsInput, ObjectiveUncheckedCreateWithoutWorkshopsInput>
  }

  export type WorkshopUpsertWithoutObjectivesInput = {
    update: XOR<WorkshopUpdateWithoutObjectivesInput, WorkshopUncheckedUpdateWithoutObjectivesInput>
    create: XOR<WorkshopCreateWithoutObjectivesInput, WorkshopUncheckedCreateWithoutObjectivesInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutObjectivesInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutObjectivesInput, WorkshopUncheckedUpdateWithoutObjectivesInput>
  }

  export type WorkshopUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutWorkshopsNestedInput
    tags?: WorkshopTagUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: WorkshopTagUncheckedUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUncheckedUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type ObjectiveUpsertWithoutWorkshopsInput = {
    update: XOR<ObjectiveUpdateWithoutWorkshopsInput, ObjectiveUncheckedUpdateWithoutWorkshopsInput>
    create: XOR<ObjectiveCreateWithoutWorkshopsInput, ObjectiveUncheckedCreateWithoutWorkshopsInput>
    where?: ObjectiveWhereInput
  }

  export type ObjectiveUpdateToOneWithWhereWithoutWorkshopsInput = {
    where?: ObjectiveWhereInput
    data: XOR<ObjectiveUpdateWithoutWorkshopsInput, ObjectiveUncheckedUpdateWithoutWorkshopsInput>
  }

  export type ObjectiveUpdateWithoutWorkshopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseObjectiveUpdateManyWithoutObjectiveNestedInput
    learningPaths?: LearningPathObjectiveUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutWorkshopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseObjectiveUncheckedUpdateManyWithoutObjectiveNestedInput
    learningPaths?: LearningPathObjectiveUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type WorkshopCreateWithoutPrerequisitesInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutWorkshopsInput
    tags?: WorkshopTagCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentCreateNestedManyWithoutWorkshopInput
    payments?: PaymentCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutPrerequisitesInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: WorkshopTagUncheckedCreateNestedManyWithoutWorkshopInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutWorkshopInput
    resources?: WorkshopResourceUncheckedCreateNestedManyWithoutWorkshopInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutWorkshopInput
    objectives?: WorkshopObjectiveUncheckedCreateNestedManyWithoutWorkshopInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableWorkshopsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutWorkshopInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutWorkshopInput
    payments?: PaymentUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutPrerequisitesInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutPrerequisitesInput, WorkshopUncheckedCreateWithoutPrerequisitesInput>
  }

  export type PrerequisiteCreateWithoutWorkshopsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    courses?: CoursePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    learningPaths?: LearningPathPrerequisiteCreateNestedManyWithoutPrerequisiteInput
  }

  export type PrerequisiteUncheckedCreateWithoutWorkshopsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    courses?: CoursePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    learningPaths?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
  }

  export type PrerequisiteCreateOrConnectWithoutWorkshopsInput = {
    where: PrerequisiteWhereUniqueInput
    create: XOR<PrerequisiteCreateWithoutWorkshopsInput, PrerequisiteUncheckedCreateWithoutWorkshopsInput>
  }

  export type WorkshopUpsertWithoutPrerequisitesInput = {
    update: XOR<WorkshopUpdateWithoutPrerequisitesInput, WorkshopUncheckedUpdateWithoutPrerequisitesInput>
    create: XOR<WorkshopCreateWithoutPrerequisitesInput, WorkshopUncheckedCreateWithoutPrerequisitesInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutPrerequisitesInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutPrerequisitesInput, WorkshopUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type WorkshopUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutWorkshopsNestedInput
    tags?: WorkshopTagUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: WorkshopTagUncheckedUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUncheckedUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type PrerequisiteUpsertWithoutWorkshopsInput = {
    update: XOR<PrerequisiteUpdateWithoutWorkshopsInput, PrerequisiteUncheckedUpdateWithoutWorkshopsInput>
    create: XOR<PrerequisiteCreateWithoutWorkshopsInput, PrerequisiteUncheckedCreateWithoutWorkshopsInput>
    where?: PrerequisiteWhereInput
  }

  export type PrerequisiteUpdateToOneWithWhereWithoutWorkshopsInput = {
    where?: PrerequisiteWhereInput
    data: XOR<PrerequisiteUpdateWithoutWorkshopsInput, PrerequisiteUncheckedUpdateWithoutWorkshopsInput>
  }

  export type PrerequisiteUpdateWithoutWorkshopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CoursePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    learningPaths?: LearningPathPrerequisiteUpdateManyWithoutPrerequisiteNestedInput
  }

  export type PrerequisiteUncheckedUpdateWithoutWorkshopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CoursePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    learningPaths?: LearningPathPrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
  }

  export type LearningPathCreateWithoutObjectivesInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLearningPathsInput
    tags?: LearningPathTagCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearningPathInput
    payments?: PaymentCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutObjectivesInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: LearningPathTagUncheckedCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: LearningPathPrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearningPathInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutObjectivesInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutObjectivesInput, LearningPathUncheckedCreateWithoutObjectivesInput>
  }

  export type ObjectiveCreateWithoutLearningPathsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    courses?: CourseObjectiveCreateNestedManyWithoutObjectiveInput
    workshops?: WorkshopObjectiveCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutLearningPathsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    courses?: CourseObjectiveUncheckedCreateNestedManyWithoutObjectiveInput
    workshops?: WorkshopObjectiveUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutLearningPathsInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutLearningPathsInput, ObjectiveUncheckedCreateWithoutLearningPathsInput>
  }

  export type LearningPathUpsertWithoutObjectivesInput = {
    update: XOR<LearningPathUpdateWithoutObjectivesInput, LearningPathUncheckedUpdateWithoutObjectivesInput>
    create: XOR<LearningPathCreateWithoutObjectivesInput, LearningPathUncheckedCreateWithoutObjectivesInput>
    where?: LearningPathWhereInput
  }

  export type LearningPathUpdateToOneWithWhereWithoutObjectivesInput = {
    where?: LearningPathWhereInput
    data: XOR<LearningPathUpdateWithoutObjectivesInput, LearningPathUncheckedUpdateWithoutObjectivesInput>
  }

  export type LearningPathUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLearningPathsNestedInput
    tags?: LearningPathTagUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: LearningPathTagUncheckedUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type ObjectiveUpsertWithoutLearningPathsInput = {
    update: XOR<ObjectiveUpdateWithoutLearningPathsInput, ObjectiveUncheckedUpdateWithoutLearningPathsInput>
    create: XOR<ObjectiveCreateWithoutLearningPathsInput, ObjectiveUncheckedCreateWithoutLearningPathsInput>
    where?: ObjectiveWhereInput
  }

  export type ObjectiveUpdateToOneWithWhereWithoutLearningPathsInput = {
    where?: ObjectiveWhereInput
    data: XOR<ObjectiveUpdateWithoutLearningPathsInput, ObjectiveUncheckedUpdateWithoutLearningPathsInput>
  }

  export type ObjectiveUpdateWithoutLearningPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseObjectiveUpdateManyWithoutObjectiveNestedInput
    workshops?: WorkshopObjectiveUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutLearningPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseObjectiveUncheckedUpdateManyWithoutObjectiveNestedInput
    workshops?: WorkshopObjectiveUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type LearningPathCreateWithoutPrerequisitesInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLearningPathsInput
    tags?: LearningPathTagCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearningPathInput
    payments?: PaymentCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutPrerequisitesInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
    tags?: LearningPathTagUncheckedCreateNestedManyWithoutLearningPathInput
    contents?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutPathInput
    resources?: LearningPathResourceUncheckedCreateNestedManyWithoutLearningPathInput
    objectives?: LearningPathObjectiveUncheckedCreateNestedManyWithoutLearningPathInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutApplicableLearningPathsInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutLearningPathInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearningPathInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutPrerequisitesInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutPrerequisitesInput, LearningPathUncheckedCreateWithoutPrerequisitesInput>
  }

  export type PrerequisiteCreateWithoutLearningPathsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    courses?: CoursePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    workshops?: WorkshopPrerequisiteCreateNestedManyWithoutPrerequisiteInput
  }

  export type PrerequisiteUncheckedCreateWithoutLearningPathsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    courses?: CoursePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    workshops?: WorkshopPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
  }

  export type PrerequisiteCreateOrConnectWithoutLearningPathsInput = {
    where: PrerequisiteWhereUniqueInput
    create: XOR<PrerequisiteCreateWithoutLearningPathsInput, PrerequisiteUncheckedCreateWithoutLearningPathsInput>
  }

  export type LearningPathUpsertWithoutPrerequisitesInput = {
    update: XOR<LearningPathUpdateWithoutPrerequisitesInput, LearningPathUncheckedUpdateWithoutPrerequisitesInput>
    create: XOR<LearningPathCreateWithoutPrerequisitesInput, LearningPathUncheckedCreateWithoutPrerequisitesInput>
    where?: LearningPathWhereInput
  }

  export type LearningPathUpdateToOneWithWhereWithoutPrerequisitesInput = {
    where?: LearningPathWhereInput
    data: XOR<LearningPathUpdateWithoutPrerequisitesInput, LearningPathUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type LearningPathUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLearningPathsNestedInput
    tags?: LearningPathTagUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: LearningPathTagUncheckedUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUncheckedUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type PrerequisiteUpsertWithoutLearningPathsInput = {
    update: XOR<PrerequisiteUpdateWithoutLearningPathsInput, PrerequisiteUncheckedUpdateWithoutLearningPathsInput>
    create: XOR<PrerequisiteCreateWithoutLearningPathsInput, PrerequisiteUncheckedCreateWithoutLearningPathsInput>
    where?: PrerequisiteWhereInput
  }

  export type PrerequisiteUpdateToOneWithWhereWithoutLearningPathsInput = {
    where?: PrerequisiteWhereInput
    data: XOR<PrerequisiteUpdateWithoutLearningPathsInput, PrerequisiteUncheckedUpdateWithoutLearningPathsInput>
  }

  export type PrerequisiteUpdateWithoutLearningPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CoursePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    workshops?: WorkshopPrerequisiteUpdateManyWithoutPrerequisiteNestedInput
  }

  export type PrerequisiteUncheckedUpdateWithoutLearningPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CoursePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    workshops?: WorkshopPrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
  }

  export type CompanySocialLinkCreateWithoutCompanyInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    socialLink: SocialLinkCreateNestedOneWithoutCompanySocialLinkInput
  }

  export type CompanySocialLinkUncheckedCreateWithoutCompanyInput = {
    id?: string
    socialLinkId: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanySocialLinkCreateOrConnectWithoutCompanyInput = {
    where: CompanySocialLinkWhereUniqueInput
    create: XOR<CompanySocialLinkCreateWithoutCompanyInput, CompanySocialLinkUncheckedCreateWithoutCompanyInput>
  }

  export type CompanySocialLinkCreateManyCompanyInputEnvelope = {
    data: CompanySocialLinkCreateManyCompanyInput | CompanySocialLinkCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanySocialLinkUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanySocialLinkWhereUniqueInput
    update: XOR<CompanySocialLinkUpdateWithoutCompanyInput, CompanySocialLinkUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanySocialLinkCreateWithoutCompanyInput, CompanySocialLinkUncheckedCreateWithoutCompanyInput>
  }

  export type CompanySocialLinkUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanySocialLinkWhereUniqueInput
    data: XOR<CompanySocialLinkUpdateWithoutCompanyInput, CompanySocialLinkUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanySocialLinkUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanySocialLinkScalarWhereInput
    data: XOR<CompanySocialLinkUpdateManyMutationInput, CompanySocialLinkUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanySocialLinkScalarWhereInput = {
    AND?: CompanySocialLinkScalarWhereInput | CompanySocialLinkScalarWhereInput[]
    OR?: CompanySocialLinkScalarWhereInput[]
    NOT?: CompanySocialLinkScalarWhereInput | CompanySocialLinkScalarWhereInput[]
    id?: StringFilter<"CompanySocialLink"> | string
    companyId?: StringFilter<"CompanySocialLink"> | string
    socialLinkId?: StringFilter<"CompanySocialLink"> | string
    url?: StringFilter<"CompanySocialLink"> | string
    createdAt?: DateTimeFilter<"CompanySocialLink"> | Date | string
    updatedAt?: DateTimeFilter<"CompanySocialLink"> | Date | string
  }

  export type CompanySocialLinkCreateWithoutSocialLinkInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCompanySocialLinkInput
  }

  export type CompanySocialLinkUncheckedCreateWithoutSocialLinkInput = {
    id?: string
    companyId: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanySocialLinkCreateOrConnectWithoutSocialLinkInput = {
    where: CompanySocialLinkWhereUniqueInput
    create: XOR<CompanySocialLinkCreateWithoutSocialLinkInput, CompanySocialLinkUncheckedCreateWithoutSocialLinkInput>
  }

  export type CompanySocialLinkCreateManySocialLinkInputEnvelope = {
    data: CompanySocialLinkCreateManySocialLinkInput | CompanySocialLinkCreateManySocialLinkInput[]
    skipDuplicates?: boolean
  }

  export type CompanySocialLinkUpsertWithWhereUniqueWithoutSocialLinkInput = {
    where: CompanySocialLinkWhereUniqueInput
    update: XOR<CompanySocialLinkUpdateWithoutSocialLinkInput, CompanySocialLinkUncheckedUpdateWithoutSocialLinkInput>
    create: XOR<CompanySocialLinkCreateWithoutSocialLinkInput, CompanySocialLinkUncheckedCreateWithoutSocialLinkInput>
  }

  export type CompanySocialLinkUpdateWithWhereUniqueWithoutSocialLinkInput = {
    where: CompanySocialLinkWhereUniqueInput
    data: XOR<CompanySocialLinkUpdateWithoutSocialLinkInput, CompanySocialLinkUncheckedUpdateWithoutSocialLinkInput>
  }

  export type CompanySocialLinkUpdateManyWithWhereWithoutSocialLinkInput = {
    where: CompanySocialLinkScalarWhereInput
    data: XOR<CompanySocialLinkUpdateManyMutationInput, CompanySocialLinkUncheckedUpdateManyWithoutSocialLinkInput>
  }

  export type CompanyCreateWithoutCompanySocialLinkInput = {
    id?: string
    name: string
    address: string
    postalCode: string
    city: string
    country: string
    email: string
    phone?: string | null
    siret?: string | null
    vatNumber?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUncheckedCreateWithoutCompanySocialLinkInput = {
    id?: string
    name: string
    address: string
    postalCode: string
    city: string
    country: string
    email: string
    phone?: string | null
    siret?: string | null
    vatNumber?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyCreateOrConnectWithoutCompanySocialLinkInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCompanySocialLinkInput, CompanyUncheckedCreateWithoutCompanySocialLinkInput>
  }

  export type SocialLinkCreateWithoutCompanySocialLinkInput = {
    id?: string
    name: string
    iconLib: string
    iconName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialLinkUncheckedCreateWithoutCompanySocialLinkInput = {
    id?: string
    name: string
    iconLib: string
    iconName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialLinkCreateOrConnectWithoutCompanySocialLinkInput = {
    where: SocialLinkWhereUniqueInput
    create: XOR<SocialLinkCreateWithoutCompanySocialLinkInput, SocialLinkUncheckedCreateWithoutCompanySocialLinkInput>
  }

  export type CompanyUpsertWithoutCompanySocialLinkInput = {
    update: XOR<CompanyUpdateWithoutCompanySocialLinkInput, CompanyUncheckedUpdateWithoutCompanySocialLinkInput>
    create: XOR<CompanyCreateWithoutCompanySocialLinkInput, CompanyUncheckedCreateWithoutCompanySocialLinkInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCompanySocialLinkInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCompanySocialLinkInput, CompanyUncheckedUpdateWithoutCompanySocialLinkInput>
  }

  export type CompanyUpdateWithoutCompanySocialLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateWithoutCompanySocialLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialLinkUpsertWithoutCompanySocialLinkInput = {
    update: XOR<SocialLinkUpdateWithoutCompanySocialLinkInput, SocialLinkUncheckedUpdateWithoutCompanySocialLinkInput>
    create: XOR<SocialLinkCreateWithoutCompanySocialLinkInput, SocialLinkUncheckedCreateWithoutCompanySocialLinkInput>
    where?: SocialLinkWhereInput
  }

  export type SocialLinkUpdateToOneWithWhereWithoutCompanySocialLinkInput = {
    where?: SocialLinkWhereInput
    data: XOR<SocialLinkUpdateWithoutCompanySocialLinkInput, SocialLinkUncheckedUpdateWithoutCompanySocialLinkInput>
  }

  export type SocialLinkUpdateWithoutCompanySocialLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconLib?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialLinkUncheckedUpdateWithoutCompanySocialLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconLib?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionCreateWithoutQuizInput = {
    id?: string
    question: string
    type?: string | null
    options?: QuizOptionCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutQuizInput = {
    id?: string
    question: string
    type?: string | null
    options?: QuizOptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionCreateManyQuizInputEnvelope = {
    data: QuizQuestionCreateManyQuizInput | QuizQuestionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutQuizInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    workshops?: WorkshopCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuizInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    stripeCustomerId?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    enrollment?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    workshops?: WorkshopUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuizInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuizInput, UserUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    update: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    data: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
  }

  export type QuizQuestionUpdateManyWithWhereWithoutQuizInput = {
    where: QuizQuestionScalarWhereInput
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizQuestionScalarWhereInput = {
    AND?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    OR?: QuizQuestionScalarWhereInput[]
    NOT?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    id?: StringFilter<"QuizQuestion"> | string
    question?: StringFilter<"QuizQuestion"> | string
    type?: StringNullableFilter<"QuizQuestion"> | string | null
    quizId?: StringFilter<"QuizQuestion"> | string
  }

  export type UserUpsertWithoutQuizInput = {
    update: XOR<UserUpdateWithoutQuizInput, UserUncheckedUpdateWithoutQuizInput>
    create: XOR<UserCreateWithoutQuizInput, UserUncheckedCreateWithoutQuizInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuizInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuizInput, UserUncheckedUpdateWithoutQuizInput>
  }

  export type UserUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    enrollment?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    workshops?: WorkshopUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuizCreateWithoutQuestionsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type?: string | null
    chapterId?: string | null
    courseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutQuestionsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type?: string | null
    chapterId?: string | null
    courseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type QuizCreateOrConnectWithoutQuestionsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizOptionCreateWithoutQuestionInput = {
    id?: string
    content: string
    isCorrect?: boolean
  }

  export type QuizOptionUncheckedCreateWithoutQuestionInput = {
    id?: string
    content: string
    isCorrect?: boolean
  }

  export type QuizOptionCreateOrConnectWithoutQuestionInput = {
    where: QuizOptionWhereUniqueInput
    create: XOR<QuizOptionCreateWithoutQuestionInput, QuizOptionUncheckedCreateWithoutQuestionInput>
  }

  export type QuizOptionCreateManyQuestionInputEnvelope = {
    data: QuizOptionCreateManyQuestionInput | QuizOptionCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuizUpsertWithoutQuestionsInput = {
    update: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizOptionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuizOptionWhereUniqueInput
    update: XOR<QuizOptionUpdateWithoutQuestionInput, QuizOptionUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuizOptionCreateWithoutQuestionInput, QuizOptionUncheckedCreateWithoutQuestionInput>
  }

  export type QuizOptionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuizOptionWhereUniqueInput
    data: XOR<QuizOptionUpdateWithoutQuestionInput, QuizOptionUncheckedUpdateWithoutQuestionInput>
  }

  export type QuizOptionUpdateManyWithWhereWithoutQuestionInput = {
    where: QuizOptionScalarWhereInput
    data: XOR<QuizOptionUpdateManyMutationInput, QuizOptionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuizOptionScalarWhereInput = {
    AND?: QuizOptionScalarWhereInput | QuizOptionScalarWhereInput[]
    OR?: QuizOptionScalarWhereInput[]
    NOT?: QuizOptionScalarWhereInput | QuizOptionScalarWhereInput[]
    id?: StringFilter<"QuizOption"> | string
    content?: StringFilter<"QuizOption"> | string
    isCorrect?: BoolFilter<"QuizOption"> | boolean
    questionId?: StringFilter<"QuizOption"> | string
  }

  export type QuizQuestionCreateWithoutOptionsInput = {
    id?: string
    question: string
    type?: string | null
    quiz: QuizCreateNestedOneWithoutQuestionsInput
  }

  export type QuizQuestionUncheckedCreateWithoutOptionsInput = {
    id?: string
    question: string
    type?: string | null
    quizId: string
  }

  export type QuizQuestionCreateOrConnectWithoutOptionsInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutOptionsInput, QuizQuestionUncheckedCreateWithoutOptionsInput>
  }

  export type QuizQuestionUpsertWithoutOptionsInput = {
    update: XOR<QuizQuestionUpdateWithoutOptionsInput, QuizQuestionUncheckedUpdateWithoutOptionsInput>
    create: XOR<QuizQuestionCreateWithoutOptionsInput, QuizQuestionUncheckedCreateWithoutOptionsInput>
    where?: QuizQuestionWhereInput
  }

  export type QuizQuestionUpdateToOneWithWhereWithoutOptionsInput = {
    where?: QuizQuestionWhereInput
    data: XOR<QuizQuestionUpdateWithoutOptionsInput, QuizQuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type QuizQuestionUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quizId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type AccountCreateManyUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LessonProgressCreateManyUserInput = {
    id?: string
    completed?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    watchedSeconds?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lessonId: string
  }

  export type EnrollmentCreateManyUserInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: string | null
    learningPathId?: string | null
    workshopId?: string | null
    paymentId?: string | null
    deletedAt?: Date | string | null
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    stripeId: string
    courseId?: string | null
    learningPathId?: string | null
    workshopId?: string | null
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InvoiceCreateManyUserInput = {
    id?: string
    number: string
    amount: number
    currency?: string
    pdfUrl?: string | null
    date?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CourseCreateManyUserInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId: string
    deletedAt?: Date | string | null
  }

  export type LearningPathCreateManyUserInput = {
    id?: string
    title: string
    description: string
    smallDescription: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    slug: string
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkshopCreateManyUserInput = {
    id?: string
    title: string
    description: string
    slug: string
    statement: string
    fileKey: string
    statementsStartFileKey?: string | null
    statementsStartFileUrl?: string | null
    statementVideoKey?: string | null
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId?: string | null
    solution?: string | null
    solutionFileKey?: string | null
    solutionFileUrl?: string | null
    solutionVideoKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ResourceCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    fileKey?: string | null
    url: string
    type: string
    createdAt?: Date | string
  }

  export type QuizCreateManyUserInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type?: string | null
    chapterId?: string | null
    courseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lesson?: LessonUpdateOneRequiredWithoutLessonProgressNestedInput
  }

  export type LessonProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonId?: StringFieldUpdateOperationsInput | string
  }

  export type EnrollmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneWithoutEnrollmentsNestedInput
    learningPath?: LearningPathUpdateOneWithoutEnrollmentsNestedInput
    workshop?: WorkshopUpdateOneWithoutEnrollmentsNestedInput
    payment?: PaymentUpdateOneWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneWithoutPaymentsNestedInput
    learningPath?: LearningPathUpdateOneWithoutPaymentsNestedInput
    workshop?: WorkshopUpdateOneWithoutPaymentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollment?: EnrollmentUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUncheckedUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningPathUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: LearningPathTagUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: LearningPathTagUncheckedUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUncheckedUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkshopUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: WorkshopTagUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: WorkshopTagUncheckedUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUncheckedUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResourceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseResources?: CourseResourceUpdateManyWithoutResourceNestedInput
    lessonResources?: LessonResourceUpdateManyWithoutResourceNestedInput
    workshopResources?: WorkshopResourceUpdateManyWithoutResourceNestedInput
    learningPathResources?: LearningPathResourceUpdateManyWithoutResourceNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseResources?: CourseResourceUncheckedUpdateManyWithoutResourceNestedInput
    lessonResources?: LessonResourceUncheckedUpdateManyWithoutResourceNestedInput
    workshopResources?: WorkshopResourceUncheckedUpdateManyWithoutResourceNestedInput
    learningPathResources?: LearningPathResourceUncheckedUpdateManyWithoutResourceNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyDomainInput = {
    id?: string
    title: string
    slug: string
    desc: string
    color?: string | null
    iconName?: string | null
    iconLib?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CategoryUpdateWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: CourseUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: CourseUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconLib?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseCreateManyCategoryInput = {
    id?: string
    title: string
    slug: string
    smallDescription: string
    description: string
    fileKey: string
    price: number
    currency?: string
    duration: number
    status: string
    level: string
    stripePriceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    deletedAt?: Date | string | null
  }

  export type CourseUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCoursesNestedInput
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCourseNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutApplicableCoursesNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUncheckedUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningPathTagCreateManyLearningPathInput = {
    tagId: string
  }

  export type LearningPathItemCreateManyLearningPathInput = {
    id?: string
    type: string
    position: number
    courseId?: string | null
    workshopId?: string | null
    resourceId?: string | null
  }

  export type UserProgressCreateManyPathInput = {
    id?: string
    userId: string
    type: string
    completed?: boolean
    updatedAt?: Date | string
    progressPercentage?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type LearningPathResourceCreateManyLearningPathInput = {
    resourceId: string
  }

  export type LearningPathObjectiveCreateManyLearningPathInput = {
    objectiveId: string
  }

  export type LearningPathPrerequisiteCreateManyLearningPathInput = {
    prerequisiteId: string
  }

  export type PromotionCreateManyLearningPathInput = {
    id?: string
    title: string
    description?: string | null
    discount: number
    type?: string
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    itemType: string
    courseId?: string | null
    workshopId?: string | null
  }

  export type EnrollmentCreateManyLearningPathInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: string | null
    workshopId?: string | null
    userId: string
    paymentId?: string | null
    deletedAt?: Date | string | null
  }

  export type PaymentCreateManyLearningPathInput = {
    id?: string
    stripeId: string
    userId: string
    courseId?: string | null
    workshopId?: string | null
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LearningPathTagUpdateWithoutLearningPathInput = {
    tag?: TagUpdateOneRequiredWithoutLearningPathTagsNestedInput
  }

  export type LearningPathTagUncheckedUpdateWithoutLearningPathInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathTagUncheckedUpdateManyWithoutLearningPathInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathItemUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneWithoutLearningPathItemsNestedInput
    workshop?: WorkshopUpdateOneWithoutLearningPathItemsNestedInput
    resource?: ResourceUpdateOneWithoutLearningPathItemsNestedInput
  }

  export type LearningPathItemUncheckedUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LearningPathItemUncheckedUpdateManyWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProgressUpdateWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    course?: CourseUpdateOneWithoutProgressNestedInput
    workshop?: WorkshopUpdateOneWithoutProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserProgressUncheckedUpdateManyWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LearningPathResourceUpdateWithoutLearningPathInput = {
    resource?: ResourceUpdateOneRequiredWithoutLearningPathResourcesNestedInput
  }

  export type LearningPathResourceUncheckedUpdateWithoutLearningPathInput = {
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathResourceUncheckedUpdateManyWithoutLearningPathInput = {
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathObjectiveUpdateWithoutLearningPathInput = {
    objective?: ObjectiveUpdateOneRequiredWithoutLearningPathsNestedInput
  }

  export type LearningPathObjectiveUncheckedUpdateWithoutLearningPathInput = {
    objectiveId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathInput = {
    objectiveId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathPrerequisiteUpdateWithoutLearningPathInput = {
    prerequisite?: PrerequisiteUpdateOneRequiredWithoutLearningPathsNestedInput
  }

  export type LearningPathPrerequisiteUncheckedUpdateWithoutLearningPathInput = {
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathInput = {
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type PromoCodeUpdateWithoutApplicableLearningPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    applicableCourses?: CourseUpdateManyWithoutPromoCodesNestedInput
    applicableWorkshops?: WorkshopUpdateManyWithoutPromoCodesNestedInput
  }

  export type PromoCodeUncheckedUpdateWithoutApplicableLearningPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    applicableCourses?: CourseUncheckedUpdateManyWithoutPromoCodesNestedInput
    applicableWorkshops?: WorkshopUncheckedUpdateManyWithoutPromoCodesNestedInput
  }

  export type PromoCodeUncheckedUpdateManyWithoutApplicableLearningPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromotionUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    itemType?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneWithoutPromotionsNestedInput
    workshop?: WorkshopUpdateOneWithoutPromotionsNestedInput
  }

  export type PromotionUncheckedUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    itemType?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionUncheckedUpdateManyWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    itemType?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnrollmentUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneWithoutEnrollmentsNestedInput
    workshop?: WorkshopUpdateOneWithoutEnrollmentsNestedInput
    user?: UserUpdateOneRequiredWithoutEnrollmentNestedInput
    payment?: PaymentUpdateOneWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentUncheckedUpdateManyWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    course?: CourseUpdateOneWithoutPaymentsNestedInput
    workshop?: WorkshopUpdateOneWithoutPaymentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollment?: EnrollmentUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChapterCreateManyCourseInput = {
    id?: string
    title: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateManyCourseInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    learningPathId?: string | null
    workshopId?: string | null
    userId: string
    paymentId?: string | null
    deletedAt?: Date | string | null
  }

  export type PaymentCreateManyCourseInput = {
    id?: string
    stripeId: string
    userId: string
    learningPathId?: string | null
    workshopId?: string | null
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PromotionCreateManyCourseInput = {
    id?: string
    title: string
    description?: string | null
    discount: number
    type?: string
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    itemType: string
    workshopId?: string | null
    learningPathId?: string | null
  }

  export type CourseTagCreateManyCourseInput = {
    tagId: string
  }

  export type UserProgressCreateManyCourseInput = {
    id?: string
    userId: string
    type: string
    completed?: boolean
    updatedAt?: Date | string
    progressPercentage?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type CourseResourceCreateManyCourseInput = {
    resourceId: string
  }

  export type LearningPathItemCreateManyCourseInput = {
    id?: string
    type: string
    position: number
    learningPathId: string
    workshopId?: string | null
    resourceId?: string | null
  }

  export type CourseObjectiveCreateManyCourseInput = {
    objectiveId: string
  }

  export type CoursePrerequisiteCreateManyCourseInput = {
    prerequisiteId: string
  }

  export type ChapterUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    learningPath?: LearningPathUpdateOneWithoutEnrollmentsNestedInput
    workshop?: WorkshopUpdateOneWithoutEnrollmentsNestedInput
    user?: UserUpdateOneRequiredWithoutEnrollmentNestedInput
    payment?: PaymentUpdateOneWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    learningPath?: LearningPathUpdateOneWithoutPaymentsNestedInput
    workshop?: WorkshopUpdateOneWithoutPaymentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollment?: EnrollmentUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PromotionUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    itemType?: StringFieldUpdateOperationsInput | string
    workshop?: WorkshopUpdateOneWithoutPromotionsNestedInput
    learningPath?: LearningPathUpdateOneWithoutPromotionsNestedInput
  }

  export type PromotionUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    itemType?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    itemType?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromoCodeUpdateWithoutApplicableCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    applicableWorkshops?: WorkshopUpdateManyWithoutPromoCodesNestedInput
    applicableLearningPaths?: LearningPathUpdateManyWithoutPromoCodesNestedInput
  }

  export type PromoCodeUncheckedUpdateWithoutApplicableCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    applicableWorkshops?: WorkshopUncheckedUpdateManyWithoutPromoCodesNestedInput
    applicableLearningPaths?: LearningPathUncheckedUpdateManyWithoutPromoCodesNestedInput
  }

  export type PromoCodeUncheckedUpdateManyWithoutApplicableCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseTagUpdateWithoutCourseInput = {
    tag?: TagUpdateOneRequiredWithoutCourseTagsNestedInput
  }

  export type CourseTagUncheckedUpdateWithoutCourseInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTagUncheckedUpdateManyWithoutCourseInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type UserProgressUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    workshop?: WorkshopUpdateOneWithoutProgressNestedInput
    path?: LearningPathUpdateOneWithoutProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserProgressUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourseResourceUpdateWithoutCourseInput = {
    resource?: ResourceUpdateOneRequiredWithoutCourseResourcesNestedInput
  }

  export type CourseResourceUncheckedUpdateWithoutCourseInput = {
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseResourceUncheckedUpdateManyWithoutCourseInput = {
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathItemUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    learningPath?: LearningPathUpdateOneRequiredWithoutContentsNestedInput
    workshop?: WorkshopUpdateOneWithoutLearningPathItemsNestedInput
    resource?: ResourceUpdateOneWithoutLearningPathItemsNestedInput
  }

  export type LearningPathItemUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LearningPathItemUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseObjectiveUpdateWithoutCourseInput = {
    objective?: ObjectiveUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseObjectiveUncheckedUpdateWithoutCourseInput = {
    objectiveId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseObjectiveUncheckedUpdateManyWithoutCourseInput = {
    objectiveId?: StringFieldUpdateOperationsInput | string
  }

  export type CoursePrerequisiteUpdateWithoutCourseInput = {
    prerequisite?: PrerequisiteUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CoursePrerequisiteUncheckedUpdateWithoutCourseInput = {
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CoursePrerequisiteUncheckedUpdateManyWithoutCourseInput = {
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonCreateManyChapterInput = {
    id?: string
    title: string
    description?: string | null
    thumbnailKey?: string | null
    videoKey?: string | null
    position: number
    duration?: number
    public?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailKey?: NullableStringFieldUpdateOperationsInput | string | null
    videoKey?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonProgress?: LessonProgressUpdateManyWithoutLessonNestedInput
    resources?: LessonResourceUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailKey?: NullableStringFieldUpdateOperationsInput | string | null
    videoKey?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    resources?: LessonResourceUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailKey?: NullableStringFieldUpdateOperationsInput | string | null
    videoKey?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressCreateManyLessonInput = {
    id?: string
    completed?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    watchedSeconds?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type LessonResourceCreateManyLessonInput = {
    resourceId: string
  }

  export type LessonProgressUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLessonProgressNestedInput
  }

  export type LessonProgressUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonProgressUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonResourceUpdateWithoutLessonInput = {
    resource?: ResourceUpdateOneRequiredWithoutLessonResourcesNestedInput
  }

  export type LessonResourceUncheckedUpdateWithoutLessonInput = {
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonResourceUncheckedUpdateManyWithoutLessonInput = {
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopTagCreateManyWorkshopInput = {
    tagId: string
  }

  export type UserProgressCreateManyWorkshopInput = {
    id?: string
    userId: string
    type: string
    completed?: boolean
    updatedAt?: Date | string
    progressPercentage?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type WorkshopResourceCreateManyWorkshopInput = {
    resourceId: string
  }

  export type LearningPathItemCreateManyWorkshopInput = {
    id?: string
    type: string
    position: number
    learningPathId: string
    courseId?: string | null
    resourceId?: string | null
  }

  export type WorkshopObjectiveCreateManyWorkshopInput = {
    objectiveId: string
  }

  export type WorkshopPrerequisiteCreateManyWorkshopInput = {
    prerequisiteId: string
  }

  export type PromotionCreateManyWorkshopInput = {
    id?: string
    title: string
    description?: string | null
    discount: number
    type?: string
    startsAt: Date | string
    endsAt: Date | string
    active?: boolean
    itemType: string
    courseId?: string | null
    learningPathId?: string | null
  }

  export type EnrollmentCreateManyWorkshopInput = {
    id?: string
    amount: number
    status?: $Enums.enrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: string | null
    learningPathId?: string | null
    userId: string
    paymentId?: string | null
    deletedAt?: Date | string | null
  }

  export type PaymentCreateManyWorkshopInput = {
    id?: string
    stripeId: string
    userId: string
    courseId?: string | null
    learningPathId?: string | null
    amount: number
    currency: string
    status: string
    method?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkshopTagUpdateWithoutWorkshopInput = {
    tag?: TagUpdateOneRequiredWithoutWorkshopTagsNestedInput
  }

  export type WorkshopTagUncheckedUpdateWithoutWorkshopInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopTagUncheckedUpdateManyWithoutWorkshopInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type UserProgressUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    course?: CourseUpdateOneWithoutProgressNestedInput
    path?: LearningPathUpdateOneWithoutProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserProgressUncheckedUpdateManyWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WorkshopResourceUpdateWithoutWorkshopInput = {
    resource?: ResourceUpdateOneRequiredWithoutWorkshopResourcesNestedInput
  }

  export type WorkshopResourceUncheckedUpdateWithoutWorkshopInput = {
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopResourceUncheckedUpdateManyWithoutWorkshopInput = {
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathItemUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    learningPath?: LearningPathUpdateOneRequiredWithoutContentsNestedInput
    course?: CourseUpdateOneWithoutLearningPathItemsNestedInput
    resource?: ResourceUpdateOneWithoutLearningPathItemsNestedInput
  }

  export type LearningPathItemUncheckedUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LearningPathItemUncheckedUpdateManyWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkshopObjectiveUpdateWithoutWorkshopInput = {
    objective?: ObjectiveUpdateOneRequiredWithoutWorkshopsNestedInput
  }

  export type WorkshopObjectiveUncheckedUpdateWithoutWorkshopInput = {
    objectiveId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopInput = {
    objectiveId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopPrerequisiteUpdateWithoutWorkshopInput = {
    prerequisite?: PrerequisiteUpdateOneRequiredWithoutWorkshopsNestedInput
  }

  export type WorkshopPrerequisiteUncheckedUpdateWithoutWorkshopInput = {
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopInput = {
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type PromoCodeUpdateWithoutApplicableWorkshopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    applicableCourses?: CourseUpdateManyWithoutPromoCodesNestedInput
    applicableLearningPaths?: LearningPathUpdateManyWithoutPromoCodesNestedInput
  }

  export type PromoCodeUncheckedUpdateWithoutApplicableWorkshopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    applicableCourses?: CourseUncheckedUpdateManyWithoutPromoCodesNestedInput
    applicableLearningPaths?: LearningPathUncheckedUpdateManyWithoutPromoCodesNestedInput
  }

  export type PromoCodeUncheckedUpdateManyWithoutApplicableWorkshopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromotionUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    itemType?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneWithoutPromotionsNestedInput
    learningPath?: LearningPathUpdateOneWithoutPromotionsNestedInput
  }

  export type PromotionUncheckedUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    itemType?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionUncheckedUpdateManyWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    itemType?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnrollmentUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneWithoutEnrollmentsNestedInput
    learningPath?: LearningPathUpdateOneWithoutEnrollmentsNestedInput
    user?: UserUpdateOneRequiredWithoutEnrollmentNestedInput
    payment?: PaymentUpdateOneWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentUncheckedUpdateManyWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumenrollmentStatusFieldUpdateOperationsInput | $Enums.enrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    course?: CourseUpdateOneWithoutPaymentsNestedInput
    learningPath?: LearningPathUpdateOneWithoutPaymentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollment?: EnrollmentUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseResourceCreateManyResourceInput = {
    courseId: string
  }

  export type LessonResourceCreateManyResourceInput = {
    lessonId: string
  }

  export type WorkshopResourceCreateManyResourceInput = {
    workshopId: string
  }

  export type LearningPathResourceCreateManyResourceInput = {
    learningPathId: string
  }

  export type LearningPathItemCreateManyResourceInput = {
    id?: string
    type: string
    position: number
    learningPathId: string
    courseId?: string | null
    workshopId?: string | null
  }

  export type CourseResourceUpdateWithoutResourceInput = {
    course?: CourseUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type CourseResourceUncheckedUpdateWithoutResourceInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseResourceUncheckedUpdateManyWithoutResourceInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonResourceUpdateWithoutResourceInput = {
    lesson?: LessonUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type LessonResourceUncheckedUpdateWithoutResourceInput = {
    lessonId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonResourceUncheckedUpdateManyWithoutResourceInput = {
    lessonId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopResourceUpdateWithoutResourceInput = {
    workshop?: WorkshopUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type WorkshopResourceUncheckedUpdateWithoutResourceInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopResourceUncheckedUpdateManyWithoutResourceInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathResourceUpdateWithoutResourceInput = {
    learningPath?: LearningPathUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type LearningPathResourceUncheckedUpdateWithoutResourceInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathResourceUncheckedUpdateManyWithoutResourceInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathItemUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    learningPath?: LearningPathUpdateOneRequiredWithoutContentsNestedInput
    course?: CourseUpdateOneWithoutLearningPathItemsNestedInput
    workshop?: WorkshopUpdateOneWithoutLearningPathItemsNestedInput
  }

  export type LearningPathItemUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LearningPathItemUncheckedUpdateManyWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    workshopId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseTagCreateManyTagInput = {
    courseId: string
  }

  export type WorkshopTagCreateManyTagInput = {
    workshopId: string
  }

  export type LearningPathTagCreateManyTagInput = {
    learningPathId: string
  }

  export type CourseTagUpdateWithoutTagInput = {
    course?: CourseUpdateOneRequiredWithoutTagsNestedInput
  }

  export type CourseTagUncheckedUpdateWithoutTagInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTagUncheckedUpdateManyWithoutTagInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopTagUpdateWithoutTagInput = {
    workshop?: WorkshopUpdateOneRequiredWithoutTagsNestedInput
  }

  export type WorkshopTagUncheckedUpdateWithoutTagInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopTagUncheckedUpdateManyWithoutTagInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathTagUpdateWithoutTagInput = {
    learningPath?: LearningPathUpdateOneRequiredWithoutTagsNestedInput
  }

  export type LearningPathTagUncheckedUpdateWithoutTagInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathTagUncheckedUpdateManyWithoutTagInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseUpdateWithoutPromoCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCoursesNestedInput
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutPromoCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutCourseNestedInput
    resources?: CourseResourceUncheckedUpdateManyWithoutCourseNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutCourseNestedInput
    objectives?: CourseObjectiveUncheckedUpdateManyWithoutCourseNestedInput
    prerequisites?: CoursePrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutPromoCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkshopUpdateWithoutPromoCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutWorkshopsNestedInput
    tags?: WorkshopTagUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUpdateManyWithoutWorkshopNestedInput
    promotions?: PromotionUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutPromoCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: WorkshopTagUncheckedUpdateManyWithoutWorkshopNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutWorkshopNestedInput
    resources?: WorkshopResourceUncheckedUpdateManyWithoutWorkshopNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutWorkshopNestedInput
    objectives?: WorkshopObjectiveUncheckedUpdateManyWithoutWorkshopNestedInput
    prerequisites?: WorkshopPrerequisiteUncheckedUpdateManyWithoutWorkshopNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutWorkshopNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutWorkshopNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateManyWithoutPromoCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    statementsStartFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    statementsStartFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statementVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    solutionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solutionVideoKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningPathUpdateWithoutPromoCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLearningPathsNestedInput
    tags?: LearningPathTagUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUpdateManyWithoutLearningPathNestedInput
    promotions?: PromotionUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutPromoCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: LearningPathTagUncheckedUpdateManyWithoutLearningPathNestedInput
    contents?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutPathNestedInput
    resources?: LearningPathResourceUncheckedUpdateManyWithoutLearningPathNestedInput
    objectives?: LearningPathObjectiveUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: LearningPathPrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutLearningPathNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearningPathNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateManyWithoutPromoCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    smallDescription?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    title: string
    type: string
    referenceId: string
    quantity?: number
    unitPrice: number
    total: number
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    referenceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    referenceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    referenceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
  }

  export type CourseObjectiveCreateManyObjectiveInput = {
    courseId: string
  }

  export type WorkshopObjectiveCreateManyObjectiveInput = {
    workshopId: string
  }

  export type LearningPathObjectiveCreateManyObjectiveInput = {
    learningPathId: string
  }

  export type CourseObjectiveUpdateWithoutObjectiveInput = {
    course?: CourseUpdateOneRequiredWithoutObjectivesNestedInput
  }

  export type CourseObjectiveUncheckedUpdateWithoutObjectiveInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseObjectiveUncheckedUpdateManyWithoutObjectiveInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopObjectiveUpdateWithoutObjectiveInput = {
    workshop?: WorkshopUpdateOneRequiredWithoutObjectivesNestedInput
  }

  export type WorkshopObjectiveUncheckedUpdateWithoutObjectiveInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopObjectiveUncheckedUpdateManyWithoutObjectiveInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathObjectiveUpdateWithoutObjectiveInput = {
    learningPath?: LearningPathUpdateOneRequiredWithoutObjectivesNestedInput
  }

  export type LearningPathObjectiveUncheckedUpdateWithoutObjectiveInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathObjectiveUncheckedUpdateManyWithoutObjectiveInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
  }

  export type CoursePrerequisiteCreateManyPrerequisiteInput = {
    courseId: string
  }

  export type WorkshopPrerequisiteCreateManyPrerequisiteInput = {
    workshopId: string
  }

  export type LearningPathPrerequisiteCreateManyPrerequisiteInput = {
    learningPathId: string
  }

  export type CoursePrerequisiteUpdateWithoutPrerequisiteInput = {
    course?: CourseUpdateOneRequiredWithoutPrerequisitesNestedInput
  }

  export type CoursePrerequisiteUncheckedUpdateWithoutPrerequisiteInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CoursePrerequisiteUncheckedUpdateManyWithoutPrerequisiteInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopPrerequisiteUpdateWithoutPrerequisiteInput = {
    workshop?: WorkshopUpdateOneRequiredWithoutPrerequisitesNestedInput
  }

  export type WorkshopPrerequisiteUncheckedUpdateWithoutPrerequisiteInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopPrerequisiteUncheckedUpdateManyWithoutPrerequisiteInput = {
    workshopId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathPrerequisiteUpdateWithoutPrerequisiteInput = {
    learningPath?: LearningPathUpdateOneRequiredWithoutPrerequisitesNestedInput
  }

  export type LearningPathPrerequisiteUncheckedUpdateWithoutPrerequisiteInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
  }

  export type LearningPathPrerequisiteUncheckedUpdateManyWithoutPrerequisiteInput = {
    learningPathId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanySocialLinkCreateManyCompanyInput = {
    id?: string
    socialLinkId: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanySocialLinkUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLink?: SocialLinkUpdateOneRequiredWithoutCompanySocialLinkNestedInput
  }

  export type CompanySocialLinkUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    socialLinkId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySocialLinkUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    socialLinkId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySocialLinkCreateManySocialLinkInput = {
    id?: string
    companyId: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanySocialLinkUpdateWithoutSocialLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCompanySocialLinkNestedInput
  }

  export type CompanySocialLinkUncheckedUpdateWithoutSocialLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySocialLinkUncheckedUpdateManyWithoutSocialLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionCreateManyQuizInput = {
    id?: string
    question: string
    type?: string | null
  }

  export type QuizQuestionUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    options?: QuizOptionUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    options?: QuizOptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizOptionCreateManyQuestionInput = {
    id?: string
    content: string
    isCorrect?: boolean
  }

  export type QuizOptionUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuizOptionUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuizOptionUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}